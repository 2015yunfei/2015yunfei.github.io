1. 数论
2. 组合计数
3. 高斯消元
4. 简单博弈论

# 质数

- 质数是指在<u>**大于1**</u>的自然数中，除了1和它本身以外不再有其他因数的自然数
- 所有小于等于1的整数既不是质数也不是合数
- 质数和素数都是同一种性质,只是叫法不同

质数的判定：**试除法** 或 **六倍原理**

“d|n”代表的含义是d能整除n,(这里的”|”代表整除)



![image-20221228234305136](%E5%BA%93/image-20221228234305136.png)

## 试除法判定质数

```c++
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}
```



## AcWing 866. 试除法判定质数

https://www.acwing.com/problem/content/868/

给定 n 个正整数 ai，判定每个数是否是质数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个正整数 ai。

#### 输出格式

共 n 行，其中第 i 行输出第 i 个正整数 ai 是否为质数，是则输出 `Yes`，否则输出 `No`。

#### 数据范围

1≤n≤100
1≤ai≤231−1

#### 输入样例：

```
2
2
6
```

#### 输出样例：

```
Yes
No
```

```c++
#include <iostream>
#include <algorithm>

using namespace std;

bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
            return false;
    return true;
}

int main()
{
    int n;
    cin >> n;

    while (n -- )
    {
        int x;
        cin >> x;
        if (is_prime(x)) puts("Yes");
        else puts("No");
    }

    return 0;
}
```



## 试除法分解质因数

依旧是试除法。

从小到大枚举所有数

注意每个数最多包含一个大于 sqrt(n) 的质因子，比如 15 的质因子 5 

```c++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```



## AcWing 867. 分解质因数

https://www.acwing.com/problem/content/869/

给定 n 个正整数 ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个正整数 ai。

#### 输出格式

对于每个正整数 ai，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。

每个正整数的质因数全部输出完毕后，输出一个空行。

#### 数据范围

1≤n≤100
2≤ai≤2×109

#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
2 1
3 1

2 3
```

```c++
#include <iostream>
#include <algorithm>

using namespace std;

void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;//很关键
    cout << endl;
}

int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        divide(x);
    }

    return 0;
}
```



## AcWing 868. 筛质数

https://www.acwing.com/problem/content/870/

给定一个正整数 n，请你求出 1∼n 中质数的个数。

#### 输入格式

共一行，包含整数 n。

#### 输出格式

共一行，包含一个整数，表示 1∼n 中质数的个数。

#### 数据范围

1≤n≤106

#### 输入样例：

```
8
```

#### 输出样例：

```
4
```





![image-20221229083905903](%E5%BA%93/image-20221229083905903.png)

### 朴素筛法

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}
```

### 线性筛法

n 只会被最小的质因子筛掉

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];
 
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;//primes[j]一定是i的最小质因子
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}
```

### 自己写的

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;
bool st[N];
int n;
int cnt;

int main() {
    cin >> n;

    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            cnt++;
            for (int j = i; j <= n; j += i) st[j] = true;//光把所有质数的倍数删掉
        }
    }

    cout << cnt;
    return 0;
}
```



> 看了好几遍没看懂
>
> https://www.acwing.com/video/293/



# 约数

- 试除法求一个数的所有约数
- 约数个数
- 约数之和

![image-20221229094400131](%E5%BA%93/image-20221229094400131.png)

## 试除法求所有约数

```c++
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```



## AcWing 869. 试除法求约数

https://www.acwing.com/problem/content/871/

给定 n 个正整数 ai，对于每个整数 ai，请你按照从小到大的顺序输出它的所有约数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个整数 ai。

#### 输出格式

输出共 n 行，其中第 i 行输出第 i 个整数 ai 的所有约数。

#### 数据范围

1≤n≤100
2≤ai≤2×10^9^

#### 输入样例：

```
2
6
8
```

#### 输出样例：

```
1 2 3 6 
1 2 4 8
```

```c++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}

int main()
{
    int n;
    cin >> n;

    while (n -- )
    {
        int x;
        cin >> x;
        auto res = get_divisors(x);

        for (auto x : res) cout << x << ' ';
        cout << endl;
    }

    return 0;
}
```

## 约数个数和约数之和

如果 N = p1^c1 * p2^c2 * ... *pk^ck
约数个数： (c1 + 1) * (c2 + 1) * ... * (ck + 1)
约数之和： (p1^0 + p1^1 + ... + p1^c1) * ... * (pk^0 + pk^1 + ... + pk^ck)

![image-20230108134608269](%E5%BA%93/image-20230108134608269.png)

## AcWing 870. 约数个数

https://www.acwing.com/problem/content/872/

给定 n 个正整数 ai，请你输出这些数的乘积的约数个数，答案对 109+7 取模。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个整数 ai。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数个数，答案需对 109+7 取模。

#### 数据范围

1≤n≤100
1≤ai≤2×10^9^

#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
12
```

```c++
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 110, mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;

    unordered_map<int, int> primes;

    while (n -- )
    {
        int x;
        cin >> x;

        for (int i = 2; i <= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x > 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes) res = res * (p.second + 1) % mod;

    cout << res << endl;

    return 0;
}
```



## AcWing 871. 约数之和

https://www.acwing.com/problem/content/873/

给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 109+7 取模。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个整数 ai。

#### 输出格式

输出一个整数，表示所给正整数的乘积的约数之和，答案需对 109+7 取模。

#### 数据范围

1≤n≤100
1≤ai≤2×10^9^

#### 输入样例：

```
3
2
6
8
```

#### 输出样例：

```
252
```

```c++
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 110, mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;

    unordered_map<int, int> primes;

    while (n -- )
    {
        int x;
        cin >> x;

        for (int i = 2; i <= x / i; i ++ )
            while (x % i == 0)
            {
                x /= i;
                primes[i] ++ ;
            }

        if (x > 1) primes[x] ++ ;
    }

    LL res = 1;
    for (auto p : primes)
    {
        LL a = p.first, b = p.second;
        LL t = 1;
        while (b -- ) t = (t * a + 1) % mod;
        res = res * t % mod;
    }

    cout << res << endl;

    return 0;
}
```

## 欧几里得算法

```c++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```



## AcWing 872. 最大公约数

https://www.acwing.com/problem/content/874/

给定 n 对正整数 ai,bi，请你求出每对数的最大公约数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个整数对 ai,bi。

#### 输出格式

输出共 n 行，每行输出一个整数对的最大公约数。

#### 数据范围

1≤n≤105
1≤ai,bi≤2×109

#### 输入样例：

```
2
3 6
4 6
```

#### 输出样例：

```
3
2
```

欧几里得算法，也称作是辗转相除法

```c++
#include <iostream>
#include <algorithm>

using namespace std;


int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}


int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        printf("%d\n", gcd(a, b));
    }

    return 0;
}
```

## 求欧拉函数

欧拉函数的定义

![image-20221229121432313](%E5%BA%93/image-20221229121432313.png)

**求欧拉函数**

```c++
int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}
```

**筛法求欧拉函数**

```c++
int primes[N], cnt;     // primes[]存储所有素数
int euler[N];           // 存储每个数的欧拉函数
bool st[N];         // st[x]存储x是否被筛掉


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}
```



## AcWing 873. 欧拉函数

https://www.acwing.com/problem/content/875/.

给定 n 个正整数 ai，请你求出每个数的欧拉函数。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含一个正整数 ai。

#### 输出格式

输出共 n 行，每行输出一个正整数 ai 的欧拉函数。

#### 数据范围

1≤n≤100
1≤ai≤2×10^9^

#### 输入样例：

```
3
3
6
8
```

#### 输出样例：

```
2
2
4
```

### y总代码

```c++
#include <iostream>

using namespace std;


int phi(int x)
{
    int res = x;
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res = res / i * (i - 1);//记得要先写除法，再写乘法，避免溢出
            while (x % i == 0) x /= i;
        }
    if (x > 1) res = res / x * (x - 1);

    return res;
}


int main()
{
    int n;
    cin >> n;
    while (n -- )
    {
        int x;
        cin >> x;
        cout << phi(x) << endl;
    }

    return 0;
}
```

### 自己写得

```c++
#include<bits/stdc++.h>

using namespace std;

int main() {
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        int res = x;
        for (int i = 2; i <= x / i; ++i) {
            if (x % i == 0) {
                res = res / i * (i - 1);//记得要先写除法，再写乘法，避免溢出
                while (x % i == 0) x /= i;
            }
        }
        if (x > 1) res = res / x * (x - 1);
        cout << res << endl;
    }
    return 0;
}
```

## AcWing 874. 筛法求欧拉函数

https://www.acwing.com/problem/content/876/

给定一个正整数 n，求 1∼n 中每个数的欧拉函数之和。

#### 输入格式

共一行，包含一个整数 n。

#### 输出格式

共一行，包含一个整数，表示 1∼n 中每个数的欧拉函数之和。

#### 数据范围

1≤n≤106

#### 输入样例：

```
6
```

#### 输出样例：

```
12
```

```c++
#include <iostream>

using namespace std;

typedef long long LL;

const int N = 1000010;


int primes[N], cnt;
int euler[N];
bool st[N];


void get_eulers(int n)
{
    euler[1] = 1;
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i])
        {
            primes[cnt ++ ] = i;
            euler[i] = i - 1;
        }
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            int t = primes[j] * i;
            st[t] = true;
            if (i % primes[j] == 0)
            {
                euler[t] = euler[i] * primes[j];
                break;
            }
            euler[t] = euler[i] * (primes[j] - 1);
        }
    }
}


int main()
{
    int n;
    cin >> n;

    get_eulers(n);

    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += euler[i];

    cout << res << endl;

    return 0;
}
```



# 快速幂

```c++
求 m^k mod p，时间复杂度 O(logk)。

int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```



## AcWing 875. 快速幂

https://www.acwing.com/problem/content/877/

给定 n 组 ai,bi,pi，对于每组数据，求出 aibimodpi 的值。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含三个整数 ai,bi,pi

#### 输出格式

对于每组数据，输出一个结果，表示 aibimodpi 的值。

每个结果占一行。

#### 数据范围

1≤n≤100000
1≤ai,bi,pi≤2×10^9^

#### 输入样例：

```
2
3 2 5
4 3 9
```

#### 输出样例：

```
4
1
```

```c++
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;

LL qmi(int a, int b, int p)
{
    LL res = 1 % p;
    while (b)
    {
        if (b & 1) res = res * a % p;
        a = a * (LL)a % p;
        b >>= 1;
    }
    return res;
}

int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        int a, b, p;
        scanf("%d%d%d", &a, &b, &p);
        printf("%lld\n", qmi(a, b, p));
    }

    return 0;
}
```

模运算的性质: (a * b) % p = (a % p * b % p) % p

注意 res 的初始化 LL res = 1 % p;   不要写成 LL res = 1;   不然会在 p=1 的时候出现问题

