# 树状数组和线段树



# 树状数组

可以动态且快速地求前缀和

- 将序列中某个位置的数加上一个数——**单点修改**
- 求前缀和——**区间查询**



关于在线和离线：

- 在线做法是指支持修改
- 离线做法是指不支持修改



![image-20230117093341601](%E5%BA%93/image-20230117093341601.png)

![image-20230117093402942](%E5%BA%93/image-20230117093402942.png)



## AcWing 1264. 动态求连续区间和

https://www.acwing.com/problem/content/1266/

给定 n 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [a,b] 的连续和。

#### 输入格式

第一行包含两个整数 n 和 m，分别表示数的个数和操作次数。

第二行包含 n 个整数，表示完整数列。

接下来 m 行，每行包含三个整数 k,a,b （k=0，表示求子数列[a,b]的和；k=1，表示第 a 个数加 b）。

数列从 1 开始计数。

#### 输出格式

输出若干行数字，表示 k=0 时，对应的子数列 [a,b] 的连续和。

#### 数据范围

1≤n≤100000
1≤m≤100000
1≤a≤b≤n
数据保证在任何时候，数列中所有元素之和均在 int 范围内。

#### 输入样例：

```
10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
```

#### 输出样例：

```
11
30
35
```



```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int a[N], tr[N];

int lowbit(int x)
{
    return x & -x;
}

void add(int x, int v)
{
    for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
}

int query(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    for (int i = 1; i <= n; i ++ ) add(i, a[i]);

    while (m -- )
    {
        int k, x, y;
        scanf("%d%d%d", &k, &x, &y);
        if (k == 0) printf("%d\n", query(y) - query(x - 1));
        else add(x, y);
    }

    return 0;
}
```

这道题如果是使用`cin`来读入的话会非常慢，一般情况下读入次数在一万次左右的时候就要使用`scanf`了



## AcWing 1265. 数星星

https://www.acwing.com/problem/content/1267/

天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。

如果一个星星的左下方（包含正左和正下）有 k 颗星星，就说这颗星星是 k 级的。

![1.png](%E5%BA%93/19_6f40991a1c-1.png)

例如，上图中星星 5 是 3 级的（1,2,4 在它左下），星星 2,4 是 1 级的。

例图中有 1 个 0 级，2 个 1 级，1 个 2 级，1 个 3 级的星星。

给定星星的位置，输出各级星星的数目。

换句话说，给定 N 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。

#### 输入格式

第一行一个整数 N，表示星星的数目；

接下来 N 行给出每颗星星的坐标，坐标用两个整数 x,y 表示；

不会有星星重叠。星星按 y 坐标增序给出，y 坐标相同的按 x 坐标增序给出。

#### 输出格式

N 行，每行一个整数，分别是 0 级，1 级，2 级，……，N−1 级的星星的数目。

#### 数据范围

1≤N≤15000
0≤x,y≤32000

#### 输入样例：

```
5
1 1
5 1
7 1
3 3
5 5
```

#### 输出样例：

```
1
2
1
1
0
```



```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 32010;

int n;
int tr[N], level[N];

int lowbit(int x){
    return x & -x;
}

void add(int x){
    for (int i = x; i < N; i += lowbit(i)) tr[i] ++ ;
}

int sum(int x)
{
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) res += tr[i];
    return res;
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int x, y;
        scanf("%d%d", &x, &y);
        x ++ ;
        level[sum(x)] ++ ;
        add(x);
    }
    for (int i = 0; i < n; i ++ ) printf("%d\n", level[i]);
    return 0;
}
```

形象解释下为什么是 `i<N` ？

因为：回想一下这个树状数组的结构，最终的节点应该是最右上角的值，如果是`n`的话 `n`这个节点不一定处于最右上角，其实也可以取横坐标最大的点的正上方的点，为了保险起见，直接取`N`了



## AcWing 1215. 小朋友排队

https://www.acwing.com/problem/content/1217/

*n* 个小朋友站成一排。

现在要把他们按身高从低到高的顺序排列，但是每次只能交换位置相邻的两个小朋友。

每个小朋友都有一个不高兴的程度。开始的时候，所有小朋友的不高兴程度都是 0。

如果某个小朋友第一次被要求交换，则他的不高兴程度增加 1，如果第二次要求他交换，则他的不高兴程度增加 2（即不高兴程度为 3），依次类推。当要求某个小朋友第 *k* 次交换时，他的不高兴程度增加 *k*。

请问，要让所有小朋友按从低到高排队，他们的不高兴程度之和最小是多少。

如果有两个小朋友身高一样，则他们谁站在谁前面是没有关系的。

#### 输入格式

输入的第一行包含一个整数 *n*，表示小朋友的个数。第二行包含 *n* 个整数 *H*1,*H*2,…,*Hn*，分别表示每个小朋友的身高。

#### 输出格式

输出一行，包含一个整数，表示小朋友的不高兴程度和的最小值。

#### 数据范围

1≤*n*≤100000,0≤*Hi*≤1000000

#### 输入样例：

```
3
3 2 1
```

#### 输出样例：

```
9
```

#### 样例解释

首先交换身高为3和2的小朋友，再交换身高为3和1的小朋友，再交换身高为2和1的小朋友，每个小朋友的不高兴程度都是3，总和为9。

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 1e6 + 10;
int n, h[N], tr[N], sum[N];

int lowbit(int x) {
    return x & -x;
}

void add(int x) {
    for (int i = x; i < N; i += lowbit(i)) tr[i] += 1;
}

int query(int x) {
    int res = 0;
    for (int i = x; i; i -= lowbit(i)) {
        res += tr[i];
    }
    return res;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) scanf("%d", &h[i]), h[i]++;
    for (int i = 0; i < n; ++i) {
        sum[i] += query(N - 1) - query(h[i]);
        add(h[i]);
    }
    memset(tr, 0, sizeof tr);
    for (int i = n - 1; i >= 0; --i) {
        sum[i] += query(h[i] - 1);
        add(h[i]);
    }
    LL res = 0;
    for (int i = 0; i < n; ++i) res += (LL) (1 + sum[i]) * sum[i] / 2;
    cout << res;
    return 0;
}
```

这个题实际上是逆序对，只不过稍稍变形，我们来看对于每个数来说他的逆序对怎么算，在这个数之前比这个数大的数+这个数之后比这个数小的数就是这个数的逆序对的个数（好绕口。。。慢慢体会）。这个逆序对个数其实代表了该数换位置的次数。

每次读入一个数就先把它放到树状数组中去，但这个**树状数组保存的并不是这个数，而是这个数出现的次数**

只要明白了这个道理就很简单了，放入完毕后，我们就去query一下这个数之前有多少个比他小的数，然后用当前数组长度减去比这个数小的数就是比这个数大的数的个数了（算比这个数大的个数）。比当前数靠后的且别当数小的数求法就是把这个树状数组给倒过来求一遍。



# 线段树

![123](./库/123.png)

## AcWing 1264. 动态求连续区间和

https://www.acwing.com/problem/content/1266/

给定 n 个数组成的一个数列，规定有两种操作，一是修改某个元素，二是求子数列 [a,b] 的连续和。

#### 输入格式

第一行包含两个整数 n 和 m，分别表示数的个数和操作次数。

第二行包含 n 个整数，表示完整数列。

接下来 m 行，每行包含三个整数 k,a,b （k=0，表示求子数列[a,b]的和；k=1，表示第 a 个数加 b）。

数列从 1 开始计数。

#### 输出格式

输出若干行数字，表示 k=0 时，对应的子数列 [a,b] 的连续和。

#### 数据范围

1≤n≤100000
1≤m≤100000
1≤a≤b≤n
数据保证在任何时候，数列中所有元素之和均在 int 范围内。

#### 输入样例：

```
10 5
1 2 3 4 5 6 7 8 9 10
1 1 5
0 1 3
0 4 8
1 7 5
0 4 8
```

#### 输出样例：

```
11
30
35
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int w[N];
struct Node {
    int l, r;
    int sum;
} tr[N * 4];

void pushup(int u) {
    tr[u].sum = tr[u << 1].sum + tr[u << 1 | 1].sum;
}

void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, w[r]};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }
}

int query(int u, int l, int r) {
    if (tr[u].l >= l && tr[u].r <= r) return tr[u].sum;
    int mid = tr[u].l + tr[u].r >> 1;
    int sum = 0;
    if (l <= mid) sum = query(u << 1, l, r);
    if (r > mid) sum += query(u << 1 | 1, l, r);
    return sum;
}

void modify(int u, int x, int v) {
    if (tr[u].l == tr[u].r) tr[u].sum += v;
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (x <= mid) modify(u << 1, x, v);
        else modify(u << 1 | 1, x, v);
        pushup(u);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
    build(1, 1, n);

    int k, a, b;
    while (m--) {
        scanf("%d%d%d", &k, &a, &b);
        if (k == 0) printf("%d\n", query(1, a, b));
        else modify(1, a, b);
    }
    return 0;
}
```



## AcWing 1270. 数列区间最大值

输入一串数字，给你 *M* 个询问，每次询问就给你两个数字 *X*,*Y*，要求你说出 *X* 到 *Y* 这段区间内的最大数。

#### 输入格式

第一行两个整数 *N*,*M* 表示数字的个数和要询问的次数；接下来一行为 *N* 个数；接下来 *M* 行，每行都有两个整数 *X*,*Y*。

#### 输出格式

输出共 *M* 行，每行输出一个数。

#### 数据范围

1≤*N*≤10^5^,1≤*M*≤10^6^,1≤*X*≤*Y*≤*N*, 数列中的数字均不超过2^31^−1

#### 输入样例：

```
10 2
3 2 4 5 6 8 1 2 9 7
1 4
3 8
```

#### 输出样例：

```
5
8
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
int n, m, w[N];
struct node {
    int l, r, maxx;
} tr[N * 4];

void build(int u, int l, int r) {
    if (l == r) tr[u] = {l, r, w[l]};
    else {
        tr[u] = {l, r};
        int mid = l + r >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        tr[u].maxx = max(tr[u << 1].maxx, tr[u << 1 | 1].maxx);
    }
}

int query(int u, int l, int r) {
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].maxx;
    int mid = tr[u].l + tr[u].r >> 1;
    int maxx = INT_MIN;
    if (l <= mid) maxx = max(maxx, query(u << 1, l, r));
    if (r >= mid + 1) maxx = max(maxx, query(u << 1 | 1, l, r));
    return maxx;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) scanf("%d", &w[i]);
    build(1, 1, n);
    int a, b;
    while (m--) {
        scanf("%d%d", &a, &b);
        printf("%d\n", query(1, a, b));
    }
    return 0;
}
```

利用线段树维护区间最大值



## AcWing 1228. 油漆面积

https://www.acwing.com/problem/content/1230/

X星球的一批考古机器人正在一片废墟上考古。

该区域的地面坚硬如石、平整如镜。

管理人员为方便，建立了标准的直角坐标系。

每个机器人都各有特长、身怀绝技。

它们感兴趣的内容也不相同。

经过各种测量，每个机器人都会报告一个或多个矩形区域，作为优先考古的区域。

矩形的表示格式为 (*x*1,*y*1,*x*2,*y*2)，代表矩形的两个对角点坐标。

为了醒目，总部要求对所有机器人选中的矩形区域涂黄色油漆。

小明并不需要当油漆工，只是他需要计算一下，一共要耗费多少油漆。

其实这也不难，只要算出所有矩形覆盖的区域一共有多大面积就可以了。

注意，各个矩形间可能重叠。

#### 输入格式

第一行，一个整数 *n*，表示有多少个矩形。接下来的 *n* 行，每行有 4 个整数 *x*1,*y*1,*x*2,*y*2，空格分开，表示矩形的两个对角顶点坐标。

#### 输出格式

一行一个整数，表示矩形覆盖的总面积。

#### 数据范围

1≤*n*≤10000,0≤*x*1,*x*2,*y*2,*y*2≤10000 数据保证 *x*1<*x*2 且 *y*1<*y*2。

#### 输入样例1：

```
3
1 5 10 10
3 1 20 20
2 7 15 17
```

#### 输出样例1：

```
340
```

#### 输入样例2：

```
3
5 2 10 6
2 7 12 10
8 1 15 15
```

#### 输出样例2：

```
128
```



```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;
const int N = 10010;
int n;

struct Segment {
    int x, y1, y2;
    int k;

    bool operator<(const Segment &t) const {
        return x < t.x;
    }
} seg[N * 2];

struct Node {
    int l, r;
    int cnt, len;
} tr[N * 4];

void pushup(int u) {
    if (tr[u].cnt > 0) tr[u].len = tr[u].r - tr[u].l + 1;
    else if (tr[u].l == tr[u].r) tr[u].len = 0;
    else tr[u].len = tr[u << 1].len + tr[u << 1 | 1].len;
}

void build(int u, int l, int r) {
    tr[u] = {l, r};
    if (l == r) return;
    int mid = l + r >> 1;
    build(u << 1, l, mid), build(u << 1 | 1, mid + 1, r);
}

void modify(int u, int l, int r, int k) {
    if (tr[u].l >= l && tr[u].r <= r) {
        tr[u].cnt += k;
        pushup(u);
    } else {
        int mid = tr[u].l + tr[u].r >> 1;
        if (l <= mid) modify(u << 1, l, r, k);
        if (r > mid) modify(u << 1 | 1, l, r, k);
        pushup(u);
    }
}

int main() {
    scanf("%d", &n);
    int m = 0;
    for (int i = 0; i < n; i++) {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        seg[m++] = {x1, y1, y2, 1};
        seg[m++] = {x2, y1, y2, -1};
    }
    sort(seg, seg + m);
    build(1, 0, 10000);
    int res = 0;
    for (int i = 0; i < m; i++) {
        if (i > 0) res += tr[1].len * (seg[i].x - seg[i - 1].x);
        modify(1, seg[i].y1, seg[i].y2 - 1, seg[i].k);
    }
    printf("%d\n", res);
    return 0;
}
```

扫描线套路：
从每个矩形的竖边，都做一条垂直的线
画完竖线之后统计面积
统计面积的方法：以每个柱形区域为单位来统计，如下图，每个颜色代表一个柱形区域

![image-20230323151146649](./库/image-20230323151146649.png)

每个柱形区域的面积就是这个`长条的宽度×阴影部分高度`
宽度就是柱形两边竖线的横坐标之差，设右边竖线横坐标为x~j~，左边竖线横坐标为x~i~，则宽度为x~j~−x~i~

那么现在的问题就变成了：如何快速统计出来每个区间内部阴影部分的高度`h`？

这就需要用到一个非常特殊的线段树了，之所以称之为“非常特殊”是因为这个做法比较难扩展，只适用于这一类题型。

线段树中的每个结点`struct Node`除了存储左右边间`l`, `r`，还要存储一个`cnt`，表示**当前区间被覆盖的次数**，
还有一个`len`，表示至少被覆盖一次的区间的总长度。这也就是说，当`cnt=0`时，`len`可能会表示当前区间的子区间被覆盖的长度。

另外，扫描线题型会用到懒标记延迟更新的思想，然后这类题型特殊的地方就是它的懒标记不更新，即不往下传（懒标记是`pushdown`操作，用父结点的信息更新子节点的信息）。

![52933_961bb22e0a-131231](./库/52933_961bb22e0a-131231.png)

那么我们现在再看一下它的每个标记真实的含义是什么，以及它的每个子节点的信息有什么特点。
`cnt`、`len`标记存的是**在不考虑父结点信息情况下**的结果。
**这两个标记不考虑上面的父结点信息，只考虑下面的子节点信息，这就是扫描线的特殊之处。**



## AcWing 1237. 螺旋折线

**这个题是个找规律的题目，不知道为什么在线段树的部分**

https://www.acwing.com/problem/content/1239/

如下图所示的螺旋折线经过平面上所有整点恰好一次。 

![p1.png](./库/19_95e6f22816-p1.png) 

对于整点 (*X*,*Y*)，我们定义它到原点的距离 *d**i**s*(*X*,*Y*) 是从原点到 (*X*,*Y*) 的螺旋折线段的长度。  

例如 *d**i**s*(0,1)=3,*d**i**s*(−2,−1)=9  

给出整点坐标 (*X*,*Y*)，你能计算出 *d**i**s*(*X*,*Y*) 吗？

#### 输入格式

包含两个整数 *X*,*Y*。

#### 输出格式

输出一个整数，表示 *d**i**s*(*X*,*Y*)。

#### 数据范围

−109≤*X*,*Y*≤109

#### 输入样例：

```
0 1
```

#### 输出样例：

```
3
```

**方法一**

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

int main() {
    int x, y;
    cin >> x >> y;
    if (abs(x) <= y)  // 在上方
    {
        int n = y;
        cout << (LL) (2 * n - 1) * (2 * n) + x - (-n) << endl;
    } else if (abs(y) <= x)  // 在右方
    {
        int n = x;
        cout << (LL) (2 * n) * (2 * n) + n - y << endl;
    } else if (abs(x) <= abs(y) + 1 && y < 0)  // 在下方
    {
        int n = abs(y);
        cout << (LL) (2 * n) * (2 * n + 1) + n - x << endl;
    } else  // 在左方
    {
        int n = abs(x);
        cout << (LL) (2 * n - 1) * (2 * n - 1) + y - (-n + 1) << endl;
    }
    return 0;
}
```

![image-20230330202326162](./库/image-20230330202326162.png)



**方法二**

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    long long x, y;
    cin >> x >> y;
    long long k = max(abs(x), abs(y));
    if (x >= y) cout << 4 * k * k + abs(x - k) + abs(y - k) << endl;
    else cout << 4 * k * k - abs(x - k) - abs(y - k) << endl;
    return 0;
}
```

找规律可以发现每层的右上角点所需步数为为4k^2^，求任意一个点的`dis`首先找到这个点所在的层数

- 如果在该层的左或上则减去该点到右上角曼哈顿距离
- 如果在该层的右或下则加上该点到右上角曼哈顿距离





# 双指针

## AcWing 1238. 日志统计

https://www.acwing.com/problem/content/1240/

小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有 NN 行。

其中每一行的格式是：

```
ts id  
```

表示在 ts 时刻编号 id 的帖子收到一个”赞”。

现在小明想统计有哪些帖子曾经是”热帖”。

如果一个帖子曾在任意一个长度为 D 的时间段内收到不少于 K 个赞，小明就认为这个帖子曾是”热帖”。

具体来说，如果存在某个时刻 T 满足该帖在 [T,T+D) 这段时间内(注意是左闭右开区间)收到不少于 K 个赞，该帖就曾是”热帖”。

给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。

#### 输入格式

第一行包含三个整数 N,D,K

以下 N 行每行一条日志，包含两个整数 ts 和 id。

#### 输出格式

按从小到大的顺序输出热帖 id。

每个 id 占一行。

#### 数据范围

1≤K≤N≤10^5^
0≤ts,id≤10^5^
1≤D≤10000

#### 输入样例：

```
7 10 2
0 1
0 10
10 10
10 1
9 1
100 3
100 3
```

#### 输出样例：

```
1
3
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
typedef pair<int, int> PII;

PII logs[N];
int k, n, d;
int cnt[N];
bool st[N];

int main() {
    cin >> n >> d >> k;

    for (int i = 0; i < n; i++) scanf("%d%d", &logs[i].first, &logs[i].second);

    sort(logs, logs + n);

    for (int i = 0, j = 0; i < n; ++i) {

        int id = logs[i].second;
        cnt[id]++;

        while (logs[i].first - logs[j].first >= d) {
            cnt[logs[j].second]--;
            ++j;
        }

        if (cnt[id] >= k) st[id] = true;
    }

    int res = 0;
    for (int i = 0; i < 1e5 + 8; i++) if (st[i]) printf("%d\n", i);
    return 0;
}
```

**注意体会双指针怎么样维护一个动态的区间**



## AcWing 1240. 完全二叉树的权值

https://www.acwing.com/problem/content/1242/

给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从上到下、从左到右的顺序依次是 A1,A2,⋅⋅⋅AN，如下图所示：

![QQ截图20191205124611.png](%E5%BA%93/19_2f0cae5817-QQ%E6%88%AA%E5%9B%BE20191205124611.png)

现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点权值之和最大？

如果有多个深度的权值和同为最大，请你输出其中最小的深度。

注：根的深度是 1。

#### 输入格式

第一行包含一个整数 N。

第二行包含 N 个整数 A1,A2,⋅⋅⋅AN

#### 输出格式

输出一个整数代表答案。

#### 数据范围

1≤N≤10^5^
−10^5^≤Ai≤10^5^

#### 输入样例：

```
7
1 6 5 4 3 2 1
```

#### 输出样例：

```
2
```

**自己写的**

虽然是双指针的题目，但是这个写法并没有利用双指针

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long LL;

const int N = 1e5 + 10;

int a[N];
int n;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    LL most = -1e18;
    int ans = 0;
    int k = 1;
    int ceng = 0;
    for (int i = 0; i < n;) {
        LL temp = 0;
        while (i < n && i < k) {
            temp += a[i];
            ++i;
        }
        ceng++;
        if (most < temp) {
            ans = ceng;
            most = temp;
        }
        k = (1 + k) * 2 - 1;
    }
    cout << ans;
    return 0;
}
```

**注意数据大小，这个题还是会爆 int 需要强制类型转换**

log（） 函数和 pow（）函数的精度不够，建议尽量不要涉及到浮点数计算

# BFS

队列→先进先出  对应 BFS 

栈→后进先出  用来解决类似递归的问题，计算机是怎么线性处理递归问题的？实际上就是利用栈来处理

## AcWing 1101. 献给阿尔吉侬的花束

https://www.acwing.com/problem/content/1103/

阿尔吉侬是一只聪明又慵懒的小白鼠，它最擅长的就是走各种各样的迷宫。

今天它要挑战一个非常大的迷宫，研究员们为了鼓励阿尔吉侬尽快到达终点，就在终点放了一块阿尔吉侬最喜欢的奶酪。

现在研究员们想知道，如果阿尔吉侬足够聪明，它最少需要多少时间就能吃到奶酪。

迷宫用一个 R×C 的字符矩阵来表示。

字符 S 表示阿尔吉侬所在的位置，字符 E 表示奶酪所在的位置，字符 # 表示墙壁，字符 . 表示可以通行。

阿尔吉侬在 1 个单位时间内可以从当前的位置走到它上下左右四个方向上的任意一个位置，但不能走出地图边界。

#### 输入格式

第一行是一个正整数 T，表示一共有 T 组数据。

每一组数据的第一行包含了两个用空格分开的正整数 R 和 C，表示地图是一个 R×C 的矩阵。

接下来的 R 行描述了地图的具体内容，每一行包含了 C 个字符。字符含义如题目描述中所述。保证有且仅有一个 S 和 E。

#### 输出格式

对于每一组数据，输出阿尔吉侬吃到奶酪的最少单位时间。

若阿尔吉侬无法吃到奶酪，则输出“oop!”（只输出引号里面的内容，不输出引号）。

每组数据的输出结果占一行。

#### 数据范围

1<T≤10
2≤R,C≤200

#### 输入样例：

```
3
3 4
.S..
###.
..E.
3 4
.S..
.E..
....
3 4
.S..
####
..E.
```

#### 输出样例：

```
5
1
oop!
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 210;

int n, m;
char g[N][N];
int dist[N][N];

int bfs(PII start, PII end)
{
    queue<PII> q;
    memset(dist, -1, sizeof dist);

    dist[start.x][start.y] = 0;
    q.push(start);

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= m) continue;  // 出界
            if (g[x][y] == '#') continue;  // 障碍物
            if (dist[x][y] != -1) continue;  // 之前已经遍历过

            dist[x][y] = dist[t.x][t.y] + 1;

            if (end == make_pair(x, y)) return dist[x][y];

            q.push({x, y});
        }
    }

    return -1;
}

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d%d", &n, &m);
        for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

        PII start, end;
        for (int i = 0; i < n; i ++ )
            for (int j = 0; j < m; j ++ )
                if (g[i][j] == 'S') start = {i, j};
                else if (g[i][j] == 'E') end = {i, j};

        int distance = bfs(start, end);
        if (distance == -1) puts("oop!");
        else printf("%d\n", distance);
    }

    return 0;
}
```



## AcWing 1113. 红与黑

https://www.acwing.com/problem/content/1115/

有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。

你站在其中一块黑色的瓷砖上，只能向相邻（上下左右四个方向）的黑色瓷砖移动。

请写一个程序，计算你总共能够到达多少块黑色的瓷砖。

#### 输入格式

输入包括多个数据集合。

每个数据集合的第一行是两个整数 W 和 H，分别表示 x 方向和 y 方向瓷砖的数量。

在接下来的 H 行中，每行包括 W 个字符。每个字符表示一块瓷砖的颜色，规则如下

1）‘.’：黑色的瓷砖；
2）‘#’：红色的瓷砖；
3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。

当在一行中读入的是两个零时，表示输入结束。

#### 输出格式

对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。

#### 数据范围

1≤W,H≤20

#### 输入样例：

```
6 9 
....#. 
.....# 
...... 
...... 
...... 
...... 
...... 
#@...# 
.#..#. 
0 0
```

#### 输出样例：

```
45
```

**洪水灌溉算法**

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;

const int N = 23;

char g[N][N];
bool st[N][N];
int n, m;
int cnt;
PII start;

void bfs() {
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    queue<PII> q;
    st[start.first][start.second] = true;
    q.push(start);
    cnt++;

    while (q.size()) {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; ++i) {
            int x = t.first + dx[i], y = t.second + dy[i];
            if (x < 0 || y < 0 || x >= n || y >= m) continue;
            if (!st[x][y]) {
                cnt++;
                st[x][y] = true;
                q.push({x, y});
            }
        }
    }
    return;
}

int main() {
    cin >> m >> n;
    while (m && n) {
        for (int i = 0; i < n; i++) scanf("%s", g[i]);

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++) {
                if (g[i][j] == '#') {
                    st[i][j] = true;
                } else if (g[i][j] == '@') start = {i, j};
            }
        bfs();

        cout << cnt << endl;
        
        cnt = 0;
        memset(st, false, sizeof st);
        memset(g, 0, sizeof g);
        
        cin >> m >> n;
    }
    return 0;
}
```

**多组测试数据的时候一定要记得利用 memset 函数重置相关数组的值**



## AcWing 1096. 地牢大师

https://www.acwing.com/problem/content/1098/

你现在被困在一个三维地牢中，需要找到最快脱离的出路！

地牢由若干个单位立方体组成，其中部分不含岩石障碍可以直接通过，部分包含岩石障碍无法通过。

向北，向南，向东，向西，向上或向下移动一个单元距离均需要一分钟。

你不能沿对角线移动，迷宫边界都是坚硬的岩石，你不能走出边界范围。

请问，你有可能逃脱吗？

如果可以，需要多长时间？

#### 输入格式

输入包含多组测试数据。

每组数据第一行包含三个整数 L,R,C 分别表示地牢层数，以及每一层地牢的行数和列数。

接下来是 L 个 R 行 C 列的字符矩阵，用来表示每一层地牢的具体状况。

每个字符用来描述一个地牢单元的具体状况。

其中, 充满岩石障碍的单元格用”#”表示，不含障碍的空单元格用”.”表示，你的起始位置用”S”表示，终点用”E”表示。

每一个字符矩阵后面都会包含一个空行。

当输入一行为”0 0 0”时，表示输入终止。

#### 输出格式

每组数据输出一个结果，每个结果占一行。

如果能够逃脱地牢，则输出”Escaped in x minute(s).”，其中X为逃脱所需最短时间。

如果不能逃脱地牢，则输出”Trapped!”。

#### 数据范围

1≤L,R,C≤100

#### 输入样例：

```
3 4 5
S....
.###.
.##..
###.#

#####
#####
##.##
##...

#####
#####
#.###
####E

1 3 3
S##
#E#
###

0 0 0
```

#### 输出样例：

```
Escaped in 11 minute(s).
Trapped!
```

**自己写的错误代码**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 106;

struct Point {
    int x, y, z;
};
Point q[N * N * N];
Point start, endpointf;
char g[N][N][N];
int dist[N][N][N];
int n, m, k;
int dx[6] = {1, -1, 0, 0, 0, 0};
int dy[6] = {0, 0, 1, -1, 0, 0};
int dz[6] = {0, 0, 0, 0, 1, -1};

void bfs() {
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y][start.z] = 0;
    q[0] = start;
    int hh = 0, tt = 0;
    while (hh <= tt) {
        auto t = q[hh++];
        for (int i = 0; i < 6; i++) {
            int x = t.x + dx[i], y = t.y + dy[i], z = t.z + dz[i];
            if (x < 0 || x >= n || y < 0 || y >= m || z < 0 || z >= k) continue;  // 出界
            if (g[x][y][z] == '#') continue;  // 有障碍物
            if (dist[x][y][z] != -1) continue;  // 之前走到过

            dist[x][y][z] = dist[t.x][t.y][t.z] + 1;
            if (x == endpointf.x && y == endpointf.y && z == endpointf.z) return;

            q[++tt] = {x, y, z};
        }
    }
}

int main() {
    cin >> n >> m >> k;
    while (n && k && m) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                for (int z = 0; z < k; ++z) {
                    scanf("%c", &g[i][j][z]);
                    if (g[i][j][z] == 'S') start = {i, j, z};
                    else if (g[i][j][z] == 'E') endpointf = {i, j, z};
                }
        bfs();

        if (dist[endpointf.x][endpointf.y][endpointf.z] == -1) puts("Trapped!");
        else cout << dist[endpointf.x][endpointf.y][endpointf.z] << endl;
        cin >> n >> m >> k;
    }
    return 0;
}
```

本例的错误在于读入数据的时候使用 scanf("%c", &g[i] [j] [k]) 处理每个坐标上的字符。这句话有问题，会读入多余的**回车字符**

这里应该联想到二维时读入使用的是

```c++
for (int i = 0; i < n; i++) scanf("%s", g[i]);
```



**y总代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

struct Point
{
    int x, y, z;
};

int L, R, C;
char g[N][N][N];
Point q[N * N * N];
int dist[N][N][N];

int dx[6] = {1, -1, 0, 0, 0, 0};
int dy[6] = {0, 0, 1, -1, 0, 0};
int dz[6] = {0, 0, 0, 0, 1, -1};

int bfs(Point start, Point end)
{
    int hh = 0, tt = 0;
    q[0] = start;
    memset(dist, -1, sizeof dist);
    dist[start.x][start.y][start.z] = 0;

    while (hh <= tt)
    {
        auto t = q[hh ++ ];

        for (int i = 0; i < 6; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i], z = t.z + dz[i];
            if (x < 0 || x >= L || y < 0 || y >= R || z < 0 || z >= C) continue;  // 出界
            if (g[x][y][z] == '#') continue;  // 有障碍物
            if (dist[x][y][z] != -1) continue;  // 之前走到过

            dist[x][y][z] = dist[t.x][t.y][t.z] + 1;
            if (x == end.x && y == end.y && z == end.z) return dist[x][y][z];

            q[ ++ tt] = {x, y, z};
        }
    }

    return -1;
}

int main()
{
    while (scanf("%d%d%d", &L, &R, &C), L || R || C)
    {
        Point start, end;
        for (int i = 0; i < L; i ++ )
            for (int j = 0; j < R; j ++ )
            {
                scanf("%s", g[i][j]);
                for (int k = 0; k < C; k ++ )
                {
                    char c = g[i][j][k];
                    if (c == 'S') start = {i, j, k};
                    else if (c == 'E') end = {i, j, k};
                }
            }

        int distance = bfs(start, end);
        if (distance == -1) puts("Trapped!");
        else printf("Escaped in %d minute(s).\n", distance);
    }

    return 0;
}
```



## AcWing 1233. 全球变暖

https://www.acwing.com/problem/content/1235/

你有一张某海域 N×N 像素的照片，”.”表示海洋、”#”表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中”上下左右”四个方向上连在一起的一片陆地组成一座岛屿，例如上图就有 2 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。

具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。

#### 输入格式

第一行包含一个整数N。

以下 N 行 N 列，包含一个由字符”#”和”.”构成的 N×N 字符矩阵，代表一张海域照片，”#”表示陆地，”.”表示海洋。

照片保证第 1 行、第 1 列、第 N 行、第 N 列的像素都是海洋。

#### 输出格式

一个整数表示答案。

#### 数据范围

1≤N≤1000

#### 输入样例1：

```
7
.......
.##....
.##....
....##.
..####.
...###.
.......
```

#### 输出样例1：

```
1
```

#### 输入样例2：

```
9
.........
.##.##...
.#####...
.##.##...
.........
.##.#....
.#.###...
.#..#....
.........
```

#### 输出样例2：

```
1
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 1010;

int n;
char g[N][N];
bool st[N][N];
PII q[N * N];
int dx[4] = {-1, 0, 1, 0};
int dy[4] = {0, 1, 0, -1};

void bfs(int sx, int sy, int &total, int &bound)
{
    int hh = 0, tt = 0;
    q[0] = {sx, sy};
    st[sx][sy] = true;

    while (hh <= tt)
    {
        PII t = q[hh ++ ];

        total ++ ;
        bool is_bound = false;
        for (int i = 0; i < 4; i ++ )
        {
            int x = t.x + dx[i], y = t.y + dy[i];
            if (x < 0 || x >= n || y < 0 || y >= n) continue;  // 出界
            if (st[x][y]) continue;
            if (g[x][y] == '.')
            {
                is_bound = true;
                continue;
            }

            q[ ++ tt] = {x, y};
            st[x][y] = true;//注意在这里设置 st[x][y] = true 避免同一个坐标被反复加入到队列中去
        }

        if (is_bound) bound ++ ;
    }
}

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ ) scanf("%s", g[i]);

    int cnt = 0;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            if (!st[i][j] && g[i][j] == '#')
            {
                int total = 0, bound = 0;
                bfs(i, j, total, bound);
                if (total == bound) cnt ++ ;
            }

    printf("%d\n", cnt);

    return 0;
}
```



# 图论

## AcWing 1224. 交换瓶子

https://www.acwing.com/problem/content/1226/

有 N 个瓶子，编号 1∼N，放在架子上。

比如有 5 个瓶子：

```
2 1 3 5 4
```

要求每次拿起 2 个瓶子，交换它们的位置。

经过若干次后，使得瓶子的序号为：

```
1 2 3 4 5
```

对于这么简单的情况，显然，至少需要交换 2 次就可以复位。

如果瓶子更多呢？你可以通过编程来解决。

#### 输入格式

第一行包含一个整数 N，表示瓶子数量。

第二行包含 N 个整数，表示瓶子目前的排列状况。

#### 输出格式

输出一个正整数，表示至少交换多少次，才能完成排序。

#### 数据范围

1≤N≤10000

#### 输入样例1：

```
5
3 1 2 5 4
```

#### 输出样例1：

```
3
```

#### 输入样例2：

```
5
5 4 3 2 1
```

#### 输出样例2：

```
2
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010;

int n;
int b[N];
bool st[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &b[i]);

    int cnt = 0;  // cnt表示有多少个环
    for (int i = 1; i <= n; i ++ )
        if (!st[i])
        {
            cnt ++ ;
            for (int j = i; !st[j]; j = b[j])
                st[j] = true;
        }

    printf("%d\n", n - cnt);

    return 0;
}
```

![image-20230104161918750](%E5%BA%93/image-20230104161918750.png)

![image-20230104161902171](%E5%BA%93/image-20230104161902171.png)

## AcWing 1207. 大臣的旅费

https://www.acwing.com/problem/content/1209/

很久以前，T王国空前繁荣。

为了更好地管理国家，王国修建了大量的快速路，用于连接首都和王国内的各大城市。

为节省经费，T国的大臣们经过思考，制定了一套优秀的修建方案，使得任何一个大城市都能从首都直接或者通过其他大城市间接到达。

同时，如果不重复经过大城市，从首都到达每个大城市的方案都是唯一的。

J是T国重要大臣，他巡查于各大城市之间，体察民情。

所以，从一个城市马不停蹄地到另一个城市成了J最常做的事情。

他有一个钱袋，用于存放往来城市间的路费。

聪明的J发现，如果不在某个城市停下来修整，在连续行进过程中，他所花的路费与他已走过的距离有关，在走第x千米到第x+1千米这一千米中（x是整数），他花费的路费是x+10这么多。也就是说走1千米花费11，走2千米要花费23。

J大臣想知道：他从某一个城市出发，中间不休息，到达另一个城市，所有可能花费的路费中最多是多少呢？

#### 输入格式

输入的第一行包含一个整数 n，表示包括首都在内的T王国的城市数。

城市从 1 开始依次编号，1 号城市为首都。

接下来 n−1 行，描述T国的高速路（T国的高速路一定是 n−1 条）。

每行三个整数 Pi,Qi,Di，表示城市 Pi 和城市 Qi 之间有一条**双向**高速路，长度为 Di 千米。

#### 输出格式

输出一个整数，表示大臣J最多花费的路费是多少。

#### 数据范围

1≤n≤10^5^
1≤Pi,Qi≤n
1≤Di≤1000

#### 输入样例：

```
5 
1  2  2 
1  3  1 
2  4  5 
2  5  4 
```

#### 输出样例：

```
135
```

根据题意可以发现是一个树，也就是图中没有环

**用 vector 存储图**

```c++
 #include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Edge
{
    int id, w;
};
vector<Edge> h[N];
int dist[N];//表示到起点的距离

void dfs(int u, int father, int distance)
{
    dist[u] = distance;

    for (auto node : h[u])
        if (node.id != father)
            dfs(node.id, u, distance + node.w);
}

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        h[a].push_back({b, c});
        h[b].push_back({a, c});
    }

    dfs(1, -1, 0);

    int u = 1;
    for (int i = 1; i <= n; i ++ )
        if (dist[i] > dist[u])
            u = i;

    dfs(u, -1, 0);

    for (int i = 1; i <= n; i ++ )
        if (dist[i] > dist[u])
            u = i;

    int s = dist[u];

    printf("%lld\n", s * 10 + s * (s + 1ll) / 2);
	//这里不要自作聪明写成printf("%lld\n", s * 10 + s / 2 * (s + 1ll));
    return 0;
}
```

![image-20230106081504271](%E5%BA%93/image-20230106081504271.png)

从任一点开始，求一遍路径长度，找到最远的点，再求一遍路径长度

为什么是对的？

![image-20230106082041802](%E5%BA%93/image-20230106082041802.png)

图的存储

![image-20230106082152246](%E5%BA%93/image-20230106082152246.png)

**用数组模拟邻接表存储图**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n;
int h[N], e[M], w[M], ne[M], idx;
int dist[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u, int father, int distance)
{
    dist[u] = distance;
    for (int i = h[u]; ~i; i = ne[i])
    {
        int j = e[i];
        if (j != father)
            dfs(j, u, distance + w[i]);
    }
}

int main()
{
    scanf("%d", &n);
    memset(h, -1, sizeof h);

    for (int i = 0; i < n - 1; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c), add(b, a, c);
    }

    dfs(1, -1, 0);

    int u = 1;
    for (int i = 2; i <= n; i ++ )
        if (dist[u] < dist[i])
            u = i;

    dfs(u, -1, 0);

    for (int i = 1; i <= n; i ++ )
        if (dist[u] < dist[i])
            u = i;

    printf("%lld\n", dist[u] * 10 + (dist[u] + 1ll) * dist[u] / 2);

    return 0;
}
```



# 贪心

## AcWing 1055. 股票买卖 II

https://www.acwing.com/problem/content/1057/

给定一个长度为 N 的数组，数组中的第 i 个数字表示一个给定股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

#### 输入格式

第一行包含整数 N，表示数组长度。

第二行包含 N 个不大于 10000 的正整数，表示完整的数组。

#### 输出格式

输出一个整数，表示最大利润。

#### 数据范围

1≤N≤10^5^

#### 输入样例1：

```
6
7 1 5 3 6 4
```

#### 输出样例1：

```
7
```

#### 输入样例2：

```
5
1 2 3 4 5
```

#### 输出样例2：

```
4
```

#### 输入样例3：

```
5
7 6 4 3 1
```

#### 输出样例3：

```
0
```

#### 样例解释

样例1：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。共得利润 4+3 = 7。

样例2：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

样例3：在这种情况下, 不进行任何交易, 所以最大利润为 0。



<u>贪心问题的做法就是策略</u>

依次看相邻两天，只要第二天大于第一天，就在第一天买入，第二天卖出

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long LL;

const int N = 1e5 + 10;
int a[N];
int n;

int main() {
    cin >> n;

    for (int i = 0; i < n; ++i) scanf("%d", &a[i]);

    LL res = 0;
    for (int i = 0; i < n - 1; i++) {
        if (a[i] < a[i + 1]) res += a[i + 1] - a[i];
    }

    cout << res;
    return 0;
}
```



## AcWing 104. 货仓选址

https://www.acwing.com/problem/content/106/

在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

#### 输入格式

第一行输入整数 N

第二行 N 个整数 A1∼AN

#### 输出格式

输出一个整数，表示距离之和的最小值。

#### 数据范围

1≤N≤100000
0≤Ai≤40000

#### 输入样例：

```
4
6 2 9 1
```

#### 输出样例：

```
12
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;

int a[N];
int n;

int main() {
    cin >> n;

    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    sort(a, a + n);

    int res = 0;
    for (int i = 0, j = n - 1; i < j; ++i, --j) {
        res += a[j] - a[i];
    }
    cout << res;
    return 0;
}
```



## AcWing 122. 糖果传递

https://www.acwing.com/problem/content/124/

有 n 个小朋友坐成一圈，每人有 a[i] 个糖果。

每人只能给左右两人传递糖果。

每人每次传递一个糖果代价为 1。

求使所有人获得均等糖果的最小代价。

#### 输入格式

第一行输入一个正整数 n，表示小朋友的个数。

接下来 n 行，每行一个整数 a[i]，表示第 i 个小朋友初始得到的糖果的颗数。

#### 输出格式

输出一个整数，表示最小代价。

#### 数据范围

1≤n≤1000000
0≤a[i]≤2×10^9^
数据保证一定有解。

#### 输入样例：

```
4
1
2
5
4
```

#### 输出样例：

```
4
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1000010;

int n;
int a[N];
LL c[N];

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);

    LL sum = 0;
    for (int i = 1; i <= n; i ++ ) sum += a[i];

    LL avg = sum / n;
    for (int i = n; i > 1; i -- )
    {
        c[i] = c[i + 1] + avg - a[i];
    }
    c[1] = 0;

    sort(c + 1, c + n + 1);

    LL res = 0;
    for (int i = 1; i <= n; i ++ ) res += abs(c[i] - c[(n + 1) / 2]);

    printf("%lld\n", res);

    return 0;
}
```



> 纸牌均分问题与环形纸牌均分问题的探讨和数学推导：
>
> https://www.acwing.com/solution/content/41677/



**自己写的**

跟y总思路一样

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long LL;

const int N = 1e6 + 10;

int a[N], n;
int c[N];

int main() {
    cin >> n;

    LL pj = 0;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        pj += a[i];
    }
    pj /= n;

    for (int i = n; i > 1; i--) c[i] = c[i + 1] + pj - a[i];// 为了清楚把 a 和 c 数组分开了
    c[1] = 0;// 全局数组不写也是 0
    sort(c + 1, c + n + 1);
    LL res = 0;
    for (int i = 1, j = n; i < j; ++i, --j) res += c[j] - c[i];

    cout << res;
    return 0;
}   
```

## AcWing 112. 雷达设备

https://www.acwing.com/problem/content/114/

假设海岸是一条无限长的直线，陆地位于海岸的一侧，海洋位于另外一侧。

每个小岛都位于海洋一侧的某个点上。

雷达装置均位于海岸线上，且雷达的监测范围为 d，当小岛与某雷达的距离不超过 d 时，该小岛可以被雷达覆盖。

我们使用笛卡尔坐标系，定义海岸线为 x 轴，海的一侧在 x 轴上方，陆地一侧在 x 轴下方。

现在给出每个小岛的具体坐标以及雷达的检测范围，请你求出能够使所有小岛都被雷达覆盖所需的最小雷达数目。

#### 输入格式

第一行输入两个整数 n 和 d，分别代表小岛数目和雷达检测范围。

接下来 n 行，每行输入两个整数，分别代表小岛的 x，y 轴坐标。

同一行数据之间用空格隔开。

#### 输出格式

输出一个整数，代表所需的最小雷达数目，若没有解决方案则所需数目输出 −1。

#### 数据范围

1≤n≤1000
−1000≤x,y≤1000

#### 输入样例：

```
3 2
1 2
-3 1
2 1
```

#### 输出样例：

```
2
```

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1010;
typedef pair<int, int> PII;
typedef pair<double, double> PDD;

struct Segment {
    double l, r;

    bool operator<(const Segment &t) const {
        return r < t.r;
    }
} seg[N];

int n, d;

int main() {
    cin >> n >> d;

    for (int i = 0; i < n; i++) {
        int x, y;
        cin >> x >> y;
        if (y <= d) seg[i] = {x - sqrt(d * d - y * y), x + sqrt(d * d - y * y)};
        else {
            puts("-1");
            return 0;
        }
    }

    sort(seg, seg + n);

    int cnt = 0;
    double last = -1e20;
    for (int i = 0; i < n; i++) {
        if (last < seg[i].l) {
            cnt++;
            last = seg[i].r;
        }
    }
    cout << cnt;
    return 0;
}
```



- 计算每个坐标所对应的区间，需要 O(n) 的计算量；
- 将所有区间排序需要 O(nlogn) 的计算量；
- 扫描所有区间需要 O(n) 的计算量；



> y总写的题解：
>
> https://www.acwing.com/solution/content/1061/



本题的本质还是涉及到贪心的区间选点问题，记得要及时回顾算法基础课所学的贪心问题

> AcWing 905. 区间选点
>
> https://www.acwing.com/problem/content/907/
>
> AcWing 908. 最大不相交区间数量
>
> https://www.acwing.com/problem/content/910/
>
> AcWing 906. 区间分组
>
> https://www.acwing.com/problem/content/908/
>
> AcWing 907. 区间覆盖
>
> https://www.acwing.com/problem/content/909/



## AcWing 1235. 付账问题

https://www.acwing.com/problem/content/1237/

几个人一起出去吃饭是常有的事。

但在结帐的时候，常常会出现一些争执。

现在有 n 个人出去吃饭，他们总共消费了 S 元。

其中第 i 个人带了 ai 元。

幸运的是，所有人带的钱的总数是足够付账的，但现在问题来了：每个人分别要出多少钱呢？

为了公平起见，我们希望在总付钱量恰好为 S 的前提下，最后每个人付的钱的标准差最小。

这里我们约定，每个人支付的钱数可以是任意非负实数，即可以不是 1 分钱的整数倍。

你需要输出最小的标准差是多少。

标准差的介绍：标准差是多个数与它们平均数差值的平方平均数，一般用于刻画这些数之间的“偏差有多大”。

形式化地说，设第 i 个人付的钱为 bi 元，那么标准差为 :

![p1.png](%E5%BA%93/19_6734517a16-p1.png)

#### 输入格式

第一行包含两个整数 n、S

第二行包含 n 个非负整数 a1, …, an

#### 输出格式

输出最小的标准差，四舍五入保留 4 位小数。

#### 数据范围

1≤n≤5×10^5^
0≤ai≤10^9^
0≤S≤10^15^

#### 输入样例1：

```
5 2333
666 666 666 666 666
```

#### 输出样例1：

```
0.0000
```

#### 输入样例2：

```
10 30
2 1 4 7 4 8 3 6 4 7
```

#### 输出样例2：

```
0.7928
```

```c++

```

**自己写的**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 5e5 + 10;

int a[N];
double b[N];
int n;

int main() {
    double to_pay = 0;
    cin >> n >> to_pay;
    double avg = to_pay / n;
    double bi = avg;

    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    sort(a, a + n);

    for (int i = 0; i < n; i++) {
        if (a[i] >= avg) {
            b[i] = avg;
            to_pay -= avg;
        } else {
            b[i] = a[i];
            to_pay -= a[i];
            avg = to_pay / (n - i - 1);
        }
    }

    long double ans = 0;
    for (int i = 0; i < n; i++) {
        ans += (b[i] - bi) * (b[i] - bi);
    }
    ans /= n;
    ans = sqrt(ans);

    printf("%.4Lf", ans);
    return 0;
}
```

最新加入的第11组数据需要将double 改为 long double并修改输出才能通过

long double 的输入输出格式为 ： %Lf



关于 double 的问题：



**y总代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 500010;

int n;
int a[N];

int main()
{
    long double s;
    cin >> n >> s;
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    sort(a, a + n);

    long double res = 0, avg = s / n;
    for (int i = 0; i < n; i ++ )
    {
        double cur = s / (n - i);
        if (a[i] < cur) cur = a[i];
        res += (cur - avg) * (cur - avg);
        s -= cur;
    }

    printf("%.4Lf\n", sqrt(res / n));

    return 0;
}
```



## AcWing 1239. 乘积最大

https://www.acwing.com/problem/content/1241/

给定 N 个整数 A1,A2,…AN

请你从中选出 K 个数，使其乘积最大。

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 1000000009 的余数。

注意，如果 X<0， 我们定义 XX 除以 1000000009 的余数是负(−X)除以 1000000009 的余数

即：0−((0−x)%1000000009)

#### 输入格式

第一行包含两个整数 N 和 K。

以下 N 行每行一个整数 Ai。

#### 输出格式

输出一个整数，表示答案。

#### 数据范围

1≤K≤N≤10^5^
−10^5^≤Ai≤10^5^

#### 输入样例1：

```
5 3
-100000
-10000
2
100000
10000
```

#### 输出样例1：

```
999100009
```

#### 输入样例2：

```
5 3
-100000
-100000
-2
-100000
-100000
```

#### 输出样例2：

```
-999999829
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010, mod = 1000000009;

int n, k;
int a[N];

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    sort(a, a + n);

    int res = 1;
    int l = 0, r = n - 1;
    int sign = 1;
    if (k % 2)
    {
        res = a[r -- ];
        k -- ;
        if (res < 0) sign = -1;
    }
    while (k)
    {
        LL x = (LL)a[l] * a[l + 1], y = (LL)a[r - 1] * a[r];
        if (x * sign > y * sign)
        {
            res = x % mod * res % mod;
            l += 2;
        }
        else
        {
            res = y % mod * res % mod;
            r -= 2;
        }
        k -= 2;
    }

    printf("%d\n", res);

    return 0;
}
```

这里有一个巨大的坑点

三种运算 * / % 的优先级相同，运算时从左向右结合，在本例中会造成一个问题

```c++
typedef longl ong int LL;
const int mod = 1000000009;
LL res=1;
int x=2; //此处 x 值接近 int 类型的上限
res =res % mod  * x % mod;//这种写法会爆 long long int ，导致精度丢失
res = x % mod * res % mod;//这种写法不会导致精度丢失
```

x 最大是 10^10^ ，如果不先取模的话， 和 res 相乘的结果最大是 10^19^ 级别，会超出 long long int 的范围



> 有两个非常典型的问题都在这个题的题解下面被提到了，可以复习一下。
>
> 一个是取模的顺序，一定是先比较大小，再取模；
>
> 另外就是上面提到的运算顺序导致超出范围的问题。
>
> https://www.acwing.com/activity/content/code/content/196046/



## AcWing 1247. 后缀表达式

https://www.acwing.com/problem/content/description/1249/

给定 N 个加号、M 个减号以及 N+M+1 个整数 A1,A2,···,AN+M+1，小明想知道在所有由这 N 个加号、M 个减号以及 N+M+1 个整数凑出的合法的后缀表达式中，结果最大的是哪一个？

请你输出这个最大的结果。

例如使用 123+−，则 “23+1−” 这个后缀表达式结果是 4，是最大的。

#### 输入格式

第一行包含两个整数 N 和 M

第二行包含 N+M+1 个整数 A1,A2,⋅⋅⋅,AN+M+1

#### 输出格式

输出一个整数，代表答案。

#### 数据范围

0≤N,M≤10^5^
−10^9^≤Ai≤10^9^

#### 输入样例：

```
1 1
1 2 3
```

#### 输出样例：

```
4
```

**自己写的**

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long LL;

const int N = 2e5 + 20;

int a[N];
int n, m;

int main() {
    cin >> n >> m;
    int len = m + n + 1;

    for (int i = 0; i < len; ++i) scanf("%d", &a[i]);

    sort(a, a + len, greater<>());

    LL ans = a[0];
    if (!m) for (int i = 1; i < len; ++i) ans += a[i];
    else {
        for (int i = 1; i < len - 1; ++i) ans += abs(a[i]);
        ans -= a[len - 1];
    }

    cout << ans;
    return 0;
}
/*
10 10
88 0 67 80 63 40 14 72 46 65 18 46 -84 32 89 83 28 66 31 32 -18
1062
*/
```

**y总代码**

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 200010;

int n, m;
int a[N];

int main()
{
    scanf("%d%d", &n, &m);
    int k = n + m + 1;
    for (int i = 0; i < k; i ++ ) scanf("%d", &a[i]);

    LL res = 0;
    if (!m)
    {
        for (int i = 0; i < k; i ++ ) res += a[i];
    }
    else
    {
        sort(a, a + k);  // 也可以不排序，找出最大值和最小值即可

        res = a[k - 1] - a[0];
        for (int i = 1; i < k - 1; i ++ ) res += abs(a[i]);
    }

    printf("%lld\n", res);

    return 0;
}
```

**调整逆波兰表达式的顺序，等价于给原表达式加括号**

![image-20230106133024599](%E5%BA%93/image-20230106133024599.png)



## AcWing 1248. 灵能传输

https://www.acwing.com/problem/content/1250/

在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对一片区域内的敌军造成毁灭性的伤害。

经常用于对抗人类的生化部队和虫族的刺蛇飞龙等低血量单位。

你控制着 n 名高阶圣堂武士，方便起见标为 1,2,⋅⋅⋅,n

每名高阶圣堂武士需要一定的灵能来战斗，每个人有一个灵能值 aiai 表示其拥有的灵能的多少（ai 非负表示这名高阶圣堂武士比在最佳状态下多余了 ai 点灵能，ai 为负则表示这名高阶圣堂武士还需要 −ai 点灵能才能到达最佳战斗状态）。

现在系统赋予了你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i∈[2,n−1]，若 ai≥0 则其两旁的高阶圣堂武士，也就是 i−1、i+1 这两名高阶圣堂武士会从 i 这名高阶圣堂武士这里各抽取 ai 点灵能；若 ai<0 则其两旁的高阶圣堂武士，也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −ai 点灵能。

形式化来讲就是ai−1+=ai,ai+1+=ai,ai−=2ai。

灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为 maxni=1|ai|，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武士的不稳定度最小。

#### 输入格式

本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。

接下来依次输入每一组询问。

每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。

接下来一行包含 n 个数 a1,a2,⋅⋅⋅,an

#### 输出格式

输出 T 行。

每行一个整数依次表示每组询问的答案。

#### 数据范围

1≤T≤3,3≤n≤300000,|ai|≤10^9^
每个评测用例的限制如下：

![QQ截图20191205220735.png](%E5%BA%93/19_ba773c9e17-QQ%E6%88%AA%E5%9B%BE20191205220735.png)

#### 输入样例1：

```
3
3
5 -2 3
4
0 0 0 0
3
1 2 3
```

#### 输出样例1：

```
3
0
3
```

#### 输入样例2：

```
3
4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1
```

#### 输出样例2：

```
5
7
4
```

#### 样例解释

样例一
对于第一组询问：
对 2 号高阶圣堂武士进行传输操作后 a1=3，a2=2，a3=1。答案为 3。
对于第二组询问：
这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 300010;

int n;
LL a[N], s[N];
bool st[N];

int main()
{
    int T;
    scanf("%d", &T);
    while (T -- )
    {
        scanf("%d", &n);
        s[0] = 0;
        for (int i = 1; i <= n; i ++ )
        {
            scanf("%lld", &a[i]);
            s[i] = s[i - 1] + a[i];
        }

        LL s0 = s[0], sn = s[n];
        if (s0 > sn) swap(s0, sn);
        sort(s, s + n + 1);

        for (int i = 0; i <= n; i ++ )
            if (s[i] == s0)
            {
                s0 = i;
                break;
            }

        for (int i = n; i >= 0; i -- )
            if (s[i] == sn)
            {
                sn = i;
                break;
            }

        memset(st, 0, sizeof st);
        int l = 0, r = n;
        for (int i = s0; i >= 0; i -= 2)
        {
            a[l ++ ] = s[i];
            st[i] = true;
        }
        for (int i = sn; i <= n; i += 2)
        {
            a[r -- ] = s[i];
            st[i] = true;
        }
        for (int i = 0; i <= n; i ++ )
            if (!st[i])
                a[l ++ ] = s[i];

        LL res = 0;
        for (int i = 1; i <= n; i ++ ) res = max(res, abs(a[i] - a[i - 1]));

        printf("%lld\n", res);
    }

    return 0;
}
```



![image-20230106165351817](%E5%BA%93/image-20230106165351817.png)



# 数学知识

## AcWing 1246. 等差数列

https://www.acwing.com/problem/content/1248/

数学老师给小明出了一道等差数列求和的题目。

但是粗心的小明忘记了一部分的数列，只记得其中 N 个整数。

现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有几项？

#### 输入格式

输入的第一行包含一个整数 N。

第二行包含 N 个整数 A1,A2,···,AN。(注意 A1∼AN 并不一定是按等差数列中的顺序给出)

#### 输出格式

输出一个整数表示答案。

#### 数据范围

2≤N≤100000
0≤Ai≤10^9^

#### 输入样例：

```
5
2 6 4 10 20
```

#### 输出样例：

```
10
```

#### 样例解释

包含 2、6、4、10、202、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、18、20

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int a[N];

int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    sort(a, a + n);

    int d = 0;
    for (int i = 1; i < n; i ++ ) d = gcd(d, a[i] - a[0]);

    if (!d) printf("%d\n", n);
    else printf("%d\n", (a[n - 1] - a[0]) / d + 1);

    return 0;
}
```

![image-20230107095720652](%E5%BA%93/image-20230107095720652.png)



## AcWing 1295. X的因子链

https://www.acwing.com/problem/content/1297/

输入正整数 X，求 X 的大于 1 的因子组成的满足任意前一项都能整除后一项的严格递增序列的最大长度，以及满足最大长度的序列的个数。

#### 输入格式

输入包含多组数据，每组数据占一行，包含一个正整数表示 X。

#### 输出格式

对于每组数据，输出序列的最大长度以及满足最大长度的序列的个数。

每个结果占一行。

#### 数据范围

1≤X≤2^20^

#### 输入样例：

```
2
3
4
10
100
```

#### 输出样例：

```
1 1
1 1
2 1
2 2
4 6
```

![image-20230107102509892](%E5%BA%93/image-20230107102509892.png)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = (1 << 20) + 10;
typedef long long LL;

int primes[N];
int minp[N];
bool st[N];
int cnt;

void get(int n) {
    for (int i = 2; i <= n; ++i) {
        if (!st[i]) {
            minp[i] = i;
            primes[cnt++] = i;
        }
        for (int j = 0; primes[j] * i <= n; ++j) {
            st[primes[j] * i] = true;
            minp[primes[j] * i] = primes[j];
            if (i % primes[j] == 0) break;
        }
    }
}


int main() {
    get(N);

    int sum[30];

    int x;
    while (scanf("%d", &x) != -1) {
        int k = 0, tot = 0;
        while (x > 1) {
            int p = minp[x];
            sum[k] = 0;
            while (x % p == 0) {
                x /= p;
                sum[k]++;
                tot++;
            }
            k++;
        }
        LL res = 1;

        for (int i = 1; i <= tot; ++i) res *= i;

        for (int i = 0; i < k; ++i)
            for (int j = 1; j <= sum[i]; ++j)
                res /= j;

        printf("%d %lld\n", tot, res);
    }
    return 0;
}
```

```c++
void get_primes(int n)
{
    for (int i = 2; i <= n; ++i) {
        if (!st[i]) {
            minp[i] = i;
            primes[cnt++] = i;
        }
        for (int j = 0; primes[j] * i <= n; ++j) {
            st[primes[j] * i] = true;
            minp[primes[j] * i] = primes[j];
            if (i % primes[j] == 0) break;
        }
    }
}
```

![image-20230107104544902](%E5%BA%93/image-20230107104544902.png)





约数个数与约数之和

![image-20230108134620436](%E5%BA%93/image-20230108134620436.png)

## AcWing 1296. 聪明的燕姿

https://www.acwing.com/problem/content/1298/

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！

燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 S，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 S。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）。

可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

#### 输入格式

输入包含 k 组数据。

对于每组数据，输入包含一个号码牌 S。

#### 输出格式

对于每组数据，输出有两行。

第一行包含一个整数 m，表示有 m 个等的人。

第二行包含相应的 m 个数，表示所有等的人的号码牌。

注意：你输出的号码牌必须按照升序排列。

#### 数据范围

1≤k≤100
1≤S≤2×10^9^

#### 输入样例：

```
42
```

#### 输出样例：

```
3
20 26 41
```

