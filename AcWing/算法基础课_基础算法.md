

> 关于 #include<bits/stdc++.h>
>
> 1. 万能头是 GCC 支持的，如果遇见 VS 或者 clang 编译器就没有办法使用了。像 mac 里面默认的就是 clang 编译器
> 2. 比赛时候可能不支持，然后导入太多文件之后可能会有重名的问题，不好排查

# 快速排序

快速排序不稳定。要想使快速排序变成稳定的，就要构造成一个没有相同元素的数组。比如利用结构体或者元组，即类似<元素值，下标>的形式，通过双关键字排序来保证稳定性。

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

## AcWing 785. 快速排序

**！！！注意快速排序这道题目的数据已加强，划分中点取左端点或右端点时会超时，改成取中点或者随机值即可**

https://www.acwing.com/problem/content/787/

给定你一个长度为 n 的整数数列。

请你使用快速排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

#### 输入格式

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。

#### 输出格式

输出共一行，包含 n 个整数，表示排好序的数列。

#### 数据范围

1≤n≤100000

#### 输入样例：

```
5
3 1 2 4 5
```

#### 输出样例：

```
1 2 3 4 5
```

```c++
#include<bits/stdc++.h>
using namespace std;
int a[100010];
void quick_sort(int a[],int l,int r){
	if(l>=r)return ;
	int i=l-1,j=r+1,x=a[l+r>>1];
	while(i<j){
		do i++;while(a[i]<x);
		do j--;while(a[j]>x);
		if(i<j)swap(a[i],a[j]);
	}
	quick_sort(a,l,j);
	quick_sort(a,j+1,r);
	return ;
}
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;++i){
        scanf("%d",&a[i]);
    }
    quick_sort(a,0,n-1); 
    for(int i=0;i<n;++i){
        printf("%d ",a[i]);
    }
    return 0;
}
```

## AcWing 786. 第k个数

https://www.acwing.com/activity/content/problem/content/820/

给定一个长度为 n 的整数数列，以及一个整数 k，请用快速选择算法求出数列从小到大排序后的第 k 个数。

#### 输入格式

第一行包含两个整数 n 和 k。

第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整数数列。

#### 输出格式

输出一个整数，表示数列的第 k 小数。

#### 数据范围

1≤n≤100000
1≤k≤n

#### 输入样例：

```
5 3
2 4 1 5 3
```

#### 输出样例：

```
3
```

**自己写的快速排序算法**

```c++
#include<bits/stdc++.h>
using namespace std;
int a[100010];
void quick_sort(int a[],int l,int r){
	if(l>=r)return ;
	int i=l-1,j=r+1,x=a[l+r>>1];
	while(i<j){
		do i++; while(a[i]<x);
		do j--; while(a[j]>x);
		if(i<j)swap(a[i],a[j]);
	}
	quick_sort(a,l,j);
	quick_sort(a,j+1,r);
}
int main(){
	int n,k;
	cin>>n>>k;
	for(int i=0;i<n;++i)scanf("%d",&a[i]);
	quick_sort(a,0,n-1);
	cout<<a[k-1];
	return 0;
}
```

**y总手写快速选择算法**

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int q[N];

int quick_sort(int q[], int l, int r, int k)
{
    if (l >= r) return q[l];

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }

    if (j - l + 1 >= k) return quick_sort(q, l, j, k);
    else return quick_sort(q, j + 1, r, k - (j - l + 1));
}

int main()
{
    int n, k;
    scanf("%d%d", &n, &k);

    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    cout << quick_sort(q, 0, n - 1, k) << endl;

    return 0;
}
```

这个题目中使用快速选择算法会比使用快速排序算法快一倍。因为快速选择仅递归被选择的那一段，而快速排序会递归所有段。

Quick Selection算法和Quick Sort算法是由同一个作者提出，这两者之间有很大的相似之处——分治，即将问题的规模一次次的减小，直到求出最终解，时间复杂度O(n)，且数据无需有序。

Quick Selection复杂度分析：假设找的数以平均情况计算（被找的数每次都在中间部分），令O(N)为总的时间复杂度，N+O(N/2)为第O(N)次查找所需要的时间。按照以下公式进行递推，可以推出，最终O(N)近似等于2N，即O(N)=N。

而最坏情况时（被找的数每次都在最边上）O(N)=N^2^。当然也不用过于担心，有很多方式，通过重新洗牌，使数据尽量的无序，达到平均情况。(Shuffle、Turkeys’s ninth 等还是挺不错的)



STL 中的快速选择函数 nth_element( )  ：

nth_element() 函数有以下 2 种语法格式

```c++
//排序规则采用默认的升序排序
void nth_element (RandomAccessIterator first,
                  RandomAccessIterator nth,
                  RandomAccessIterator last);
//排序规则为自定义的 comp 排序规则
void nth_element (RandomAccessIterator first,
                  RandomAccessIterator nth,
                  RandomAccessIterator last,
                  Compare comp);
```

其中，各个参数的含义如下：

- first 和 last：都是随机访问迭代器，[first, last) 用于指定该函数的作用范围（即要处理哪些数据）
- nth：也是随机访问迭代器，默认情况下其功能是令函数查找“第 nth 小”的元素，并将其移动到 nth 指向的位置
- comp：用于自定义排序规则



nth_element(a,a+k,a+n)，**函数只是把下标为 k 的元素放在了正确位置**，对其它元素并没有排序，当然 k 左边元素都小于等于它，右边元素都大于等于它，所以可以利用这个函数快速定位某个元素

那求第 k 大时呢？我们可以转化成求第 n-k+1 小，此时下标应该是 n - k

- nth_element(a,a+n-k,a+n)，将下标为 n-k，也就是第 n-k+1 个数放在正确的位置，求的是第 k 大的数 a[n-k]
- 当然也可以把要处理的序列全变成负值，那样求得第 k 小就是第 k 大了



注意，鉴于 nth_element() 函数中各个参数的类型，其只能对普通数组或者部分容器进行排序。换句话说，只有普通数组和符合以下全部条件的容器，才能使用使用 nth_element() 函数：

1. 容器支持的迭代器类型必须为随机访问迭代器。这意味着，nth_element() 函数只适用于 array、vector、deque 这 3 个容器。
2. 当选用默认的升序排序规则时，容器中存储的元素类型必须支持 < 小于运算符；同样，如果选用标准库提供的其它排序规则，元素类型也必须支持该规则底层实现所用的比较运算符；
3. nth_element() 函数在实现过程中，需要交换某些元素的存储位置。因此，如果容器中存储的是自定义的类对象，则该类的内部必须提供移动构造函数和移动赋值运算符。

# 归并排序

需要创建一个临时数组，把待排序数组中的两段按照从小到大的顺序放进临时数组，最后再从临时数组中放回原数组

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```



可以说一下归并排序中为什么递归完之后会形成两个有序数组嘛？

答：整个递归执行过程是一棵二叉树，先会递归到整棵树的底部，底部只有一个节点一定有序，然后在回溯时不断合并相邻两个区间，每次合并之后都会将合并之后的区间排好序。那么当合并到根节点时，整个区间就有序了



> 这个问题可以看一下归并排序的动画演示
>
> https://juejin.cn/post/6844903717645352974



作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

- 自上而下的递归（所有递归的方法都可以用迭代重写）；
- 自下而上的迭代；



**算法演示：**

![img](%E5%BA%93/16733b1a9c74ce50tplv-t2oaga2asx-zoom-in-crop-mark4536000.gif)



排序动画过程解释：

1. 首先，将数字分割成两片区域
2. 将数字分割成两片区域
3. 。。。。。。
4. 直到每片区域只有一个元素
5. 分割完成
6. 接下来，将分割的每片区域进行合并组合
7. 合并时，按照数字的升序移动，使得合并后的数字在组内按升序排列
8. 当合并包含多个数字的组时，比较开头的数字，移动其中较小的数字
9. 比如在动画中，比较开头的 4 和 3
10. 其中 4 大于 3， 因此移动 3
11. 按照同样的逻辑去比较该列剩余的头数
12. 4 小于 7 ，所以移动 4
13. 。。。。。。
14. 递归的重复组的合并操作，直到所有数字都在一个组中。
15. 完成 归并排序 啦~



## AcWing 787. 归并排序

https://www.acwing.com/problem/content/789/

给定你一个长度为 n 的整数数列。

请你使用归并排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

#### 输入格式

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在 1∼109 范围内），表示整个数列。

#### 输出格式

输出共一行，包含 n 个整数，表示排好序的数列。

#### 数据范围

1≤n≤100000

#### 输入样例：

```
5
3 1 2 4 5
```

#### 输出样例：

```
1 2 3 4 5
```

```c++
#include<bits/stdc++.h>
using namespace std;
int a[100010];
int tmp[100010];
void merge_sort(int a[],int l,int r){
	if(l>=r)return;
	int mid=l+r>>1;
	merge_sort(a,l,mid);
	merge_sort(a,mid+1,r);
	int k=0,i=l,j=mid+1;
	while(i<=mid&&j<=r){
		if(a[i]<=a[j])tmp[k++]=a[i++];
		else tmp[k++]=a[j++];
	}
	while(i<=mid)tmp[k++]=a[i++];
	while(j<=r)tmp[k++]=a[j++];
	for(int i=l,j=0;i<=r;i++,j++)a[i]=tmp[j];
	return ;
} 
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;++i){
        scanf("%d",&a[i]);
    }
    merge_sort(a,0,n-1);
    for(int i=0;i<n;++i){
        printf("%d ",a[i]);
    }
    return 0;
}
```

## AcWing 788. 逆序对的数量

https://www.acwing.com/activity/content/problem/content/822/

给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]a[i]>a[j]，则其为一个逆序对；否则不是。

#### 输入格式

第一行包含整数 n，表示数列的长度。

第二行包含 n 个整数，表示整个数列。

#### 输出格式

输出一个整数，表示逆序对的个数。

#### 数据范围

1≤n≤100000
数列中的元素的取值范围1，109。

#### 输入样例：

```
6
2 3 4 5 6 1
```

#### 输出样例：

```
5
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int a[N]; 
int tmp[N];
unsigned long long int merge_sort(int l,int r){
	if(l>=r)return 0;
	int mid=r+l>>1;
	unsigned long long int res=merge_sort(l,mid)+merge_sort(mid+1,r);
	int i=l,j=mid+1,k=0;
	while(i<=mid&&j<=r){
		if(a[i]<=a[j])tmp[k++]=a[i++];
		else{
			tmp[k++]=a[j++];//妙极了 
			res+=mid-i+1;
		}
	}
	while(i<=mid)tmp[k++]=a[i++];
	while(j<=r)tmp[k++]=a[j++];
	for (int i=l,j=0;i<=r;i++,++j) a[i]=tmp[j];
	return res;
}
int main(){
	int n;
	unsigned long long int sum=0;
	cin>>n;
	for(int i=0;i<n;++i)scanf("%d",&a[i]);
	cout<<merge_sort(0,n-1);
	return 0;
}
```

![image-20221215195259547](%E5%BA%93/image-20221215195259547.png)

# 整数二分

有两个模板，分别适用于不同情况。

核心区别在于 mid 需不需要 +1



**二分与单调性的关系：**

有单调性一定可以二分

但是二分不一定都要求有单调性



**二分的本质：**

对于某种性质，可以将整个区间一分为二，即左边不满足某种性质，右边满足。则我们可以通过二分寻找这个性质在区间中的边界点。每次我们将还有答案的区间缩小一半，然后选择答案所在的区间进行下一步处理，逐渐逼近答案，最后的区间长度为1。

![image-20221215195310839](%E5%BA%93/image-20221215195310839.png)

红色和绿色边界对应着两个不同模板

对于二分无解的情况，并不是二分算法无解，而是题目无解。比如在左侧寻找第一个 ≥x 的值，如果没有那个数字是＞x 的值，则不存在 =x 的值，即二分查找 x 无解



步骤：

1. 先写 check() 函数
2. 考虑是 l = mid 还是 r = mid

![image-20221215195324786](%E5%BA%93/image-20221215195324786.png)



```c++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```



二分思想其实不是很难，注意边界的处理就可以了

```c++
int mid = l + r >> 1;
```

注意一定要让 mid 指针指向数组中间，不然个别测试数据可能过不了测试集



> 如果还不懂看一看下面的分析：
>
> **二分终极分析！！！**
>
> https://www.acwing.com/solution/content/123954/



## AcWing 789. 数的范围

https://www.acwing.com/problem/content/791/

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 输入格式

第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

#### 输出格式

共 q 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 数据范围

1≤n≤100000
1≤q≤10000
1≤k≤10000

#### 输入样例：

```
6 3
1 2 2 3 3 4
3
4
5
```

#### 输出样例：

```
3 4
5 5
-1 -1
```

```c++
#include<bits/stdc++.h>
using namespace std;
int a[100009];
int main(){
	int n,q;
	cin>>n>>q;
	for(int i=0;i<n;++i)scanf("%d",&a[i]);
	while(q--){
		int num;
		cin>>num;
		int l=0,r=n-1;
		while(l<r){
			int mid=l+r>>1;// mid 一定要写在while循环里面才能保证不断更新
			if(a[mid]>=num)r=mid;
			else l=mid+1;
		}
		if(a[l]!=num){
			cout<<"-1 -1"<<endl;
		}else{
			cout<<l<<' ';
			l=0;
			int r=n-1;
			while(l<r){
				int mid=l+r+1>>1;
				if(a[mid]<=num)l=mid;
				else r=mid-1;
			}
			cout<<l<<' '<<endl;
		}
	}
	return 0;
} 
```

# 浮点数二分

```c++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求，一般情况下
    						//实际精度要比要求精度小两个数量级
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## AcWing 790. 数的三次方根

给定一个浮点数 n，求它的三次方根。

#### 输入格式

共一行，包含一个浮点数 n。

#### 输出格式

共一行，包含一个浮点数，表示问题的解。

注意，结果保留 6 位小数。

#### 数据范围

−10000≤n≤10000

#### 输入样例：

```
1000.00
```

#### 输出样例：

```
10.000000
```

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
	double n;
	cin>>n;
	double l=-10000,r=10000;
	while(r-l>1e-8){//实际精度要比要求精度小两个数量级 
		double mid=(l+r)/2;
		if(mid*mid*mid>=n)r=mid;
		else l=mid;
	}
	printf("%lf",l);
	return 0;
} 
```

# 高精度加法

代码模板不唯一，要明白模板是如何运用的。明确哪些地方可以改，哪些地方不可以改。

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

## AcWing 791.高精度加法

```c++
// C = A + B, A >= 0, B >= 0
vector<int> add(vector<int> &A, vector<int> &B)
{
    if (A.size() < B.size()) return add(B, A);

    vector<int> C;
    int t = 0;
    for (int i = 0; i < A.size(); i ++ )
    {
        t += A[i];
        if (i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }

    if (t) C.push_back(t);
    return C;
}
```

给定两个正整数（不含前导 0），计算它们的和。

#### 输入格式

共两行，每行包含一个整数。

#### 输出格式

共一行，包含所求的和。

#### 数据范围

1≤整数长度≤100000

#### 输入样例：

```
12
23
```

#### 输出样例：

```
35
```

```c++
#include<bits/stdc++.h>
using namespace std;
vector<int> add(vector<int> &A,vector<int> &B){
	vector<int> C;
	if(A.size()<B.size()) return add(B,A);
	int t=0;
	for(int i=0;i<A.size();i++){
		t+=A[i];
		if(i<B.size())t+=B[i];
		C.push_back(t%10);
		t/=10;
	}
	if(t)C.push_back(t);//处理最高位有进位的情况
	return C;
}
int main(){
	vector<int> A;
	vector<int> B;
	string a,b;
	cin>>a>>b;
	for(int i=a.size()-1;i>=0;i--)A.push_back(a[i]-'0');
	for(int i=b.size()-1;i>=0;i--)B.push_back(b[i]-'0');
	vector<int> C = add(A,B);
	for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
	return 0;
} 
```

# 高精度减法

```c++
// C = A - B, 满足A >= B, A >= 0, B >= 0
vector<int> sub(vector<int> &A, vector<int> &B)
{
    vector<int> C;
    for (int i = 0, t = 0; i < A.size(); i ++ )
    {
        t = A[i] - t;
        if (i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10);
        if (t < 0) t = 1;
        else t = 0;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## AcWing792.高精度减法

https://www.acwing.com/problem/content/794/

给定两个正整数（不含前导 0），计算它们的差，计算结果可能为负数。

#### 输入格式

共两行，每行包含一个整数。

#### 输出格式

共一行，包含所求的差。

#### 数据范围

1≤整数长度≤105

#### 输入样例：

```
32
11
```

#### 输出样例：

```
21
```

```c++
#include<bits/stdc++.h>
using namespace std;
bool cmp(vector<int> &A,vector<int> &B){
	if(A.size()!=B.size())return A.size()>B.size();
	for(int i=A.size()-1;i>=0;i--)if(A[i]!=B[i])return A[i]>B[i];//从高位开始比较被减数
	return true;
}
vector<int> sub(vector<int> &A,vector<int> &B){//A是被减数 B是减数
	vector<int>C;
	for(int i=0,t=0;i<A.size();i++){
		t=A[i]-t;
		if(i<B.size()) t-=B[i];
		C.push_back((t+10)%10);//妙
		if(t<0)t=1;
		else t=0;
	}
	while(C.size()>1&&C.back()==0)C.pop_back();
	return C;
}
int main(){
	string a,b;
	cin>>a>>b;
	vector<int>A,B,C;
	for(int i=a.size()-1;i>=0;--i)A.push_back(a[i]-'0');
	for(int i=b.size()-1;i>=0;--i)B.push_back(b[i]-'0');
	if(cmp(A,B))C = sub(A,B);
	else{
		cout<<"-";//减法单独校验符号
		C = sub(B,A);
	}
	for(int i=C.size()-1;i>=0;i--)printf("%d",C[i]);
	return 0;
} 
```

# 高精度乘法

```c++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

## AcWing793.高精度乘法

https://www.acwing.com/problem/content/795/

给定两个非负整数（不含前导 0） A 和 B，请你计算 A×B 的值。

#### 输入格式

共两行，第一行包含整数 A，第二行包含整数 B。

#### 输出格式

共一行，包含 A×B 的值。

#### 数据范围

1≤A的长度≤100000
0≤B≤10000

#### 输入样例：

```
2
3
```

#### 输出样例：

```
6
```

```c++
#include <iostream>
#include <vector>

using namespace std;

vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}

int main()
{
    string a;
    int b;

    cin >> a >> b;

    vector<int> A;
    for (int i = a.size() - 1; i >= 0; i -- ) A.push_back(a[i] - '0');

    auto C = mul(A, b);

    for (int i = C.size() - 1; i >= 0; i -- ) printf("%d", C[i]);

    return 0;
}
```

# 高精度除法

```c++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

## AcWing794.高精度除法

给定两个非负整数（不含前导 0） A，B请你计算 A/B 的商和余数。

#### 输入格式

共两行，第一行包含整数 A，第二行包含整数 B。

#### 输出格式

共两行，第一行输出所求的商，第二行输出所求余数。

#### 数据范围

1≤A的长度≤100000
1≤B≤10000
B 一定不为 0

#### 输入样例：

```
7
2
```

#### 输出样例：

```
3
1
```

```c++
#include<bits/stdc++.h>
using namespace std;
vector<int> div(vector<int> &A,int b,int &r){
	vector<int> C;
	r=0;//高位进行除运算后剩下的余数
	for(int i=A.size()-1;i>=0;--i){
		r=r*10+A[i];
		C.push_back(r/b);
		r=r%b;
	}
	reverse(C.begin(),C.end());
	while(C.size()>1&&C.back()==0)C.pop_back();
	return C;
}
int main(){
	string a;
	int b;
	cin>>a>>b;
	vector<int>A;
	for(int i=a.size()-1;i>=0;--i)A.push_back(a[i]-'0');
	int r=0;
	vector<int>C =div(A,b,r);
	for(int i=C.size()-1;i>=0;--i)printf("%d",C[i]);
	cout<<endl<<r;
	return 0;
}
```

# 前缀和

![image-20221215195656445](%E5%BA%93/image-20221215195656445.png)

```
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

## AcWing795.前缀和

https://www.acwing.com/problem/content/797/

输入一个长度为 n 的整数序列。

接下来再输入 m 个询问，每个询问输入一对 l,r。

对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。

#### 输入格式

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。

#### 输出格式

共 m 行，每行输出一个询问的结果。

#### 数据范围

1≤l≤r≤n
1≤n,m≤100000
−1000≤数列中元素的值≤1000

#### 输入样例：

```
5 3
2 1 3 6 4
1 2
1 3
2 4
```

#### 输出样例：

```
3
6
10
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010;
int n,m;
int a[N],s[N];
int main(){
	s[0]=0;
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i)scanf("%d",&a[i]);//注意起始坐标是1不是0
	for(int i=1;i<=n;++i)s[i]=s[i-1]+a[i];//注意起始坐标是1不是0
	while(m--){
		int l,r;
		scanf("%d%d",&l,&r);
		printf("%d\n",s[r]-s[l-1]);//注意下标是 l-1
	} 
	return 0;
}
```

# 二维前缀和

![image-20221111202842237](C:\Users\QF laptop\AppData\Roaming\Typora\typora-user-images\image-20221111202842237.png)

```
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

## AcWing796.子矩阵的和

https://www.acwing.com/problem/content/798/

输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2表示一个子矩阵的左上角坐标和右下角坐标。

对于每个询问输出子矩阵中所有数的和。

#### 输入格式

第一行包含三个整数 n，m，q

接下来 n 行，每行包含 m 个整数，表示整数矩阵。

接下来 q 行，每行包含四个整数 x1,y1,x2,y2表示一组询问。

#### 输出格式

共 q 行，每行输出一个询问的结果。

#### 数据范围

1≤n,m≤1000
1≤q≤200000
1≤x1≤x2≤n
1≤y1≤y2≤m
−1000≤矩阵内元素的值≤1000

#### 输入样例：

```
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```

#### 输出样例：

```
17
27
21
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int a[N][N],s[N][N];
int n,m,q;
int main(){
	scanf("%d%d%d",&n,&m,&q);
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			scanf("%d",&a[i][j]);
	//建立二维前缀和数组 
	for(int i=1;i<=n;++i)
		for(int j=1;j<=m;++j)
			s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];
	//查询二维前缀和 
	while(q--){
		int x1,x2,y1,y2;
		cin>>x1>>y1>>x2>>y2;
		printf("%d\n",s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]);
	}
	return 0;
	//注意：建立二维前缀和数组的算法和查询二维前缀和数组的算法是不一样的 
}
```

# 差分

## AcWing797.差分

```
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

https://www.acwing.com/problem/content/799/

输入一个长度为 n 的整数序列。

接下来输入 m 个操作，每个操作包含三个整数 l,r,c表示将序列中 l,r 之间的每个数加上 c。

请你输出进行完所有操作后的序列。

#### 输入格式

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数序列。

接下来 m 行，每行包含三个整数 l，r，c表示一个操作。

#### 输出格式

共一行，包含 n 个整数，表示最终序列。

#### 数据范围

1≤n,m≤100000
1≤l≤r≤n
−1000≤c≤1000
−1000≤整数序列中元素的值≤1000

#### 输入样例：

```
6 3
1 2 2 1 2 1
1 3 1
3 5 1
1 6 1
```

#### 输出样例：

```
3 4 5 3 4 2
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N =100010;
int m,n;
int a[N],b[N];
void insert(int l,int r,int c){
	b[l]+=c;
	b[r+1]-=c;
}
int main(){
	scanf("%d%d",&n,&m);
	for(int i=1;i<=n;++i) scanf("%d",&a[i]);
	for(int i=1;i<=n;++i) insert(i,i,a[i]);
	while(m--){
		int l,r,c;
		scanf("%d%d%d",&l,&r,&c);
		insert(l,r,c);
	}
	for(int i=1;i<=n;i++) b[i]+=b[i-1];//差分的结果并没有写到a数组里面 
	for(int i=1;i<=n;i++) printf("%d ",b[i]); 
	return 0;
} 
```

## AcWing798.差分矩阵

```
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

https://www.acwing.com/problem/content/800/

输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。

每个操作都要将选中的子矩阵中的每个元素的值加上 c。

请你将进行完所有操作后的矩阵输出。

#### 输入格式

第一行包含整数 n,m,q

接下来 n 行，每行包含 m 个整数，表示整数矩阵。

接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c 表示一个操作。

#### 输出格式

共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。

#### 数据范围

1≤n,m≤1000
1≤q≤100000
1≤x1≤x2≤n
1≤y1≤y2≤m
−1000≤c≤1000
−1000≤矩阵内元素的值≤1000

#### 输入样例：

```
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```

#### 输出样例：

```
2 3 4 1
4 3 4 1
2 2 2 2
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int a[N][N], b[N][N];
void insert(int i, int j, int x, int y, int c)
{
    b[i][j] += c;
    b[i][y + 1] -= c;
    b[x + 1][j] -= c;;
    b[x + 1][y + 1] += c;
}
//可以默认二维数组a都是0,那么二维数组b也都是0
//每次都是向二维数组b中插入元素 
int main()
{
    int n, m, q, x, y, xx, yy, c;
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &a[i][j]);
            
    // 初始化差分矩阵
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            insert(i, j, i, j, a[i][j]);
	// 处理每个操作        
    for (int i = 0; i < q; i ++ )
    {
        scanf("%d%d%d%d%d", &x, &y, &xx, &yy, &c);
        insert(x, y, xx, yy, c); 
    }
    //更新二维数组b的状态
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            b[i][j] =b[i][j] + b[i][j - 1] + b[i - 1][j] - b[i - 1][j - 1]; 
        
    for (int i = 1; i <= n; i ++ )
    {
        for (int j = 1; j <= m; j ++ ) printf("%d ", b[i][j]);
        printf("\n");
    }
    return 0;
}
```

# 双指针算法

```
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

![image-20221215195220237](%E5%BA%93/image-20221215195220237.png)

![image-20221215195233994](%E5%BA%93/image-20221215195233994.png)

## AcWing799.最长连续不重复子序列

https://www.acwing.com/problem/content/801/

给定一个长度为 nn 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数（均在 0∼1050∼105 范围内），表示整数序列。

#### 输出格式

共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。

#### 数据范围

1≤n≤105

#### 输入样例：

```
5
1 2 2 3 5
```

#### 输出样例：

```
3
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N =100010;
int a[N];
int b[N];// 是1说明序列中已经存在这个数 

int main(){
	int n;
	cin>>n;
	for(int i=0;i<n;++i)scanf("%d",&a[i]);
	int res=0;
	for(int i=0,j=0;j<n;++j){
		if(!b[a[j]]){
			b[a[j]]=1;
			res=res>j-i+1?res:j-i+1;
		}else{
			while(a[i]!=a[j]){
				b[a[i]]=0;
				i++;
			}
			++i;
		}
	}
	cout<<res;
	return 0;
} 
```

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N =100010;
int a[N];
int s[N];// 是1说明序列中已经存在这个数 

int main(){
	int n;
	cin>>n;
	for (int i = 0; i < n; i ++ ) cin >> a[i];
	int res=0;
	for(int i=0,j=0;i<n;++i){
		s[a[i]]++;
		while(s[a[i]]>1){
			s[a[j]]--;
			j++;
		}
		res=max(res,i-j+1);
	}
	cout<<res;
	return 0;
} 
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
bool st[N];
int a[N];
int n;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    int res = 0;
    for (int i = 0, j = 0; i < n; i++) {
        if (st[a[i]]) {
            do {
                st[a[j]] = false;
                ++j;
            } while (st[a[i]]);
            st[a[i]] = true;
        } else {
            st[a[i]] = true;
            res = max(res, i - j + 1);
        }
    }
    cout << res;
    return 0;
}
```



## AcWing800.数组元素的目标和

https://www.acwing.com/activity/content/problem/content/834/

给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。

数组下标从 0 开始。

请你求出满足 A[i]+B[j]=x 的数对 (i,j)。

数据保证有唯一解。

#### 输入格式

第一行包含三个整数 n,m,x 分别表示 A 的长度，B 的长度以及目标值 x。

第二行包含 n 个整数，表示数组 A。

第三行包含 m 个整数，表示数组 B。

#### 输出格式

共一行，包含两个整数 i 和 j。

#### 数据范围

数组长度不超过 105。
同一数组内元素各不相同。
1≤数组元素≤109

#### 输入样例：

```
4 5 6
1 2 4 7
3 4 6 8 9
```

#### 输出样例：

```
1 1
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
int A[N];
int B[N];
int n, m, x;

int main() {
    cin >> n >> m >> x;

    for (int i = 0; i < n; i++) scanf("%d", &A[i]);
    for (int i = 0; i < m; i++) scanf("%d", &B[i]);

    int i = 0, j = m - 1;
    while (A[i] + B[j] != x) {
        if (A[i] + B[j] > x) --j;
        else ++i;
    }
    cout << i << " " << j << endl;
    return 0;
}
```

思维拓展：双指针不一定都要从头开始，可以一个指针从头开始枚举，另外一个指针从尾开始枚举

## AcWing2816.判断子序列

https://www.acwing.com/problem/content/2818/

给定一个长度为 n 的整数序列 a1,a2,…,an 以及一个长度为 m 的整数序列 b1,b2,…,bm。

请你判断 a 序列是否为 b 序列的子序列。

子序列指序列的一部分项按**原有次序排列**而得的序列，例如序列 {a1,a3,a5} 是序列 {a1,a2,a3,a4,a5} 的一个子序列。

#### 输入格式

第一行包含两个整数 n,m。

第二行包含 n 个整数，表示 a1,a2,…,an

第三行包含 m 个整数，表示 b1,b2,…,bm。

#### 输出格式

如果 a 序列是 b 序列的子序列，输出一行 `Yes`。

否则，输出 `No`。

#### 数据范围

1≤n≤m≤105
−109≤ai,bi≤109

#### 输入样例：

```
3 5
1 3 5
1 2 3 4 5
```

#### 输出样例：

```
Yes
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
int A[N];
int B[N];
int n, m;

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i)scanf("%d", &A[i]);
    for (int i = 0; i < m; ++i)scanf("%d", &B[i]);
    int i = 0, j = 0;//  A i   B j
    while (j < m) {
        if (i < n && B[j] == A[i]) ++i, ++j;
        else j++;
    }
    if (i == n)cout << "Yes";
    else cout << "No";
    return 0;
}
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 100010;
int A[N];
int B[N];
int n, m;

int main() {
    cin >> n >> m;

    for (int i = 0; i < n; i++) scanf("%d", &A[i]);
    for (int i = 0; i < m; i++) scanf("%d", &B[i]);

    for (int i = 0, j = 0; i < m; i++) {
        if (B[i] == A[j]) {
            j++;
            if (j == n) {
                puts("Yes");
                return 0;
            }
        }
    }
    puts("No");
    return 0;
}
```



# 位运算

![image-20221215222448092](%E5%BA%93/image-20221215222448092.png)

## AcWing801.二进制数中1的个数

https://www.acwing.com/problem/content/803/

给定一个长度为 n 的数列，请你求出数列中每个数的二进制表示中 1 的个数。

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数，表示整个数列。

#### 输出格式

共一行，包含 n 个整数，其中的第 i 个数表示数列中的第 i 个数的二进制表示中 1 的个数。

#### 数据范围

1≤n≤100000
0≤数列中元素的值≤109

#### 输入样例：

```
5
1 2 3 4 5
```

#### 输出样例：

```
1 1 2 1 2
```

```c++
#include<bits/stdc++.h>
using namespace std;
int lowbit(int x){
	return x & -x;
}
int main(){
	int n;
	cin>>n;
	while(n--){
		int x,res=0;
		cin>>x;
		while(x){
			res++;
			x-=lowbit(x);
		}
		cout<<res<<" ";
	} 
	return 0;
}
```

# 离散化

```c++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

![image-20221215222510466](%E5%BA%93/image-20221215222510466.png)

## AcWing802.区间和

https://www.acwing.com/problem/content/804/

假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。

现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。

接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r][l,r] 之间的所有数的和。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含两个整数 x 和 c。

再接下来 m 行，每行包含两个整数 l 和 r。

#### 输出格式

共 m 行，每行输出一个询问中所求的区间内数字和。

#### 数据范围

−109≤x≤109
1≤n,m≤105
−109≤l≤r≤109
−10000≤c≤10000

#### 输入样例：

```
3 3
1 2
3 6
7 5
1 3
4 6
7 8
```

#### 输出样例：

```
8
0
5
```

```c++
#include<bits/stdc++.h> 
using namespace std;
typedef pair<int, int> PII;
const int N = 300010;
int n, m;
int a[N], s[N];
vector<int> alls;// vector是动态数组，也可以按照数组的方式理解 
vector<PII> add, query;
int find(int x)// 离散化之后的值就是在vector中的下标加上1 
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1;
}
int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
    {
        int x, c;
        cin >> x >> c;
        add.push_back({x, c});
        alls.push_back(x);
    }
    for (int i = 0; i < m; i ++ )
    {
        int l, r;
        cin >> l >> r;
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    // 去重
    sort(alls.begin(), alls.end());
    alls.erase(unique(alls.begin(), alls.end()), alls.end());
    
    // 处理插入
    for (auto item : add)//这种遍历方式要求 C11 标准  要在编译选项中加入声明 
    {
        int x = find(item.first);//  x ≥1 
        a[x] += item.second;
    }
    
    // 预处理前缀和
    for(int i = 1; i <= alls.size(); i ++ ) s[i] = s[i - 1] + a[i];
    
    // 处理询问
    for (auto item : query)
    {
        int l = find(item.first), r = find(item.second);
        cout << s[r] - s[l - 1] << endl;
    }
    return 0;
}
```

# 区间合并

```c++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

## AcWing

https://www.acwing.com/problem/content/805/

给定 n 个区间 [li,ri][li,ri]，要求合并所有有交集的区间。

注意如果在端点处相交，也算有交集。

输出合并完成后的区间个数。

例如：[1,3][1,3] 和 [2,6][2,6] 可以合并为一个区间 [1,6][1,6]。

#### 输入格式

第一行包含整数 n。

接下来 n 行，每行包含两个整数 l 和 r。

#### 输出格式

共一行，包含一个整数，表示合并区间完成后的区间个数。

#### 数据范围

1≤n≤100000
−109≤li≤ri≤109

#### 输入样例：

```
5
1 2
2 4
5 6
7 8
7 9
```

#### 输出样例：

```
3
```

```c++
#include<bits/stdc++.h>
using namespace std;
void merge(vector<pair<int,int>> &segs){
	vector<pair<int,int>> res;
	sort(segs.begin(),segs.end());
	int st=-2e9,ed=-2e9;
	for(auto seg : segs){
		if(ed<seg.first){
			if(st!=-2e9)res.push_back({st,ed});
			st=seg.first,ed=seg.second;
		}else{
			ed=max(ed,seg.second);
		}
	}
	//某种情况下最后一段被维护的最后一段区间不会在循环体内被压入vector 
	if(st!=-2e9)res.push_back({st,ed});
	segs=res;
}
int main(){
	int n;
	cin>>n;
	vector<pair<int,int>>segs;
	for(int i=0;i<n;++i){
		int l,r;
		scanf("%d%d",&l,&r);
		segs.push_back({l,r});
	}
	merge(segs);
	cout<<segs.size();
	return 0;
} 
```

