# 如何准备蓝桥杯考试

1. 完成全部知识点

    10个比较重要的知识点，来自于历年蓝桥杯真题

2. 例题的思路全部要弄明白，课后习题也要写

3. 授课时间 50 小时左右



- 由题目描述抽象出模型



![image-20221227231757122](%E5%BA%93/image-20221227231757122.png)



# 递归与递推

理解递归可以画出来它的递归搜索树

![image-20221225215124221](%E5%BA%93/image-20221225215124221.png)

![image-20221225215931828](image/image-20221225215931828.png)



## AcWing 92. 递归实现指数型枚举

https://www.acwing.com/problem/content/94/

从 1∼n 这 n 个整数中随机选取任意多个，输出所有可能的选择方案。

#### 输入格式

输入一个整数 n。

#### 输出格式

每行输出一种方案。

同一行内的数必须升序排列，相邻两个数用恰好 1 个空格隔开。

对于没有选任何数的方案，输出空行。

本题有自定义校验器（SPJ），各行（不同方案）之间的顺序任意。

#### 数据范围

1≤n≤15

#### 输入样例：

```
3
```

#### 输出样例：

```
3
2
2 3
1
1 3
1 2
1 2 3
```

![image-20221225220939661](%E5%BA%93/image-20221225220939661.png)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 16;

int n;
int st[N];  // 状态，记录每个位置当前的状态：0表示还没考虑，1表示选它，2表示不选它

void dfs(int u)
{
    if (u > n)
    {
        for (int i = 1; i <= n; i ++ )
            if (st[i] == 1)
                printf("%d ", i);
        printf("\n");
        return;
    }

    st[u] = 2;
    dfs(u + 1);     // 第一个分支：不选
    st[u] = 0;  // 恢复现场

    st[u] = 1;
    dfs(u + 1);     // 第二个分支：选
    st[u] = 0;
}

int main()
{
    cin >> n;

    dfs(1);

    return 0;
}
```



## AcWing 94. 递归实现排列型枚举

https://www.acwing.com/problem/content/96/

把 1∼n 这 n 个整数排成一行后随机打乱顺序，输出所有可能的次序。

#### 输入格式

一个整数 n。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。

#### 数据范围

1≤n≤9

#### 输入样例：

```
3
```

#### 输出样例：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

- 依次枚举每个数放到哪个位置
- 依次枚举每个位置放哪个数字

![image-20221225224134132](%E5%BA%93/image-20221225224134132.png)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
int state[N];   // 0 表示还没放数，1~n表示放了哪个数
bool used[N];   // true表示用过，false表示还未用过

void dfs(int u)
{
    if (u > n)  // 边界
    {
        for (int i = 1; i <= n; i ++ ) printf("%d ", state[i]); // 打印方案
        puts("");

        return;
    }

    // 依次枚举每个分支，即当前位置可以填哪些数
    for (int i = 1; i <= n; i ++ )
        if (!used[i])
        {
            state[u] = i;
            used[i] = true;
            dfs(u + 1);

            // 恢复现场
            state[u] = 0;
            used[i] = false;
        }
}

int main()
{
    scanf("%d", &n);

    dfs(1);

    return 0;
}
```



## AcWing 93. 递归实现组合型枚举

https://www.acwing.com/problem/content/95/

从 1∼n 这 n 个整数中随机选出 m 个，输出所有可能的选择方案。

#### 输入格式

两个整数 n,m ,在同一行用空格隔开。

#### 输出格式

按照从小到大的顺序输出所有方案，每行 1 个。

首先，同一行内的数升序排列，相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面（例如 `1 3 5 7` 排在 `1 3 6 8` 前面）。

#### 数据范围

n>0
0≤m≤n
n+(n−m)≤25

#### 输入样例：

```
5 3
```

#### 输出样例：

```
1 2 3 
1 2 4 
1 2 5 
1 3 4 
1 3 5 
1 4 5 
2 3 4 
2 3 5 
2 4 5 
3 4 5 
```

**思考题**：如果要求使用非递归方法，该怎么做呢？

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 30;

int n, m;
int way[N];

void dfs(int u, int start)
{
    if (u + n - start < m) return;  // 剪枝
    if (u == m + 1)
    {
        for (int i = 1; i <= m; i ++ ) printf("%d ", way[i]);
        puts("");
        return;
    }

    for (int i = start; i <= n; i ++ )
    {
        way[u] = i;
        dfs(u + 1, i + 1);
        way[u] = 0; // 恢复现场
    }
}

int main()
{
    scanf("%d%d", &n, &m);

    dfs(1, 1);

    return 0;
}
```



## AcWing 1209. 带分数

https://www.acwing.com/problem/content/1211/

![image-20221225230429258](%E5%BA%93/image-20221225230429258.png)

#### 输入格式

一个正整数。

#### 输出格式

输出输入数字用数码 1∼9 不重复不遗漏地组成带分数表示的全部种数。

#### 数据范围

1≤N<10^6^

#### 输入样例1：

```
100
```

#### 输出样例1：

```
11
```

#### 输入样例2：

```
105
```

#### 输出样例2：

```
6
```



> https://www.acwing.com/solution/content/38879/
>
> AcWing 1209. 带分数（y总字幕版本，思路贼清晰）

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10;

int n;
bool st[N], backup[N];
int ans;

bool check(int a, int c)
{
    long long b = n * (long long)c - a * c;

    if (!a || !b || !c) return false;

    memcpy(backup, st, sizeof st);
    while (b)
    {
        int x = b % 10;     // 取个位
        b /= 10;    // 个位删掉
        if (!x || backup[x]) return false;
        backup[x] = true;
    }

    for (int i = 1; i <= 9; i ++ )
        if (!backup[i])
            return false;

    return true;
}

void dfs_c(int u, int a, int c)
{
    if (u > 9) return;

    if (check(a, c)) ans ++ ;

    for (int i = 1; i <= 9; i ++ )
        if (!st[i])
        {
            st[i] = true;
            dfs_c(u + 1, a, c * 10 + i);
            st[i] = false;
        }
}

void dfs_a(int u, int a)
{
    if (a >= n) return;
    if (a) dfs_c(u, a, 0);

    for (int i = 1; i <= 9; i ++ )
        if (!st[i])
        {
            st[i] = true;
            dfs_a(u + 1, a * 10 + i);
            st[i] = false;
        }
}

int main()
{
    cin >> n;

    dfs_a(0, 0);

    cout << ans << endl;

    return 0;
}
```



## AcWing 717. 简单斐波那契

https://www.acwing.com/problem/content/719/

以下数列 `0 1 1 2 3 5 8 13 21 ...` 被称为斐波纳契数列。

这个数列从第 3 项开始，每一项都等于前两项之和。

输入一个整数 N，请你输出这个序列的前 N 项。

#### 输入格式

一个整数 N。

#### 输出格式

在一行中输出斐波那契数列的前 N 项，数字之间用空格隔开。

#### 数据范围

0<N<46

#### 输入样例：

```
5
```

#### 输出样例：

```
0 1 1 2 3
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int a = 0, b = 1;
    int n;
    cin >> n;

    for (int i = 0; i < n; i ++ )
    {
        cout << a << ' ';
        int c = a + b;
        a = b, b = c;
    }

    cout << endl;

    return 0;
}
```



## AcWing 95. 费解的开关

https://www.acwing.com/problem/content/97/

你玩过“拉灯”游戏吗？

25 盏灯排成一个 5×5 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。

以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 66 步以内无法使所有灯变亮，则输出 −1。

#### 数据范围

0<n≤500

#### 输入样例：

```
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
```

输出样例：

```
3
2
-1
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 6;

char g[N][N], backup[N][N];
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};

void turn(int x, int y)
{
    for (int i = 0; i < 5; i ++ )
    {
        int a = x + dx[i], b = y + dy[i];
        if (a < 0 || a >= 5 || b < 0 || b >= 5) continue;   // 在边界外，直接忽略即可
        g[a][b] ^= 1;
    }
}

int main()
{
    int T;
    cin >> T;
    while (T -- )
    {
        for (int i = 0; i < 5; i ++ ) cin >> g[i];

        int res = 10;
        for (int op = 0; op < 32; op ++ )//枚举第一行的所有操作
        {
            memcpy(backup, g, sizeof g);
            int step = 0;
            for (int i = 0; i < 5; i ++ )
                if (op >> i & 1)
                {
                    step ++ ;
                    turn(0, i);
                }

            for (int i = 0; i < 4; i ++ )
                for (int j = 0; j < 5; j ++ )
                    if (g[i][j] == '0')
                    {
                        step ++ ;
                        turn(i + 1, j);
                    }

            bool dark = false;
            for (int i = 0; i < 5; i ++ )
                if (g[4][i] == '0')
                {
                    dark = true;
                    break;
                }

            if (!dark) res = min(res, step);
            memcpy(g, backup, sizeof g);
        }

        if (res > 6) res = -1;

        cout << res << endl;
    }

    return 0;
}
```



## AcWing 116. 飞行员兄弟

https://www.acwing.com/problem/content/118/

“飞行员兄弟”这个游戏，需要玩家顺利的打开一个拥有 16 个把手的冰箱。

已知每个把手可以处于以下两种状态之一：打开或关闭。

只有当所有把手都打开时，冰箱才会打开。

把手可以表示为一个 4×4 的矩阵，您可以改变任何一个位置 [i,j][i,j] 上把手的状态。

但是，这也会使得第 i 行和第 j 列上的所有把手的状态也随着改变。

请你求出打开冰箱所需的切换把手的次数最小值是多少。

#### 输入格式

输入一共包含四行，每行包含四个把手的初始状态。

符号 `+` 表示把手处于闭合状态，而符号 `-` 表示把手处于打开状态。

至少一个手柄的初始状态是关闭的。

#### 输出格式

第一行输出一个整数 N，表示所需的最小切换把手次数。

接下来 N 行描述切换顺序，每行输出两个整数，代表被切换状态的把手的行号和列号，数字之间用空格隔开。

**注意**：如果存在多种打开冰箱的方式，则按照优先级整体从上到下，同行从左到右打开。

#### 数据范围

1≤i,j≤4

#### 输入样例：

```
-+--
----
----
-+--
```

#### 输出样例：

```
6
1 1
1 3
1 4
4 1
4 3
4 4
```

**数组写法**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 5;

char g[N][N], backup[N][N];

int get(int x, int y)
{
    return x * 4 + y;
}

void turn_one(int x, int y)
{
    if (g[x][y] == '+') g[x][y] = '-';
    else g[x][y] = '+';
}

void turn_all(int x, int y)
{
    for (int i = 0; i < 4; i ++ )
    {
        turn_one(x, i);
        turn_one(i, y);
    }

    turn_one(x, y);
}

int main()
{
    for (int i = 0; i < 4; i ++ ) cin >> g[i];

    vector<PII> res;
    for (int op = 0; op < 1 << 16; op ++ )
    {
        vector<PII> temp;
        memcpy(backup, g, sizeof g);        // 备份

        // 进行操作
        for (int i = 0; i < 4; i ++ )
            for (int j = 0; j < 4; j ++ )
                if (op >> get(i, j) & 1)
                {
                    temp.push_back({i, j});
                    turn_all(i, j);
                }

        // 判断所有灯泡是否全亮
        bool has_closed = false;
        for (int i = 0; i < 4; i ++ )
            for (int j = 0; j < 4; j ++ )
                if (g[i][j] == '+')
                    has_closed = true;

        if (has_closed == false)
        {
            if (res.empty() || res.size() > temp.size()) res = temp;
        }

        memcpy(g, backup, sizeof g);        // 还原
    }

    cout << res.size() << endl;
    for (auto op : res) cout << op.x + 1 << ' ' << op.y + 1 << endl;

    return 0;
}
```

**二进制写法**

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 4;

int change[N][N];

int get(int x, int y) {
    return x * N + y;
}

int main() {

    for (int i = 0; i < N; i++)
        for (int j = 0; j < N; ++j) {
            for (int k = 0; k < 4; k++) {
                change[i][j] += 1 << get(i, k);
                change[i][j] += 1 << get(k, j);
            }
            change[i][j] -= 1 << get(i, j);
        }

    int state = 0;
    for (int i = 0; i < N; i++) {
        string line;
        cin >> line;
        for (int j = 0; j < N; j++)
            if (line[j] == '+') state += 1 << get(i, j);
    }

    vector<PII> path;
    for (int i = 0; i < 1 << 16; i++) {
        int now = state;
        vector<PII> temp;
        for (int j = 0; j < 16; j++) {
            if (i >> j & 1) {
                int x = j / 4, y = j % 4;
                now ^= change[x][y];
                temp.push_back({x, y});
            }
        }
        if (!now && (path.empty() || path.size() > temp.size())) path = temp;
    }

    cout << path.size() << endl;
    for (auto &p: path) {
        cout << p.first + 1 << " " << p.second + 1 << endl;
    }
    return 0;
}
```



## AcWing 1208. 翻硬币

https://www.acwing.com/problem/content/1210/

小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：`**oo***oooo`

如果同时翻转左边的两个硬币，则变为：`oooo***oooo`

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

#### 输入格式

两行等长的字符串，分别表示初始状态和要达到的目标状态。

#### 输出格式

一个整数，表示最小操作步数

#### 数据范围

输入字符串的长度均不超过100。
数据保证答案一定有解。

#### 输入样例1：

```
**********
o****o****
```

#### 输出样例1：

```
5
```

#### 输入样例2：

```
*o**o***o***
*o***o**o***
```

#### 输出样例2：

```
1
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 110;

int n;
char start[N], aim[N];

void turn(int i)
{
    if (start[i] == '*') start[i] = 'o';
    else start[i] = '*';
}

int main()
{
    cin >> start >> aim;
    n = strlen(start);

    int res = 0;
    for (int i = 0; i < n - 1; i ++ )
        if (start[i] != aim[i])
        {
            turn(i), turn(i + 1);
            res ++ ;
        }

    cout << res << endl;
    return 0;
}
```





# 整数二分

![image-20221228122926335](%E5%BA%93/image-20221228122926335.png)

## AcWing 789. 数的范围

https://www.acwing.com/problem/content/791/

给定一个按照升序排列的长度为 n 的整数数组，以及 q 个查询。

对于每个查询，返回一个元素 k 的起始位置和终止位置（位置从 0 开始计数）。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 输入格式

第一行包含整数 n 和 q，表示数组长度和询问个数。

第二行包含 n 个整数（均在 1∼10000 范围内），表示完整数组。

接下来 q 行，每行包含一个整数 k，表示一个询问元素。

#### 输出格式

共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。

如果数组中不存在该元素，则返回 `-1 -1`。

#### 数据范围

1≤n≤100000
1≤q≤10000
1≤k≤10000

#### 输入样例：

```
6 3
1 2 2 3 3 4
3
4
5
```

#### 输出样例：

```
3 4
5 5
-1 -1
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, q, k;
int a[N];

int main() {
    cin >> n >> q;

    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    while (q--) {
        scanf("%d", &k);
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = (l + r) >> 1;
            if (a[mid] >= k) r = mid;
            else l = mid + 1;
        }
        if (a[l] != k) {
            puts("-1 -1");
            continue;
        }
        cout << l << " ";
        l = 0, r = n - 1;
        while (l < r) {
            int mid = (r + l + 1) >> 1;
            if (a[mid] <= k) l = mid;
            else r = mid - 1;
        }
        cout << r << endl;
    }
    return 0;
}
```

- l == r 时退出循环，所以 l 和 r 是一样的
- 一个mid = (l+r)>>1
    一个mid = (l+r+1)>>1
    加不加1 完全取决于 l = mid 还是r = mid
    l等于mid时必须+1向上取整 不然会陷入l=l的死循环
    r = mid 时候不用加1 因为下一步l = r 直接会退出循环

y总代码

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int q[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    for (int i = 0; i < m; i ++ )
    {
        int x;
        scanf("%d", &x);
        // 二分x的左端点
        int l = 0, r = n - 1;   // 确定区间范围
        while (l < r)
        {
            int mid = l + r >> 1;
            if (q[mid] >= x) r = mid;
            else l = mid + 1;
        }

        if (q[r] == x)
        {
            cout << r << ' ';

            // 二分x的右端点
            r = n - 1;  // 右端点一定在[左端点, n - 1] 之间
            while (l < r)
            {
                int mid = l + r + 1 >> 1;   // 因为写的是l = mid，所以需要补上1
                if (q[mid] <= x) l = mid;
                else r = mid - 1;
            }
            cout << r << endl;
        }
        else cout << "-1 -1" << endl;
    }

    return 0;
}
```



## AcWing 790. 数的三次方根

https://www.acwing.com/problem/content/792/

给定一个浮点数 n，求它的三次方根。

#### 输入格式

共一行，包含一个浮点数 n。

#### 输出格式

共一行，包含一个浮点数，表示问题的解。

注意，结果保留 6 位小数。

#### 数据范围

−10000≤n≤10000

#### 输入样例：

```
1000.00
```

#### 输出样例：

```
10.000000
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    double x;
    cin >> x;
    double l = -10000, r = 10000;
    while (r - l > 1e-8)
    {
        double mid = (l + r) / 2;
        if (mid * mid * mid >= x) r = mid;
        else l = mid;
    }

    printf("%lf\n", l);

    return 0;
}
```



## AcWing 730. 机器人跳跃问题

https://www.acwing.com/problem/content/732/

机器人正在玩一个古老的基于 DOS 的游戏。

游戏中有 N+1 座建筑——从 0 到 N 编号，从左到右排列。

编号为 0 的建筑高度为 0 个单位，编号为 i 的建筑高度为 H(i) 个单位。

起初，机器人在编号为 0 的建筑处。

每一步，它跳到下一个（右边）建筑。

假设机器人在第 k 个建筑，且它现在的能量值是 E，下一步它将跳到第 k+1 个建筑。

如果 H(k+1)>E，那么机器人就失去 H(k+1)−E 的能量值，否则它将得到 E−H(k+1) 的能量值。

游戏目标是到达第 N 个建筑，在这个过程中能量值不能为负数个单位。

现在的问题是机器人至少以多少能量值开始游戏，才可以保证成功完成游戏？

#### 输入格式

第一行输入整数 N。

第二行是 N 个空格分隔的整数，H(1),H(2),…,H(N) 代表建筑物的高度。

#### 输出格式

输出一个整数，表示所需的最少单位的初始能量值上取整后的结果。

#### 数据范围

1≤N,H(i)≤105

#### 输入样例1：

```
5
3 4 3 2 4
```

#### 输出样例1：

```
4
```

#### 输入样例2：

```
3
4 4 4
```

#### 输出样例2：

```
4
```

#### 输入样例3：

```
3
1 6 4
```

#### 输出样例3：

```
3
```



```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
int n;
int a[N];

bool check(int e) {
    for (int i = 1; i <= n; i++) {
        e = e * 2 - a[i];
        if (e < 0) return false;
        if (e > 1e5) return true;
    }
    return true;
}

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

    int l = 0, r = 1e5;
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l;

    return 0;
}
```



## AcWing 1221. 四平方和

https://www.acwing.com/problem/content/1223/

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 4 个正整数的平方和。

如果把 0 包括进去，就正好可以表示为 4 个数的平方和。

比如：

![image-20221228184543435](%E5%BA%93/image-20221228184543435.png)

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 4 个数排序：

0≤a≤b≤c≤d

并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法。

#### 输入格式

输入一个正整数 N。

#### 输出格式

输出4个非负整数，按从小到大排序，中间用空格分开。

#### 数据范围

0<N<5∗10^6^

#### 输入样例：

```
5
```

#### 输出样例：

```
0 0 1 2
```

**暴力做法**  原题超时

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 2500010;

int n;

int main()
{
    cin >> n;
    for (int a = 0; a * a <= n; a ++ )
        for (int b = a; a * a + b * b <= n; b ++ )
            for (int c = b; a * a + b * b + c * c <= n; c ++ )
            {
                int t = n - a * a - b * b - c * c;
                int d = sqrt(t);
                if (d * d == t)
                {
                    printf("%d %d %d %d\n", a, b, c, d);
                    return 0;
                }
            }
}
```

**二分**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

const int N = 2500010;

struct Sum
{
    int s, c, d;
    bool operator< (const Sum &t)const
    {
        if (s != t.s) return s < t.s;
        if (c != t.c) return c < t.c;
        return d < t.d;
    }
}sum[N];

int n, m;

int main()
{
    cin >> n;

    for (int c = 0; c * c <= n; c ++ )
        for (int d = c; c * c + d * d <= n; d ++ )
            sum[m ++ ] = {c * c + d * d, c, d};

    sort(sum, sum + m);

    for (int a = 0; a * a <= n; a ++ )
        for (int b = 0; a * a + b * b <= n; b ++ )
        {
            int t = n - a * a - b * b;
            int l = 0, r = m - 1;
            while (l < r)
            {
                int mid = l + r >> 1;
                if (sum[mid].s >= t) r = mid;
                else l = mid + 1;
            }
            if (sum[l].s == t)
            {
                printf("%d %d %d %d\n", a, b, sum[l].c, sum[l].d);
                return 0;
            }
        }

    return 0;
}
```

**哈希表**  原题超时

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <unordered_map>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 2500010;

int n, m;
unordered_map<int, PII> S;

int main()
{
    cin >> n;

    for (int c = 0; c * c <= n; c ++ )
        for (int d = c; c * c + d * d <= n; d ++ )
        {
            int t = c * c + d * d;
            if (S.count(t) == 0) S[t] = {c, d};
        }

    for (int a = 0; a * a <= n; a ++ )
        for (int b = 0; a * a + b * b <= n; b ++ )
        {
            int t = n - a * a - b * b;
            if (S.count(t))
            {
                printf("%d %d %d %d\n", a, b, S[t].x, S[t].y);
                return 0;
            }
        }

    return 0;
}
```



## AcWing 1227. 分巧克力

https://www.acwing.com/problem/content/1229/

儿童节那天有 K 位小朋友到小明家做客。

小明拿出了珍藏的巧克力招待小朋友们。

小明一共有 N 块巧克力，其中第 i 块是 Hi×Wi 的方格组成的长方形。

为了公平起见，小明需要从这 N 块巧克力中切出 K 块巧克力分给小朋友们。

切出的巧克力需要满足：

1. 形状是正方形，边长是整数
2. 大小相同

例如一块 6×5 的巧克力可以切出 6 块 2×2 的巧克力或者 2 块 3×3 的巧克力。

当然小朋友们都希望得到的巧克力尽可能大，你能帮小明计算出最大的边长是多少么？

#### 输入格式

第一行包含两个整数 N 和 K。

以下 N 行每行包含两个整数 HiHi 和 Wi。

输入保证每位小朋友至少能获得一块 1×1 的巧克力。

#### 输出格式

输出切出的正方形巧克力最大可能的边长。

#### 数据范围

1≤N,K≤10^5^
1≤Hi,Wi≤10^5^

#### 输入样例：

```
2 10
6 5
5 6
```

#### 输出样例：

```
2
```

### 自己写得

结果超时，看一下数据范围就知道会超时了，以后写代码要注意关注测试数据的范围

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, k;
int q[N];

int main() {
    cin >> n >> k;
    int l = 0, r = 0;
    for (int i = 0; i < n; ++i) {
        int a, b;
        cin >> a >> b;
        r = max(r, max(a, b));
        for (int j = 1; j <= min(a, b); j++) {
            q[j] += (a / j) * (b / j);
        }
    }

    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (q[mid] >= k) l = mid;
        else r = mid - 1;
    }

    cout << l;
    return 0;
}
```

### y总代码

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, k;
int h[N], w[N];

bool check(int mid)
{
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        res += (h[i] / mid) * (w[i] / mid);
        if (res >= k) return true;
    }

    return false;
}

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &h[i], &w[i]);

    int l = 1, r = 1e5;
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }

    printf("%d\n", r);

    return 0;
}
```



# 前缀和

## AcWing 795. 前缀和

https://www.acwing.com/problem/content/797/

输入一个长度为 n 的整数序列。

接下来再输入 m 个询问，每个询问输入一对 l,r。

对于每个询问，输出原序列中从第 l 个数到第 r 个数的和。

#### 输入格式

第一行包含两个整数 n 和 m。

第二行包含 n 个整数，表示整数数列。

接下来 m 行，每行包含两个整数 l 和 r，表示一个询问的区间范围。

#### 输出格式

共 m 行，每行输出一个询问的结果。

#### 数据范围

1≤l≤r≤n
1≤n,m≤100000
−1000≤数列中元素的值≤1000

#### 输入样例：

```
5 3
2 1 3 6 4
1 2
1 3
2 4
```

#### 输出样例：

```
3
6
10
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n, m;
int a[N];   // 表示原数组
int s[N];   // 表示前缀和数组

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 1; i <= n; i ++ )
    {
        scanf("%d", &a[i]);
        s[i] = s[i - 1] + a[i];
    }

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]);
    }

    return 0;
}
```



## AcWing 796. 子矩阵的和

https://www.acwing.com/problem/content/798/

输入一个 n 行 m 列的整数矩阵，再输入 q 个询问，每个询问包含四个整数 x1,y1,x2,y2，表示一个子矩阵的左上角坐标和右下角坐标。

对于每个询问输出子矩阵中所有数的和。

#### 输入格式

第一行包含三个整数 n，m，q

接下来 n 行，每行包含 m 个整数，表示整数矩阵。

接下来 q 行，每行包含四个整数 x1,y1,x2,y2，表示一组询问。

#### 输出格式

共 q 行，每行输出一个询问的结果。

#### 数据范围

1≤n,m≤1000
1≤q≤200000
1≤x1≤x2≤n
1≤y1≤y2≤m
−1000≤矩阵内元素的值≤1000

#### 输入样例：

```
3 4 3
1 7 2 4
3 6 2 8
2 1 2 3
1 1 2 2
2 1 3 4
1 3 3 4
```

#### 输出样例：

```
17
27
21
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m, q;
int a[N][N], s[N][N];

int main()
{
    scanf("%d%d%d", &n, &m, &q);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            scanf("%d", &a[i][j]);
            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];
        }

    while (q -- )
    {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }

    return 0;
}
```



## AcWing 99. 激光炸弹

https://www.acwing.com/problem/content/101/

地图上有 N 个目标，用整数 Xi,Yi 表示目标在地图上的位置，每个目标都有一个价值 Wi。

**注意**：不同目标可能在同一位置。

现在有一种新型的激光炸弹，可以摧毁一个包含 R×R 个位置的正方形内的所有目标。

激光炸弹的投放是通过卫星定位的，但其有一个缺点，就是其爆炸范围，即那个正方形的边必须和 x，y 轴平行。

求一颗炸弹最多能炸掉地图上总价值为多少的目标。

#### 输入格式

第一行输入正整数 N 和 R，分别代表地图上的目标数目和正方形包含的横纵位置数量，数据用空格隔开。

接下来 N 行，每行输入一组数据，每组数据包括三个整数 Xi,Yi,Wi，分别代表目标的 x 坐标，y 坐标和价值，数据用空格隔开。

#### 输出格式

输出一个正整数，代表一颗炸弹最多能炸掉地图上目标的总价值数目。

#### 数据范围

0≤R≤10^9^
0<N≤10000
0≤Xi,Yi≤5000
0≤Wi≤1000

#### 输入样例：

```
2 1
0 0 1
1 1 1
```

#### 输出样例：

```
1
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 5010;

int n, m;
int s[N][N];

int main()
{
    int cnt, R;
    cin >> cnt >> R;
    R = min(5001, R);

    n = m = R;
    while (cnt -- )
    {
        int x, y, w;
        cin >> x >> y >> w;
        x ++, y ++ ;
        n = max(n, x), m = max(m, y);
        s[x][y] += w;
    }

    // 预处理前缀和
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];

    int res = 0;

    // 枚举所有边长是R的矩形，枚举(i, j)为右下角
    for (int i = R; i <= n; i ++ )
        for (int j = R; j <= m; j ++ )
            res = max(res, s[i][j] - s[i - R][j] - s[i][j - R] + s[i - R][j - R]);

    cout << res << endl;

    return 0;
}
```



## AcWing 1230. K倍区间

https://www.acwing.com/problem/content/1232/

给定一个长度为 N 的数列，A1,A2,…AN，如果其中一段连续的子序列 Ai,Ai+1,…Aj 之和是 K 的倍数，我们就称这个区间 [i,j][i,j] 是 K 倍区间。

你能求出数列中总共有多少个 K 倍区间吗？

#### 输入格式

第一行包含两个整数 N 和 K。

以下 N 行每行包含一个整数 Ai。

#### 输出格式

输出一个整数，代表 K 倍区间的数目。

#### 数据范围

1≤N,K≤100000
1≤Ai≤100000

#### 输入样例：

```
5 2
1
2
3
4
5
```

#### 输出样例：

```
6
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, k;
LL s[N], cnt[N];

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; i ++ )
    {
        scanf("%lld", &s[i]);
        s[i] += s[i - 1];
    }

    LL res = 0;
    cnt[0] = 1;//注意这里是为什么？
    for (int i = 1; i <= n; i ++ )
    {
        res += cnt[s[i] % k];
        cnt[s[i] % k] ++ ;
    }

    printf("%lld\n", res);

    return 0;
}
```

![image-20221229170023368](%E5%BA%93/image-20221229170023368.png)

这个思想真的是非常巧妙，值得深入学习理解

K 倍区间这道题目需要了解一个数论知识——同余定理，给定一个正整数 m，如果两个整数 a 和 b 满足 a-b 能够被 m 整除，即 (a-b)/m 得到一个整数(余数为0)，那么就称整数 a 与 b 对模 m 同余，记作 a≡b(mod m) 。对模 m 同余是整数的一个等价关系



# 简单数学知识

## AcWing 1205. 买不到的数目

https://www.acwing.com/problem/content/1207/

小明开了一家糖果店。

他别出心裁：把水果糖包成4颗一包和7颗一包的两种。

糖果不能拆包卖。

小朋友来买糖的时候，他就用这两种包装来组合。

当然有些糖果数目是无法组合出来的，比如要买 10 颗糖。

你可以用计算机测试一下，在这种包装情况下，最大不能买到的数量是17。

大于17的任何数字都可以用4和7组合出来。

本题的要求就是在已知两个包装的数量时，求最大不能组合出的数字。

#### 输入格式

两个正整数 n,m，表示每种包装中糖的颗数。

#### 输出格式

一个正整数，表示最大不能买到的糖数。

#### 数据范围

2≤n,m≤1000
保证数据一定有解。

#### 输入样例：

```
4 7
```

#### 输出样例：

```
17
```

当我们不能确定规律的时候，我们可以尝试暴搜打表的方式来尝试着通过观察找规律

**暴力搜索代码**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

bool dfs(int m, int p, int q) {
    if (!m) return true;

    if (m >= p && dfs(m - p, p, q)) return true;
    if (m >= q && dfs(m - q, p, q)) return true;
    return false;
}

int main() {
    int p, q;
    cin >> p >> q;

    int res = 0;
    for (int i = 1; i <= 1000; i++) {
        if (!dfs(i, p, q)) res = i;
    }
    cout << res;
    return 0;
}
```

发现规律之后直接输出即可

```c++
#include <iostream>
using namespace std;
int main()
{
    int p, q;
    cin >> p >> q;
    cout << (p - 1) * (q - 1) - 1 << endl;

    return 0;
}
```



## AcWing 1211. 蚂蚁感冒

https://www.acwing.com/problem/content/1213/

长 100 厘米的细长直杆子上有 n 只蚂蚁。

它们的头有的朝左，有的朝右。

每只蚂蚁都只能沿着杆子向前爬，速度是 1 厘米/秒。

当两只蚂蚁碰面时，它们会同时掉头往相反的方向爬行。

这些蚂蚁中，有 1 只蚂蚁感冒了。

并且在和其它蚂蚁碰面时，会把感冒传染给碰到的蚂蚁。

请你计算，当所有蚂蚁都爬离杆子时，有多少只蚂蚁患上了感冒。

#### 输入格式

第一行输入一个整数 n, 表示蚂蚁的总数。

接着的一行是 n 个用空格分开的整数 Xi,Xi 的绝对值表示蚂蚁离开杆子左边端点的距离。

正值表示头朝右，负值表示头朝左，数据中不会出现 0 值，也不会出现两只蚂蚁占用同一位置。

其中，第一个数据代表的蚂蚁感冒了。

#### 输出格式

输出1个整数，表示最后感冒蚂蚁的数目。

#### 数据范围

1<n<50
0<|Xi|<100

#### 输入样例1：

```
3
5 -2 8
```

#### 输出样例1：

```
1
```

#### 输入样例2：

```
5
-10 8 -20 12 25
```

#### 输出样例2：

```
3
```

有一个非常重要的性质是：碰撞后掉头等价于穿过

这个题目类似于脑筋急转弯，而不是严谨性的数学题

![image-20221231174359039](%E5%BA%93/image-20221231174359039.png)

**自己写的**

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 60;
int x[N];
int n;

int main() {
    cin >> n;

    for (int i = 0; i < n; i++) cin >> x[i];

    int left = 0, right = 0;// left表示左边向右走的蚂蚁数量，right表示右边向左走的蚂蚁数量
    for (int i = 1; i < n; i++) {
        if (abs(x[i] < abs(x[0]) && x[i] > 0)) left++;
        else if (abs(x[i]) > abs(x[0]) && x[i] < 0) right++;
    }

    int cnt = 1;
    if (x[0] > 0) {
        cnt += right;
        if (cnt > 1) cnt += left;
    } else {
        cnt += left;
        if (cnt > 1) cnt += right;
    }

    cout << cnt;
    return 0;
}
```

**y总代码**

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55;

int n;
int x[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> x[i];

    int left = 0, right = 0;// 分别表示左边向右走的蚂蚁数量，和右边向左走的蚂蚁数量
    for (int i = 1; i < n; i ++ )
        if (abs(x[i]) < abs(x[0]) && x[i] > 0) left ++ ;
        else if (abs(x[i]) > abs(x[0]) && x[i] < 0) right ++ ;

    if (x[0] > 0 && right == 0 || x[0] < 0 && left == 0) cout << 1 << endl;
    else cout << left + right + 1 << endl;

    return 0;
}
```



## AcWing 1216. 饮料换购

https://www.acwing.com/problem/content/1218/

乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。

请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的 n 瓶饮料，最后他一共能喝到多少瓶饮料。

#### 输入格式

输入一个整数 n,表示初始买入的饮料数量。

#### 输出格式

输出一个整数，表示一共能够喝到的饮料数量。

#### 数据范围

0<n<10000

#### 输入样例：

```
100
```

#### 输出样例：

```
149
```

**自己写的**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int n;

int main() {
    cin >> n;//n表示瓶盖的数量，cnt表示喝到饮料的数量
    int cnt = n;
    while (n >= 3) {
        cnt += n / 3;
        n = n / 3 + n % 3;
    }
    cout << cnt;
    return 0;
}
```



<img src="%E5%BA%93/image-20221231182306138.png" alt="image-20221231182306138" style="zoom:50%;" />

这个上取整为什么正确？可以通过分情况讨论来证明，不再详述

注意库函数 ceil（）返回的是 double 类型，注意是否需要强制类型转换



# 简单 DP

## AcWing 2. 01背包问题

https://www.acwing.com/problem/content/2/

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。

第 i 件物品的体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，N，V，用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi，用空格隔开，分别表示第 i 件物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

0<N,V≤1000
0<vi,wi≤1000

#### 输入样例

```
4 5
1 2
2 4
3 4
4 5
```

#### 输出样例：

```
8
```



1. 不选择第 i 个物体 ，f[i] [j]=f[i-1] [j]
2. 选择第 i 个物体，f[i] [j]=f[i-1] [j-v[i]]+w[i]

**自己写的**

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int f[N], w[N], v[N];
int n, m;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);

    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; --j)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];

    return 0;
}
```



> https://www.acwing.com/solution/content/1374/
>
> 一篇题解

（1）状态f[i] [j]定义：前 i 个物品，背包容量 j 下的最优解（最大价值）：

当前的状态依赖于之前的状态，可以理解为从初始状态f[0] [0] = 0开始决策，有 N 件物品，则需要 N 次决策，每一次对第 i 件物品的决策，状态f[i] [j]不断由之前的状态更新而来。
（2）当前背包容量不够（j < v[i]），没得选，因此前 i 个物品最优解即为前 i−1 个物品最优解：

对应代码：f[i] [j] = f[i - 1] [j]。
（3）当前背包容量够，可以选，因此需要决策选与不选第 i 个物品：

选：f[i] [j] = f[i - 1] [j - v[i]] + w[i]。
不选：f[i] [j] = f[i - 1] [j] 。
我们的决策是如何取到最大价值，因此以上两种情况取 max() 。

**二维代码**

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int v[MAXN];    // 体积
int w[MAXN];    // 价值 
int f[MAXN][MAXN];  // f[i][j], j体积下前i个物品的最大价值 

int main() 
{
    int n, m;   
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> v[i] >> w[i];

    for(int i = 1; i <= n; i++) 
        for(int j = 1; j <= m; j++)
        {
            //  当前背包容量装不进第i个物品，则价值等于前i-1个物品
            if(j < v[i]) 
                f[i][j] = f[i - 1][j];
            // 能装，需进行决策是否选择第i个物品
            else    
                f[i][j] = max(f[i - 1][j], f[i - 1][j - v[i]] + w[i]);
        }           

    cout << f[n][m] << endl;

    return 0;
}
```

将状态f[i][j]优化到一维 f[j]，实际上只需要做一个等价变形。

为什么可以这样变形呢？我们定义的状态 f[i] [j] 可以求得任意合法的i与j最优解，但题目只需要求得最终状态f[n] [m]，因此我们只需要一维的空间来更新状态。

（1）状态 f[j] 定义：N 件物品，背包容量 j 下的最优解。

（2）注意枚举背包容量 j 必须从 m 开始。

（3）为什么一维情况下枚举背包容量需要逆序？在二维情况下，状态 f[i] [j] 是由上一轮i - 1的状态得来的，f[i] [j]与 f[i - 1] [j] 是独立的。而优化到一维后，如果我们还是正序，则有 f[较小体积] 更新到 f[较大体积] ，则有可能本应该用第 i-1 轮的状态却用的是第 i 轮的状态。

（4）例如，一维状态第i轮对体积为 3 的物品进行决策，则 f[7] 由 f[4] 更新而来，这里的 f[4] 正确应该是f[i - 1] [4]，但从小到大枚举 j 这里的 f[4] 在第i轮计算却变成了 f[i] [4]。当逆序枚举背包容量 j 时，我们求 f[7] 同样由 f[4] 更新，但由于是逆序，这里的 f[4] 还没有在第 i 轮计算，所以此时实际计算的 f[4] 仍然是 f[i - 1] [4]。

（5）简单来说，一维情况正序更新状态f[j]需要用到前面计算的状态已经被「污染」，逆序则不会有这样的问题。

状态转移方程为：f[j] = max(f[j], f[j - v[i]] + w[i] 。

**自己写得一维代码**

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;

int f[N], w[N], v[N];
int n, m;

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) scanf("%d%d", &v[i], &w[i]);

    for (int i = 1; i <= n; i++)
        for (int j = m; j >= v[i]; --j)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    cout << f[m];

    return 0;
}
```

关于状态 f[j] 的补充说明
二维下的状态定义 f[i] [j] 是前 i 件物品，背包容量 j 下的最大价值。一维下，少了前 i 件物品这个维度，我们的代码中决策到第 i 件物品（循环到第 i 轮），f[j] 就是前 i 轮已经决策的物品且背包容量 j 下的最大价值。

因此当执行完循环结构后，由于已经决策了所有物品，f[j] 就是所有物品背包容量 j 下的最大价值。即一维 f[j] 等价于二维 f[n] [j]。

另外，我们注意到在处理数据时，我们是一个物品一个物品，一个一个体积的枚举。

因此我们可以不必开两个数组记录体积和价值，而是边输入边处理。

```c++
#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1005;
int f[MAXN];  // 

int main() 
{
    int n, m;   
    cin >> n >> m;

    for(int i = 1; i <= n; i++) {
        int v, w;
        cin >> v >> w;      // 边输入边处理
        for(int j = m; j >= v; j--)
            f[j] = max(f[j], f[j - v] + w);
    }

    cout << f[m] << endl;

    return 0;
}
```



## AcWing 1015. 摘花生

https://www.acwing.com/problem/content/1017/

Hello Kitty想摘点花生送给她喜欢的米老鼠。

她来到一片有网格状道路的矩形花生地(如下图)，从西北角进去，东南角出来。

地里每个道路的交叉点上都有种着一株花生苗，上面有若干颗花生，经过一株花生苗就能摘走该它上面所有的花生。

Hello Kitty只能向东或向南走，不能向西或向北走。

问Hello Kitty最多能够摘到多少颗花生。

![1.gif](%E5%BA%93/19_a8509f26d5-1.gif)

#### 输入格式

第一行是一个整数T，代表一共有多少组数据。

接下来是T组数据。

每组数据的第一行是两个整数，分别代表花生苗的行数R和列数 C。

每组数据的接下来R行数据，从北向南依次描述每行花生苗的情况。每行数据有C个整数，按从西向东的顺序描述了该行每株花生苗上的花生数目M。

#### 输出格式

对每组输入数据，输出一行，内容为Hello Kitty能摘到得最多的花生颗数。

#### 数据范围

1≤T≤100
1≤R,C≤100
0≤M≤1000

#### 输入样例：

```
2
2 2
1 1
3 4
2 3
2 3 4
1 6 5
```

#### 输出样例：

```
8
16
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 110;
int a[N][N];

int main() {
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                scanf("%d", &a[i][j]);

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++) {
                a[i][j] = max(a[i - 1][j], a[i][j - 1]) + a[i][j];
            }
        cout << a[n][m] << endl;
    }
    return 0;
}
```



## AcWing 895. 最长上升子序列

https://www.acwing.com/problem/content/897/

给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 N。

第二行包含 N 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

1≤N≤1000
−10^9^≤数列中的数≤10^9^

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n;
int a[N];
int f[N];

int main()
{
    cin >> n ;
    for (int i = 1; i <= n; i ++ ) cin >> a[i];

    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        f[i] = 1;
        for (int j = 1; j < i; j ++ )
            if (a[i] > a[j])
                f[i] = max(f[i], f[j] + 1);

        res = max(res, f[i]);
    }

    cout << res << endl;

    return 0;
}
```



## AcWing 1212. 地宫取宝

https://www.acwing.com/problem/content/1214/

X 国王有一个地宫宝库，是 n×m 个格子的矩阵，每个格子放一件宝贝，每个宝贝贴着价值标签。

地宫的入口在左上角，出口在右下角。

小明被带到地宫的入口，国王要求他只能向右或向下行走。

走过某个格子时，如果那个格子中的宝贝价值比小明手中任意宝贝价值都大，小明就可以拿起它（当然，也可以不拿）。

当小明走到出口时，如果他手中的宝贝恰好是 k 件，则这些宝贝就可以送给小明。

请你帮小明算一算，在给定的局面下，他有多少种不同的行动方案能获得这 k 件宝贝。

#### 输入格式

第一行 3 个整数，n,m,k，含义见题目描述。

接下来 n 行，每行有 m 个整数 Ci 用来描述宝库矩阵每个格子的宝贝价值。

#### 输出格式

输出一个整数，表示正好取 k 个宝贝的行动方案数。

该数字可能很大，输出它对 1000000007 取模的结果。

#### 数据范围

1≤n,m≤50
1≤k≤12
0≤Ci≤12

#### 输入样例1：

```
2 2 2
1 2
2 1
```

#### 输出样例1：

```
2
```

#### 输入样例2：

```
2 3 2
1 2 3
2 1 5
```

#### 输出样例2：

```
14
```

```c++

```

![image-20230102163337491](%E5%BA%93/image-20230102163337491.png)

![image-20230102165238957](%E5%BA%93/image-20230102165238957.png)

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 55, MOD = 1000000007;

int n, m, k;
int w[N][N];
int f[N][N][13][14];

int main()
{
    cin >> n >> m >> k;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            cin >> w[i][j];
            w[i][j] ++ ;
        }

    f[1][1][1][w[1][1]] = 1;
    f[1][1][0][0] = 1;

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
        {
            if (i == 1 && j == 1) continue;// 这句话对执行速度影响不大
            for (int u = 0; u <= k; u ++ )
                for (int v = 0; v <= 13; v ++ )
                {
                    int &val = f[i][j][u][v];
                    val = (val + f[i - 1][j][u][v]) % MOD;
                    val = (val + f[i][j - 1][u][v]) % MOD;
                    if (u > 0 && v == w[i][j])
                    {
                        for (int c = 0; c < v; c ++ )
                        {
                            val = (val + f[i - 1][j][u - 1][c]) % MOD;
                            val = (val + f[i][j - 1][u - 1][c]) % MOD;
                        }
                    }
                }
        }

    int res = 0;
    for (int i = 0; i <= 13; i ++ ) res = (res + f[n][m][k][i]) % MOD;

    cout << res << endl;

    return 0;
}
```



因为这道题的所有物品价值范围是 0…12，可以把他们全部都递增，范围就变成了 1…13，因为我们记录的是方案数，只关心各个物品之间的大小关系，具体数值不影响答案，但是这样的做法可以把 0 作为一个特殊边界来处理



> 一篇模仿y总思路的题解
>
> https://www.acwing.com/solution/content/7116/

![地宫取宝.png](%E5%BA%93/13359_7c304e7b9b-%E5%9C%B0%E5%AE%AB%E5%8F%96%E5%AE%9D.png)



## AcWing 1214. 波动数列

https://www.acwing.com/problem/content/1216/

观察这个数列：

1 3 0 2 -1 1 -2 …

这个数列中后一项总是比前一项增加2或者减少3，**且每一项都为整数**。

栋栋对这种数列很好奇，他想知道长度为 n 和为 s 而且后一项总是比前一项增加 a 或者减少 b 的整数数列可能有多少种呢？

#### 输入格式

共一行，包含四个整数 n,s,a,b，含义如前面所述。

#### 输出格式

共一行，包含一个整数，表示满足条件的方案数。

由于这个数很大，请输出方案数除以 100000007 的余数。

#### 数据范围

1≤n≤1000
−10^9^≤s≤10^9^
1≤a,b≤10^6^

#### 输入样例：

```
4 10 2 3
```

#### 输出样例：

```
2
```

#### 样例解释

两个满足条件的数列分别是2 4 1 3和7 4 1 -2。

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010, MOD = 100000007;

int f[N][N];

int get_mod(int a, int b)   // 求a除以b的正余数
{
    return (a % b + b) % b;
}

int main()
{
    int n, s, a, b;
    cin >> n >> s >> a >> b;

    f[0][0] = 1;
    for (int i = 1; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            f[i][j] = (f[i - 1][get_mod(j - a * (n - i), n)] + f[i - 1][get_mod(j + b * (n - i), n)]) % MOD;

    cout << f[n - 1][get_mod(s, n)] << endl;

    return 0;
}
```

![image-20230103092523591](%E5%BA%93/image-20230103092523591.png)

 

# 枚举、模拟与排序

## AcWing 1210. 连号区间数

https://www.acwing.com/problem/content/description/1212/

小明这些天一直在思考这样一个奇怪而有趣的问题：

在 1∼N 的某个排列中有多少个连号区间呢？

这里所说的连号区间的定义是：

如果区间 [L,R] 里的所有元素（即此排列的第 L 个到第 R 个元素）递增排序后能得到一个长度为 R−L+1 的“连续”数列，则称这个区间连号区间。

当 N 很小的时候，小明可以很快地算出答案，但是当 N 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。

#### 输入格式

第一行是一个正整数 N，表示排列的规模。

第二行是 N 个不同的数字 Pi，表示这 N 个数字的某一排列。

#### 输出格式

输出一个整数，表示不同连号区间的数目。

#### 数据范围

1≤N≤10000
1≤Pi≤N

#### 输入样例1：

```
4
3 2 4 1
```

#### 输出样例1：

```
7
```

#### 输入样例2：

```
5
3 4 2 5 1
```

#### 输出样例2：

```
9
```

#### 样例解释

第一个用例中，有 77 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]
第二个用例中，有 99 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010, INF = 100000000;

int n;
int a[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> a[i];

    int res = 0;
    for (int i = 0; i < n; i ++ )   // 枚举区间左端点
    {
        int minv = INF, maxv = -INF;
        for (int j = i; j < n; j ++ )   // 枚举区间右端点
        {
            minv = min(minv, a[j]);
            maxv = max(maxv, a[j]);
            if (maxv - minv == j - i) res ++ ;
        }
    }

    cout << res << endl;

    return 0;
}
```



## AcWing 1236. 递增三元组

https://www.acwing.com/problem/content/1238/

给定三个整数数组

A=[A1,A2,…AN]
B=[B1,B2,…BN]
C=[C1,C2,…CN]

请你统计有多少个三元组 (i,j,k) 满足：

1. 1≤i,j,k≤N
2. Ai<Bj<Ck

#### 输入格式

第一行包含一个整数 N。

第二行包含 N 个整数 A1,A2,…AN

第三行包含 N 个整数 B1,B2,…BN

第四行包含 N 个整数 C1,C2,…CN

#### 输出格式

一个整数表示答案。

#### 数据范围

1≤N≤10^5^
0≤Ai,Bi,Ci≤10^5^

#### 输入样例：

```
3
1 1 1
2 2 2
3 3 3
```

#### 输出样例：

```
27
```

![image-20230103113356073](%E5%BA%93/image-20230103113356073.png)

**y总代码**

用的是前缀和的思路     O(n)

这里说明前缀和不仅可以用来求多个数的和，也可以用来求某些数出现的个数，非常的巧妙

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int a[N], b[N], c[N];
int as[N];  // as[i]表示在A[]中有多少个数小于b[i]
int cs[N];  // cs[i]表示在C[]中有多少个数大于b[i]
int cnt[N], s[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]), a[i] ++ ;
    for (int i = 0; i < n; i ++ ) scanf("%d", &b[i]), b[i] ++ ;
    for (int i = 0; i < n; i ++ ) scanf("%d", &c[i]), c[i] ++ ;

    // 求as[]
    for (int i = 0; i < n; i ++ ) cnt[a[i]] ++ ;
    for (int i = 1; i < N; i ++ ) s[i] = s[i - 1] + cnt[i];   // 求cnt[]的前缀和
    for (int i = 0; i < n; i ++ ) as[i] = s[b[i] - 1];

    // 求cs[]
    memset(cnt, 0, sizeof cnt);
    memset(s, 0, sizeof s);
    for (int i = 0; i < n; i ++ ) cnt[c[i]] ++ ;
    for (int i = 1; i < N; i ++ ) s[i] = s[i - 1] + cnt[i];
    for (int i = 0; i < n; i ++ ) cs[i] = s[N - 1] - s[b[i]];

    // 枚举每个b[i]
    LL res = 0;
    for (int i = 0; i < n; i ++ ) res += (LL)as[i] * cs[i];

    cout << res << endl;

    return 0;
}
```

**自己写的排序+二分**        O(nlog~2~n)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
typedef long long LL;
const int N = 100010;

int a[N], b[N], c[N];
int n;

int main() {
    cin >> n;

    for (int i = 0; i < n; i++) scanf("%d", &a[i]), a[i]++;
    for (int i = 0; i < n; i++) scanf("%d", &b[i]), b[i]++;
    for (int i = 0; i < n; i++) scanf("%d", &c[i]), c[i]++;

    sort(a, a + n);
    sort(c, c + n);

    LL res = 0;
    for (int i = 0; i < n; i++) {
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (a[mid] < b[i]) l = mid;
            else r = mid - 1;
        }
        int ans = l + 1;
        if (b[i] <= a[l])continue;//注意判断二分查找是否找到一个正确的位置，即查找失败的情况
        l = 0;
        r = n - 1;
        while (l < r) {
            int mid = l + r >> 1;
            if (c[mid] > b[i]) r = mid;
            else l = mid + 1;
        }
        if (b[i] < c[l]) res += (LL) ans * (n - l);//注意判断二分查找是否找到一个正确的位置，即查找失败的情况
    }
    cout << res;
    return 0;
}
```

**注意判断二分查找是否找到一个正确的位置**



- 该题目还可以利用双指针算法进行模拟。
- 本题最重要的思想就是要**从中间的数组 B 数组开始枚举**。如果从第一个数组 A 或者最后一个数组 C 枚举都会非常麻烦。



## AcWing 1245. 特别数的和

https://www.acwing.com/problem/content/1247/

小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 00），在 1 到 40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。

请问，在 1 到 n 中，所有这样的数的和是多少？

#### 输入格式

共一行，包含一个整数 n。

#### 输出格式

共一行，包含一个整数，表示满足条件的数的和。

#### 数据范围

1≤n≤10000

#### 输入样例：

```
40
```

#### 输出样例：

```
574
```

数据范围特别小，用不到数位DP，直接暴算即可

```c++
#include<bits/stdc++.h>

using namespace std;

int n;

long long res;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int j = i;
        while (j) {
            int e = j % 10;
            if (e == 1 || e == 2 || e == 9 || e == 0) {
                res += i;
                break;
            }
            j /= 10;
        }
    }
    cout << res;
    return 0;
}
```



## AcWing 1204. 错误票据

https://www.acwing.com/problem/content/1206/

某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的ID号。

全年所有票据的ID号是连续的，但ID的开始数码是随机选定的。

因为工作人员疏忽，在录入ID号的时候发生了一处错误，造成了某个ID断号，另外一个ID重号。

你的任务是通过编程，找出断号的ID和重号的ID。

假设断号不可能发生在最大和最小号。

#### 输入格式

第一行包含整数 N，表示后面共有 N 行数据。

接下来 N 行，每行包含空格分开的若干个（不大于100个）正整数（不大于100000），每个整数代表一个ID号。

#### 输出格式

要求程序输出1行，含两个整数 m,n，用空格分隔。

其中，m表示断号ID，n表示重号ID。

#### 数据范围

1≤N≤100

#### 输入样例：

```
2
5 6 8 11 9 
10 12 9
```

#### 输出样例：

```
7 9
```

```c++
#include <cstring>
#include <sstream>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 10010;

int n;
int a[N];

int main()
{
    int cnt;
    cin >> cnt;
    string line;

    getline(cin, line); // 忽略掉第一行的回车
    while (cnt -- )
    {
        getline(cin, line);
        stringstream ssin(line);

        while (ssin >> a[n]) n ++ ;
    }

    sort(a, a + n);

    int res1, res2;
    for (int i = 1; i < n; i ++ )
        if (a[i] == a[i - 1]) res2 = a[i];  // 重号
        else if (a[i] >= a[i - 1] + 2) res1 = a[i] - 1; // 断号

    cout << res1 << ' ' << res2 << endl;

    return 0;
}
```

**另外一种处理输入的方式**

直接读入第一个行数，但是不实际使用，算是处理垃圾数据

```c++
//错误票据
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int a[N];

int main()
{
    int x, i = 0;
    cin >> x;//过滤
    while(cin >> x) a[i++] = x;

    int len = i;//表示数组长度

    sort(a, a + len);

    int n, m;
    for(int i = 1; i < len; i++)
    {
        if(a[i] == a[i - 1]) n = a[i];//重号ID
        else if(a[i] >= a[i - 1] + 2) m = a[i] - 1;//断号ID
    }

    cout << m << " " << n << endl;
    return 0;
}
```



## AcWing 466. 回文日期

https://www.acwing.com/problem/content/468/

在日常生活中，通过年、月、日这三个要素可以表示出一个唯一确定的日期。

牛牛习惯用 8 位数字表示一个日期，其中，前 4 位代表年份，接下来 2 位代表月份，最后 2 位代表日期。

显然：一个日期只有一种表示方法，而两个不同的日期的表示方法不会相同。

牛牛认为，一个日期是回文的，当且仅当表示这个日期的 8 位数字是回文的。

现在，牛牛想知道：在他指定的两个日期之间（包含这两个日期本身），有多少个真实存在的日期是回文的。

一个 8 位数字是回文的，当且仅当对于所有的 i(1≤i≤8) 从左向右数的第 i 个数字和第 9−i 个数字（即从右向左数的第 i 个数字）是相同的。

例如：

- 对于 2016 年 11 月 19 日，用 8 位数字 20161119 表示，它不是回文的。
- 对于 2010 年 1 月 2 日，用 8 位数字 20100102 表示，它是回文的。
- 对于 2010 年 10 月 2 日，用 8 位数字 20101002 表示，它不是回文的。

#### 输入格式

输入包括两行，每行包括一个 8 位数字。

第一行表示牛牛指定的起始日期 date1，第二行表示牛牛指定的终止日期 date2。保证 date1 和 date2 都是真实存在的日期，且年份部分一定为 4 位数字，且首位数字不为 0。

保证 date1 一定不晚于 date2。

#### 输出格式

输出共一行，包含一个整数，表示在 date1 和 date2 之间，有多少个日期是回文的。

#### 输入样例：

```
20110101
20111231
```

#### 输出样例：

```
1
```

```c++
#include<bits/stdc++.h>

using namespace std;

int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool check(int data) {
    int year = data / 10000;
    int month = data / 100 % 100;
    int day = data % 100;

    if (month == 0 || month >= 13) return false;
    if (day == 0 || (month != 2 && day > days[month])) return false;
    if (month == 2) {
        int leap = year % 400 == 0 || (year % 4 == 0 && year % 100 != 0); // 注意这里如何设置 leap 变量
        if (day > days[2] + leap) return false;
    }
    return true;
}

int main() {
    int data1, data2;
    cin >> data1 >> data2;

    int res = 0;
    for (int i = 1000; i < 10000; ++i) {
        int data = i, x = i;
        for (int j = 0; j < 4; j++) {
            data = data * 10 + x % 10;
            x /= 10;
        }
        if (data1 <= data && data <= data2 && check(data)) res++;
    }
    cout << res;
    return 0;
}
```

注意代码中如何设置的 leap 变量来测试闰年的问题。同时整个 check 函数也是非常常用的日期检查函数



## AcWing 787. 归并排序

https://www.acwing.com/problem/content/789/

给定你一个长度为 n 的整数数列。

请你使用归并排序对这个数列按照从小到大进行排序。

并将排好序的数列按顺序输出。

#### 输入格式

输入共两行，第一行包含整数 n。

第二行包含 n 个整数（所有整数均在 1∼10^9^ 范围内），表示整个数列。

#### 输出格式

输出共一行，包含 n 个整数，表示排好序的数列。

#### 数据范围

1≤n≤100000

#### 输入样例：

```
5
3 1 2 4 5
```

#### 输出样例：

```
1 2 3 4 5
```

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 100010;
int a[N], tmp[N];
int n;

void merge_sort(int q[], int l, int r)  // 归并排序
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];

    while (i <= mid) tmp[k++] = q[i++];
    while (j <= r) tmp[k++] = q[j++];

    for (i = l, j = 0; i <= r; i++, j++) q[i] = tmp[j];
}


int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    merge_sort(a, 0, n - 1);
    for (int i = 0; i < n; i++) printf("%d ", a[i]);

    return 0;
}
```



## AcWing 1219. 移动距离

https://www.acwing.com/problem/content/description/1221/

X星球居民小区的楼房全是一样的，并且按矩阵样式排列。

其楼房的编号为 1,2,3…

当排满一行时，从下一行相邻的楼往反方向排号。

比如：当小区排号宽度为 6 时，开始情形如下：

```
1  2  3  4  5  6
12 11 10 9  8  7
13 14 15 .....
```

我们的问题是：已知了两个楼号 m 和 n，需要求出它们之间的最短移动距离（不能斜线方向移动）。

#### 输入格式

输入共一行，包含三个整数 w,m,n，w 为排号宽度，m,n 为待计算的楼号。

#### 输出格式

输出一个整数，表示 m,n 两楼间最短移动距离。

#### 数据范围

1≤w,m,n≤10000

#### 输入样例：

```
6 8 2
```

#### 输出样例：

```
4
```

**自己写的**

主要是预处理出来所有楼的坐标，然后直接作差即可，甚至在多次询问中也会有非常好的时间复杂度，虽然这个题没有要求多次查询

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;

int main() {
    int w, m, n;
    cin >> w >> m >> n;

    vector<PII> v;

    bool flag = false;
    int x = 1, y = 1;
    for (int i = 1; i <= 10000; i++) {
        if (!flag) {
            v.push_back({x, y++});
            if (y > w) {
                flag = true;
                x++;
                y = w;
            }
        } else {
            v.push_back({x, y--});
            if (y == 0) {
                x++;
                flag = false;
                y++;
            }
        }
        //cout<<v[i-1].first<<" "<<v[i-1].second<<endl;
    }

    auto a = v[m - 1];
    auto b = v[n - 1];
    //cout<<a.first<<" "<<b.first<<" "<<a.second<<" "<<b.second<<endl;
    cout << abs(a.first - b.first) + abs(a.second - b.second);
    return 0;
}
```



**y总代码**

![image-20230103185938519](%E5%BA%93/image-20230103185938519.png)

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
    int w, m, n;
    cin >> w >> m >> n;
    m --, n -- ;

    int x1 = m / w, x2 = n / w;
    int y1 = m % w, y2 = n % w;
    if (x1 % 2) y1 = w - 1 - y1;
    if (x2 % 2) y2 = w - 1 - y2;

    cout << abs(x1 - x2) + abs(y1 - y2) << endl;

    return 0;
}
```



## AcWing 1229. 日期问题

https://www.acwing.com/problem/content/1231/

小明正在整理一批历史文献。这些历史文献中出现了很多日期。

小明知道这些日期都在1960年1月1日至2059年12月31日。

令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。

更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。

比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。

给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？

#### 输入格式

一个日期，格式是”AA/BB/CC”。

即每个’/’隔开的部分由两个 0-9 之间的数字（不一定相同）组成。

#### 输出格式

输出若干个不相同的日期，每个日期一行，格式是”yyyy-MM-dd”。

多个日期按从早到晚排列。

#### 数据范围

0≤A,B,C≤9

#### 输入样例：

```
02/03/04
```

#### 输出样例：

```
2002-03-04
2004-02-03
2004-03-02
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int days[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool check_valid(int year, int month, int day)
{
    if (month == 0 || month > 12) return false;
    if (day == 0) return false;
    if (month != 2)
    {
        if (day > days[month]) return false;
    }
    else
    {
        int leap = year % 100 && year % 4 == 0 || year % 400 == 0;
        if (day > 28 + leap) return false;
    }

    return true;
}

int main()
{
    int a, b, c;
    scanf("%d/%d/%d", &a, &b, &c);

    for (int date = 19600101; date <= 20591231; date ++ )
    {
        int year = date / 10000, month = date % 10000 / 100, day = date % 100;
        if (check_valid(year, month, day))
        {
            if (year % 100 == a && month == b && day == c ||        // 年/月/日
                month == a && day == b && year % 100 == c ||        // 月/日/年
                day == a && month == b &&year % 100 == c)           // 日/月/年
                printf("%d-%02d-%02d\n", year, month, day);
        }
    }

    return 0;
}
```



## AcWing 1231. 航班时间

https://www.acwing.com/problem/content/1233/

小 h 前往美国参加了蓝桥杯国际赛。

小 h 的女朋友发现小 h 上午十点出发，上午十二点到达美国，于是感叹到“现在飞机飞得真快，两小时就能到美国了”。

小 h 对超音速飞行感到十分恐惧。

仔细观察后发现飞机的起降时间都是当地时间。

由于北京和美国东部有 12 小时时差，故飞机总共需要 14 小时的飞行时间。

不久后小 h 的女朋友去中东交换。

小 h 并不知道中东与北京的时差。

但是小 h 得到了女朋友来回航班的起降时间。

小 h 想知道女朋友的航班飞行时间是多少。

对于一个可能跨时区的航班，给定来回程的起降时间。

假设飞机来回飞行时间相同，求飞机的飞行时间。

#### 输入格式

一个输入包含多组数据。

输入第一行为一个正整数 T，表示输入数据组数。

每组数据包含两行，第一行为去程的起降时间，第二行为回程的起降时间。

起降时间的格式如下:

1. h1:m1:s1 h2:m2:s2
2. h1:m1:s1 h3:m3:s3 (+1)
3. h1:m1:s1 h4:m4:s4 (+2)

第一种格式表示该航班在**当地**时间h1时m1分s1秒起飞，在**当地**时间**当日**h2时m2分s2秒降落。

第二种格式表示该航班在**当地**时间h1时m1分s1秒起飞，在**当地**时间**次日**h2时m2分s2秒降落。

第三种格式表示该航班在**当地**时间h1时m1分s1秒起飞，在**当地**时间**第三日**h2时m2分s2秒降落。

#### 输出格式

对于每一组数据输出一行一个时间hh:mm:ss，表示飞行时间为hh小时mm分ss秒。

注意，当时间为一位数时，要补齐前导零，如三小时四分五秒应写为03:04:05。

#### 数据范围

保证输入时间合法（0≤h≤23,0≤m,s≤59），飞行时间不超过24小时。

#### 输入样例：

```
3
17:48:19 21:57:24
11:05:18 15:14:23
17:21:07 00:31:46 (+1)
23:02:41 16:13:20 (+1)
10:19:19 20:41:24
22:19:04 16:41:09 (+1)
```

#### 输出样例：

```
04:09:05
12:10:39
14:22:05
```

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

int get_seconds(int h, int m, int s)
{
    return h * 3600 + m * 60 + s;
}

int get_time()
{
    string line;
    getline(cin, line);

    if (line.back() != ')') line += " (+0)";

    int h1, m1, s1, h2, m2, s2, d;
    sscanf(line.c_str(), "%d:%d:%d %d:%d:%d (+%d)", &h1, &m1, &s1, &h2, &m2, &s2, &d);

    return get_seconds(h2, m2, s2) - get_seconds(h1, m1, s1) + d * 24 * 3600;
}

int main()
{
    int n;
    scanf("%d", &n);
    string line;
    getline(cin, line);     // 忽略掉第一行的回车
    while (n -- )
    {
        int time = (get_time() + get_time()) / 2;
        int hour = time / 3600, minute = time % 3600 / 60, second = time % 60;
        printf("%02d:%02d:%02d\n", hour, minute, second);
    }

    return 0;
}
```



string中c_str()的使用方法和特性

- c_str()是Borland封装的String类中的一个函数，它返回当前字符串的首字符地址。换种说法，c_str()函数返回一个指向正规C字符串的***指针常量***，内容与本string串相同。这是为了与C语言兼容，在C语言中没有string类型，故必须通过string类对象的成员函数c_str()把string对象转换成C中的字符串样式。

- c_str()的原型是：`const char*c_str() const;`

- **c_str()生成一个const char*指针，指向以空字符终止的数组。**<u>而data()与c_str()类似，但是返回的数组不以空字符终止。</u>

- 注意：一定要使用strcpy()等函数来操作c_str()返回的指针。例如下面这样直接赋值就是错误的：

    ```c++
    char* c; 
    string s="1234"; 
    c = s.c_str();
    ```

    上述代码中，c最后指向的内容是垃圾，因为s对象被析构，其内容被处理，同时编译器将会报错。正确代码如下：

    ```c++
    char *cstr,*p;
    string str ("Please split this phrase into tokens");
    cstr = new char [str.size()+1];
    strcpy (cstr, str.c_str());
    ```

    

> 《string中c_str()的使用方法和特性》原文连接：
>
> https://zhuanlan.zhihu.com/p/166169343#:~:text=c_str%20%28%29%E6%98%AFBorland%E5%B0%81%E8%A3%85%E7%9A%84String%E7%B1%BB%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%83%E8%BF%94%E5%9B%9E%E5%BD%93%E5%89%8D%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E9%A6%96%E5%AD%97%E7%AC%A6%E5%9C%B0%E5%9D%80%E3%80%82%20%E6%8D%A2%E7%A7%8D%E8%AF%B4%E6%B3%95%EF%BC%8Cc_str,%28%29%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E6%AD%A3%E8%A7%84C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%20%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F%20%EF%BC%8C%E5%86%85%E5%AE%B9%E4%B8%8E%E6%9C%ACstring%E4%B8%B2%E7%9B%B8%E5%90%8C%E3%80%82



## AcWing 1241. 外卖店优先级

https://www.acwing.com/problem/content/1243/

“饱了么”外卖系统中维护着 N 家外卖店，编号 1∼N。

每家外卖店都有一个优先级，初始时 (0 时刻) 优先级都为 0。

每经过 1 个时间单位，如果外卖店没有订单，则优先级会减少 1，最低减到 0；而如果外卖店有订单，则优先级不减反加，每有一单优先级加 2。

如果某家外卖店某时刻优先级大于 5，则会被系统加入优先缓存中；如果优先级小于等于 3，则会被清除出优先缓存。

给定 T 时刻以内的 M 条订单信息，请你计算 T 时刻时有多少外卖店在优先缓存中。

#### 输入格式

第一行包含 3 个整数 N,M,T。

以下 M 行每行包含两个整数 ts 和 id，表示 ts 时刻编号 id 的外卖店收到一个订单。

#### 输出格式

输出一个整数代表答案。

#### 数据范围

1≤N,M,T≤10^5^
1≤ts≤T
1≤id≤N

#### 输入样例：

```
2 6 6
1 1
5 2
3 1
6 2
2 1
6 2
```

#### 输出样例：

```
1
```

#### 样例解释

6 时刻时，1 号店优先级降到 3，被移除出优先缓存；2 号店优先级升到 6，加入优先缓存。

所以是有 1 家店 (2 号) 在优先缓存中。



自己写的代码，STL容器使用有问题

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 1e5+10;
typedef pair<int, int> PII;

unordered_map<int,int> unorderedMap;// 编号    优先级
bool st[N];
vector<PII> v;//时间，编号
int n,m,t;

bool cmp(PII a,PII b){
    return a.first<b.first;
}

int main(){
    cin>>n>>m>>t;
    //处理请求
    for(int i=0;i<m;i++){
        int a,b;
        cin>>a>>b;
        v.push_back({a,b});
    }

    sort(v.begin(),v.end(),cmp);
    //cout<<v.size()<<endl;
    //cout<<v[0].first<<endl;
    //按照时间处理
    int j=0;
    for(int i=1;i<=t;i++){
        while(j<=v.size()-1&&v[j].first<=i){
            //cout<<v[j].first<<"   "<<v[j].second<<endl;
            //cout<<"处理请求之前 "<<unorderedMap[v[j].first]<<" "<<unorderedMap[v[j].second]<<endl;
            //cout<<"请求 "<<v[j].first<<" "<<v[j].second<<endl;
            unorderedMap[v[j].second]+=2;
            //cout<<"处理请求之后 "<<v[j].first<<" "<<unorderedMap[v[j].second]<<endl;
            if(unorderedMap[v[j].second] > 5){
                st[v[j].second] =true;
                //cout<<v[j].second<<"大于5"<<endl;
            } 
            ++j;
        }
        for(auto t:unorderedMap){
            //cout<<t.first<<"减之前"<<t.second<<endl;
            t.second-=1;
            //cout<<t.first<<"减之后"<<t.second<<endl;
            //cout<<"编号 优先级 "<<t.first<<"  "<<t.second<<endl;
            if(t.second<=3) st[t.first]=false;
        }
    }
    int res=0;
    
    for(auto t:unorderedMap){
        if(st[t.first]){
            cout<<t.first<<endl;
            res++;
        } 
    }
    cout<<res;
    return 0;
}
```

这里

```c++
for(auto t:unorderedMap){
	t.second-=1;
    if(t.second<=3) st[t.first]=false;
}
```

需要使用引用

```c++
for(auto &t:unorderedMap){
	t.second-=1;
    if(t.second<=3) st[t.first]=false;
}
```



**y总思路**

![image-20230104135659150](%E5%BA%93/image-20230104135659150.png)

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>

#define x first
#define y second

using namespace std;

typedef pair<int, int> PII;

const int N = 100010;

int n, m, T;
int score[N], last[N];
bool st[N];

PII order[N];

int main()
{
    scanf("%d%d%d", &n, &m, &T);
    for (int i = 0; i < m; i ++ ) scanf("%d%d", &order[i].x, &order[i].y);
    sort(order, order + m);

    for (int i = 0; i < m;)
    {
        int j = i;
        while (j < m && order[j] == order[i]) j ++ ;
        int t = order[i].x, id = order[i].y, cnt = j - i;
        i = j;

        score[id] -= t - last[id] - 1;
        if (score[id] < 0) score[id] = 0;
        if (score[id] <= 3) st[id] = false; // 以上处理的是t时刻之前的信息

        score[id] += cnt * 2;
        if (score[id] > 5) st[id] = true;

        last[id] = t;
    }

    for (int i = 1; i <= n; i ++ )
        if (last[i] < T)
        {
            score[i] -= T - last[i];
            if (score[i] <= 3) st[i] = false;
        }

    int res = 0;
    for (int i = 1; i <= n; i ++ ) res += st[i];

    printf("%d\n", res);

    return 0;
}
```





## AcWing 788. 逆序对的数量

https://www.acwing.com/problem/content/790/

给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。

逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i<j 且 a[i]>a[j]，则其为一个逆序对；否则不是。

#### 输入格式

第一行包含整数 n，表示数列的长度。

第二行包含 n 个整数，表示整个数列。

#### 输出格式

输出一个整数，表示逆序对的个数。

#### 数据范围

1≤n≤100000
数列中的元素的取值范围 [1,10^9^]

#### 输入样例：

```
6
2 3 4 5 6 1
```

#### 输出样例：

```
5
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6 + 10;
int a[N], tmp[N];
int n;

unsigned long long int merge_sort(int l, int r) {
    if (l >= r) return 0;
    int mid = l + r >> 1;
    auto res = merge_sort(l, mid) + merge_sort(mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r) {
        if (a[i] <= a[j])tmp[k++] = a[i++];
        else {
            res += mid - i + 1;
            tmp[k++] = a[j++];
        }
    }
    while (i <= mid) tmp[k++] = a[i++];
    while (j <= r) tmp[k++] = a[j++];

    for (int i = 0, j = l; j <= r; i++, j++) a[j] = tmp[i];
    return res;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    cout << merge_sort(0, n - 1);
    return 0;
}
```

![image-20230104120438452](%E5%BA%93/image-20230104120438452.png)
