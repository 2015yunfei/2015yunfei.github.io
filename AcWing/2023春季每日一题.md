## AcWing 3384. 二叉树遍历

https://www.acwing.com/problem/content/3387/

编写一个程序，读入用户输入的一串先序遍历字符串，根据此字符串建立一个二叉树（以指针方式存储）。 

例如如下的先序遍历字符串： `abc##de#g##f###` 其中 `#` 表示的是空格，空格字符代表空树。

建立起此二叉树以后，再对二叉树进行中序遍历，输出遍历结果。

#### 输入格式

共一行，包含一个字符串，表示先序遍历字符串。

#### 输出格式

共一行，输出将输入字符串建立二叉树后中序遍历的序列，字符之间用空格隔开。

注意，输出中不用包含 `#`。

#### 数据范围

输入字符串长度不超过 100，且只包含小写字母和 `#`。

#### 输入样例：

```
abc##de#g##f###
```

#### 输出样例：

```
c b e g d f a
```

```c++
#include <bits/stdc++.h>

using namespace std;
int k;
string s;

void dfs() {
    if (s[k] == '#') {
        k++;
        return;
    }
    char r = s[k++];
    dfs();
    cout << r << " ";
    dfs();
}

int main() {
    cin >> s;
    dfs();
    return 0;
}
```



## AcWing 4956. 冶炼金属

https://www.acwing.com/problem/content/4959/

小蓝有一个神奇的炉子用于将普通金属 *O* 冶炼成为一种特殊金属 *X*。

这个炉子有一个称作转换率的属性 *V*，*V* 是一个正整数，这意味着消耗 *V* 个普通金属 *O* 恰好可以冶炼出一个特殊金属 *X*，当普通金属 *O* 的数目不足 *V* 时，无法继续冶炼。

现在给出了 *N* 条冶炼记录，每条记录中包含两个整数 *A* 和 *B*，这表示本次投入了 *A* 个普通金属 *O*，最终冶炼出了 *B* 个特殊金属 *X*。

每条记录都是独立的，这意味着上一次没消耗完的普通金属 *O* 不会累加到下一次的冶炼当中。

根据这 *N* 条冶炼记录，请你推测出转换率 *V* 的最小值和最大值分别可能是多少，**题目保证评测数据不存在无解的情况**。

#### 输入格式

第一行一个整数 *N*，表示冶炼记录的数目。

接下来输入 *N* 行，每行两个整数 *A*、*B*，含义如题目所述。

#### 输出格式

输出两个整数，分别表示 *V* 可能的最小值和最大值，中间用空格分开。

#### 数据范围

对于 30% 的评测用例，1≤*N*≤10^2^
对于 60% 的评测用例，1≤*N*≤10^3^
对于 100% 的评测用例，1≤*N*≤10^4^，1≤*B*≤*A*≤10^9^

#### 输入样例：

```
3
75 3
53 2
59 2
```

#### 输出样例：

```
20 25
```

#### 样例解释

当 *V*=20 时，有：⌊7520⌋=3，⌊5320⌋=2，⌊5920⌋=2，可以看到符合所有冶炼记录。

当 *V*=25 时，有：⌊7525⌋=3，⌊5325⌋=2，⌊5925⌋=2，可以看到符合所有冶炼记录。

且再也找不到比 20 更小或者比 25 更大的符合条件的 *V* 值了。

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
typedef long long int LL;
const int N = 1e4 + 10;
int n;
PII d[N];

bool check1(int x) {
    if (x == 0) return false;
    LL res = 0, num = 0;
    for (int i = 0; i < n; ++i) {
        res += d[i].first / x;
        num += d[i].second;
    }
    if (res <= num) return true;
    return false;
}

bool check2(int x) {
    if (x == 0) return true;
    LL res = 0, num = 0;
    for (int i = 0; i < n; ++i) {
        res += d[i].first / x;
        num += d[i].second;
    }
    if (res >= num) return true;
    return false;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> d[i].first >> d[i].second;

    int l = 0, r = 1e9;
    while (l < r) {
        int mid = l + r >> 1;
        if (check1(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << " ";
    l = 0, r = 1e9;
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (check2(mid)) l = mid;
        else r = mid - 1;
    }
    cout << l << endl;
    return 0;
}
```

**注意函数的参数 x 可能是 0 ，需要进行特判！**



## AcWing 4957. 飞机降落

https://www.acwing.com/problem/content/4960/

有 *N* 架飞机准备降落到某个只有一条跑道的机场。

其中第 *i* 架飞机在 *Ti* 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 *Di* 个单位时间，即它最早可以于 *Ti* 时刻开始降落，最晚可以于 *Ti*+*Di* 时刻开始降落。

降落过程需要 *Li* 个单位时间。

一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。

请你判断 *N* 架飞机是否可以全部安全降落。

#### 输入格式

输入包含多组数据。

第一行包含一个整数 *T*，代表测试数据的组数。对于每组数据，第一行包含一个整数 *N*。

以下 *N* 行，每行包含三个整数：*i*，*Di* 和 *Li*。

#### 输出格式

对于每组数据，输出 `YES` 或者 `NO`，代表是否可以全部安全降落。

#### 数据范围

对于 30% 的数据，*N*≤2。 对于 100% 的数据，1≤*T*≤10，1≤*N*≤10，0≤*Ti*,*Di*,*Li*≤105。

#### 输入样例：

```
2
3
0 100 10
10 10 10
0 2 20
3
0 10 20
10 10 20
20 10 20
```

#### 输出样例：

```
YES
NO
```

#### 样例解释

对于第一组数据，可以安排第 3 架飞机于 0 时刻开始降落，20 时刻完成降落。安排第 2 架飞机于 20 时刻开始降落，30 时刻完成降落。安排第 1 架飞机于 30 时刻开始降落，40 时刻完成降落。

对于第二组数据，无论如何安排，都会有飞机不能及时降落。

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 12;
int n, t[N], d[N], l[N];
bool st[N], flag;

void dfs(int x, int last) {
    if (x == n) {
        puts("YES");
        flag = true;
    }
    if (flag) return;
    for (int i = 1; i <= n; ++i) {
        if (!st[i]) {
            if (last > t[i] + d[i]) continue;
            st[i] = true;
            if (last < t[i]) {
                dfs(x + 1, t[i] + l[i]);
            } else {
                dfs(x + 1, last + l[i]);
            }
            st[i] = false;
        }
    }
}

void solve() {
    cin >> n;
    flag = false;
    memset(st, false, sizeof st);
    for (int i = 1; i <= n; ++i) cin >> t[i] >> d[i] >> l[i];
    dfs(0, 0);
    if (!flag) puts("NO");
}

int main() {
    int t;
    cin >> t;
    while (t--) solve();
    return 0;
}
```

看 N 最大为10，T 最大也为10，考虑全排列枚举所有的降落情况，只要有一种符合的情况即可，大概计算一下复杂度为10 ! × 10 × 10 等于3e8，理论可过 。使用dfs剪枝可以提高效率。



## AcWing 4958. 接龙数列

https://www.acwing.com/problem/content/4961/

对于一个长度为 *K* 的整数数列：*A*1,*A*2,...,*A**K*，我们称之为接龙数列当且仅当 *Ai* 的首位数字恰好等于 *Ai*−1 的末位数字 (2≤*i*≤*K*)。

例如 12,23,35,56,61,11 是接龙数列；12,23,34,56 不是接龙数列，因为 56 的首位数字不等于 34 的末位数字。

所有长度为 1 的整数数列都是接龙数列。

现在给定一个长度为 *N* 的数列 *A*1,*A*2,...,*AN*，请你计算最少从中删除多少个数，可以使剩下的序列是接龙序列？

#### 输入格式

第一行包含一个整数 *N*。

第二行包含 *N* 个整数 *A*1,*A*2,...,*AN*。

#### 输出格式

一个整数代表答案。

#### 数据范围

对于 20% 的数据，1≤*N*≤20。
对于 50% 的数据，1≤*N*≤10000。
对于 100% 的数据，1≤*N*≤105，1≤*Ai*≤109。所有 *A* 保证不包含前导 0

#### 输入样例：

```
5
11 121 22 12 2023
```

#### 输出样例：

```
1
```

#### 样例解释

删除 22，剩余 11,121,12,2023 是接龙数列。

```c++
#include <bits/stdc++.h>

using namespace std;
int n, a[12];

int main() {
    cin >> n;
    string s;
    for (int i = 0; i < n; ++i) {
        cin >> s;
        a[s[s.size() - 1] - '0'] = max(a[s[s.size() - 1] - '0'], a[s[0] - '0'] + 1);
    }
    int ans = 0;
    for (int i = 0; i <= 9; ++i) ans = max(ans, a[i]);
    cout << n - ans << endl;
    return 0;
}
```



## AcWing 4964. 子矩阵

https://www.acwing.com/problem/content/4967/

给定一个 *n*×*m* （*n* 行 *m* 列）的矩阵。

设一个矩阵的价值为其所有数中的最大值和最小值的乘积。

求给定矩阵的所有大小为 *a*×*b* （*a* 行 *b* 列）的子矩阵的价值的和。

答案可能很大，你只需要输出答案对 998244353 取模后的结果。

#### 输入格式

输入的第一行包含四个整数分别表示 *n*,*m*,*a*,*b*，相邻整数之间使用一个空格分隔。

接下来 *n* 行每行包含 *m* 个整数，相邻整数之间使用一个空格分隔，表示矩阵中的每个数 *Ai*,*j*。

#### 输出格式

输出一行包含一个整数表示答案。

#### 数据范围

对于 40%的评测用例，1≤*n*,*m*≤100
对于 70% 的评测用例，1≤*n*,*m*≤500
对于所有评测用例，1≤*a*≤*n*≤1000，1≤*b*≤*m*≤1000，1≤*Ai*,*j*≤10^9^

#### 输入样例：

```
2 3 1 2
1 2 3
4 5 6
```

#### 输出样例：

```
58
```

#### 样例解释

1×2+2×3+4×5+5×6=58

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 1010, mod = 998244353;
int n, m, a, b, s[N][N], q[N], qq[N], maxx[N][N], minn[N][N];

int main() {
    cin >> n >> m >> a >> b;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) scanf("%d", &s[i][j]);

    for (int j = 1; j <= m; ++j) {
        int h = 0, t = -1;
        memset(q, 0, sizeof q);
        for (int i = 1; i <= n; ++i) {
            if (h <= t && i - a + 1 > q[h]) h++;
            while (h <= t && s[q[t]][j] <= s[i][j]) t--;
            q[++t] = i;
            if (i - a + 1 >= 1) maxx[i - a + 1][j] = s[q[h]][j];
        }
    }
    for (int j = 1; j <= m; ++j) {
        int h = 0, t = -1;
        memset(q, 0, sizeof q);
        for (int i = 1; i <= n; ++i) {
            if (h <= t && i - a + 1 > q[h]) h++;
            while (h <= t && s[q[t]][j] >= s[i][j]) t--;
            q[++t] = i;
            if (i - a + 1 >= 1) minn[i - a + 1][j] = s[q[h]][j];
        }
    }
    LL ans = 0;
    for (int i = 1; i <= n - a + 1; ++i) {
        int h = 0, t = -1;
        int hh = 0, tt = -1;
        memset(q, 0, sizeof q);
        memset(qq, 0, sizeof qq);
        for (int j = 1; j <= m; ++j) {
            if (h <= t && j - b + 1 > q[h]) h++;
            while (h <= t && maxx[i][q[t]] <= maxx[i][j]) t--;
            q[++t] = j;
            if (hh <= tt && j - b + 1 > qq[hh]) hh++;
            while (hh <= tt && minn[i][qq[tt]] >= minn[i][j]) tt--;
            qq[++tt] = j;
            if (j - b + 1 >= 1) {
                ans += (LL) maxx[i][q[h]] * minn[i][qq[hh]];
                ans %= mod;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```



## AcWing 3431. skew数

https://www.acwing.com/problem/content/3434/

在 skew binary 表示中，第 *k* 位的值 *x*[*k*] 表示 *x*[*k*]×(2(*k*+1)−1)，*k* 的取值从0开始。

每个位上的可能数字是 0 或 1，最后面一个非零位可以是 2，且不含前导零。

例如，10120(*skew*)=1×(25−1)+0×(24−1)+1×(23−1)+2×(22−1)+0×(21−1)=31+0+7+6+0=4。

前十个 skew 数是 0、1、2、10、11、12、20、100、101 以及 102。

给定若干 skew 数，请你输出它们的十进制形式。

#### 输入格式

输入包含多组测试数据。

每组数据占一行，包含一个 skew 数。

#### 输出格式

每行输出一个 skew 数的对应十进制形式。

#### 数据范围

保证结果不超过 2^31^−1

#### 输入样例：

```
10120
200000000000000000000000000000
10
1000000000000000000000000000000
11
100
11111000001110000101101102000
```

#### 输出样例：

```
44
2147483646
3
2147483647
4
7
1041110737
```

```c++
#include <bits/stdc++.h>

using namespace std;
string s;

int get(int x, int u) {
    int k = 1;
    while (u > 0) {
        k *= 2;
        u--;
    }
    k -= 1;
    return x * k;
}

int main() {
    while (cin >> s) {
        int ans = 0;
        for (int i = 0; i < s.size(); ++i) {
            if (s[i] == '1') {
                ans += get(s[i] - '0', s.size() - i);
            } else if (s[i] == '2') {
                ans += get(s[i] - '0', s.size() - i);
                break;
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```



## AcWing 3446. 整数奇偶排序

https://www.acwing.com/problem/content/3449/

输入 10 个整数，彼此以空格分隔。

重新排序以后输出(也按空格分隔)，要求: 

1. 先输出其中的奇数,并按从大到小排列； 
2. 然后输出其中的偶数,并按从小到大排列。

#### 输入格式

任意排序的 10 个整数，彼此以空格分隔。

#### 输出格式

按照要求排序后输出，整数之间由空格分隔。

#### 数据范围

输入整数取值范围 [0,100]

#### 输入样例：

```
4 7 3 13 11 12 0 47 34 98
```

#### 输出样例：

```
47 13 11 7 3 0 4 12 34 98
```

```c++
#include <bits/stdc++.h>

using namespace std;
vector<int> s1, s2;

int main() {
    int n = 10;
    while (n--) {
        int x;
        cin >> x;
        if (x % 2 == 0) s1.push_back(x);
        else s2.push_back(x);
    }
    sort(s1.begin(), s1.end());
    sort(s2.begin(), s2.end(), greater<>());
    for (auto ss: s2) cout << ss << " ";
    for (auto ss: s1) cout << ss << " ";
    return 0;
}
```



## AcWing 3508. 最长公共子串

https://www.acwing.com/problem/content/3511/

给定两个字符串，求这两个字符串的**不包含数字**的最长公共子串的长度。

#### 输入格式

共两行，每行一个由小写字母和数字构成的字符串。

#### 输出格式

一个整数，表示给定两个字符串的**不包含数字**的最长公共子串的长度。

如果不存在满足要求的非空公共子串，则输出 0

#### 数据范围

输入字符串的长度均不超过 10000

#### 输入样例：

```
ab123abccff
abcfacb123
```

#### 输出样例：

```
3
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 10010;
char str1[N], str2[N];
int f[N];
int alen, blen;
int maxv;

int main() {
    scanf("%s%s", str1 + 1, str2 + 1);
    alen = strlen(str1 + 1);
    blen = strlen(str2 + 1);
    for (int i = 1; i <= alen; i++) {
        for (int j = blen; j >= 1; j--) {
            if (str1[i] == str2[j] && isalpha(str1[i]) && isalpha(str2[j]))f[j] = f[j - 1] + 1;
            else f[j] = 0;
            maxv = max(maxv, f[j]);
        }
    }
    cout << maxv;
    return 0;
}
```



## AcWing 3543. 三元组

https://www.acwing.com/problem/content/3546/

给定一个长度为 *m* 的数组 *a*0,*a*1,…,*am*−1。

如果数组中有 *ai*+*aj*=*ak* 其中 *i*,*j*,*k* 大于等于 0 并且小于 *m*，则称 (*ai*,*aj*,*ak*) 为一个三元组。

现在，给定你数组 *a*，请你计算其中三元组的个数。

例如，当 *m*=2，数组 *a* 为 {0,0} 时，所有三元组为：

- (*a*0,*a*0,*a*0)
- (*a*0,*a*0,*a*1)
- (*a*0,*a*1,*a*0)
- (*a*0,*a*1,*a*1)
- (*a*1,*a*0,*a*0)
- (*a*1,*a*0,*a*1)
- (*a*1,*a*1,*a*0)
- (*a*1,*a*1,*a*1)

共计 8 个三元组。

#### 输入格式

第一行包含一个整数 *n*，表示共有 *n* 组测试数据。

每组数据第一行包含整数 *m*，表示数组长度。

第二行包含 *m* 个整数，表示数组。

#### 输出格式

每组数据输出一行一个答案，表示三元组个数。

#### 数据范围

1≤*n*≤10,
1≤*m*≤50，
数组元素取值范围 [0,100]。

#### 输入样例：

```
2
2
0 0
5
1 1 1 2 1
```

#### 输出样例：

```
8
16
```

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 66, M = 110;

int n, a[N], st[M];

int main() {
    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        memset(st, 0, sizeof st);
        memset(a, 0, sizeof a);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            st[a[i]]++;
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = i; j < n; ++j) {
                if (st[a[i] + a[j]]) {
                    ans += st[a[i] + a[j]];
                    if (i != j) ans += st[a[i] + a[j]];
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```



## AcWing 3576. 分组统计

https://www.acwing.com/problem/content/3579/

给定 *n* 个整数 *a*1,*a*2,…,*a**n*，这 *n* 个数对应 *m* 个不同的数值，从小到大依次为 *v*1,*v*2,…,*vm*。（*m*≤*n*）

这 *n* 个数被分到了 *k* 个小组中。*k* 个小组编号 1∼*k* 且每个小组都不为空。

现在，请你统计每个小组中，每个数值的数有多少个。

#### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。

每组数据第一行包含整数 *n*，表示整数个数。

第二行包含 *n* 个整数 *a*1,*a*2,…,*an*。

第三行包含 *n* 个整数，其中第 *i* 个整数表示 *ai* 所在的小组编号。

#### 输出格式

每组数据输出 *k* 行，第 *i* 行输出第 *i* 组的各数值统计情况，格式如下：

```
i={v_1=xx,v_2=xx,...,v_m=xx}
```

具体可参照样例。

#### 数据范围

1≤*T*≤10
1≤*k*≤*n*≤100,
1≤*ai*≤1000

#### 输入样例：

```
1
7
3 2 3 8 8 2 3
1 2 3 2 1 3 1
```

#### 输出样例：

```
1={2=0,3=2,8=1}
2={2=1,3=0,8=1}
3={2=1,3=1,8=0}
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1010, M = 110;
int st[M][N];
int a[M];

void solve(int t) {
    memset(st, 0, sizeof st);
    memset(a, 0, sizeof a);
    int n;
    cin >> n;
    set<int> s;
    for (int i = 0; i < n; ++i) {
        cin >> a[i];
        s.insert(a[i]);
    }
    int maxx = 0;
    for (int i = 0; i < n; ++i) {
        int x;
        cin >> x;
        maxx = max(maxx, x);
        st[x][a[i]]++;
    }
    for (int i = 1; i <= maxx; ++i) {
        printf("%d={", i);
        for (auto t: s) {
            printf("%d=%d", t, st[i][t]);
            if (s.upper_bound(t) != s.end()) {
                cout << ",";
            }
        }
        cout << "}" << endl;
    }
}

int main() {
    int t;
    cin >> t;
    while (t--)solve(t);
    return 0;
}
```



## AcWing 3425. 小白鼠排队

https://www.acwing.com/problem/content/3428/

*N* 只小白鼠，每只鼠头上戴着一顶有颜色的帽子。

现在称出每只白鼠的重量，要求按照白鼠重量从大到小的顺序输出它们头上帽子的颜色。

帽子的颜色用 `red`，`blue` 等字符串来表示。

不同的小白鼠可以戴相同颜色的帽子。

白鼠的重量用整数表示。

#### 输入格式

第一行为一个整数 *N*，表示小白鼠的数目。下面有 *N* 行，每行是一只白鼠的信息。第一个为不大于 100 的正整数，表示白鼠的重量；第二个为字符串，表示白鼠的帽子颜色，字符串长度不超过 10 个字符。

注意：白鼠的重量各不相同。

#### 输出格式

按照白鼠的重量从大到小的顺序输出白鼠的帽子颜色。

#### 数据范围

1≤*N*≤100

#### 输入样例：

```
3
30 red
50 blue
40 green
```

#### 输出样例：

```
blue
green
red
```

```c++
#include <bits/stdc++.h>

using namespace std;

struct node {
    int a;
    string s;

    bool operator<(const node &d) const {
        return a > d.a;
    }
} h[110];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> h[i].a >> h[i].s;
    sort(h, h + n);
    for (auto t: h) {
        if (t.s != "") cout << t.s << endl;
        else break;
    }
    return 0;
}
```

