# DFS

DFS：递归结束条件的选择+状态标记+递归后的恢复。是否使用状态标记，取决于是否允许修改给定数组的数值。

```c++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

## AcWing 842. 排列数字

https://www.acwing.com/problem/content/844/

给定一个整数 n，将数字 1∼n 排成一排，将会有很多种排列方法。

现在，请你按照字典序将所有的排列方法输出。

#### 输入格式

共一行，包含一个整数 n。

#### 输出格式

按字典序输出所有排列方案，每个方案占一行。

#### 数据范围

1≤n≤7

#### 输入样例：

```
3
```

#### 输出样例：

```
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

### 手敲 DFS

带 bool 数组

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 10;
int path[N];
bool st[N];
int n;

void dfs(int u) {

    if (u == n) {
        for (int i = 0; i < n; ++i) printf("%d ", path[i]);
        puts("");
        return 0;
    }

    for (int i = 1; i <= n; ++i) {
        if (!st[i]) {
            path[u] = i;
            st[i] = true;
            dfs(u + 1);
            st[i] = false;//恢复现场
        }
    }
}

int main() {

    cin >> n;

    dfs(0);

    return 0;
}
```

### y总 DFS

不带 bool 数组，state 比较难理解

```c++
#include <iostream>

using namespace std;

const int N = 10;

int n;
int path[N];

void dfs(int u, int state)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) printf("%d ", path[i]);
        puts("");

        return;
    }

    for (int i = 0; i < n; i ++ )
        if (!(state >> i & 1))
        {
            path[u] = i + 1;
            dfs(u + 1, state + (1 << i));
        }
}

int main()
{
    scanf("%d", &n);

    dfs(0, 0);

    return 0;
}
```



![在这里插入图片描述](%E5%BA%93/bcfc4b17081e49ad9edd24e247372d2f.png)



## AcWing 843. n-皇后问题

https://www.acwing.com/problem/content/845/

n−皇后问题是指将 n 个皇后放在 n×n 的国际象棋棋盘上，使得皇后不能相互攻击到，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

![1_597ec77c49-8-queens.png](%E5%BA%93/19_860e00c489-1_597ec77c49-8-queens.png)

现在给定整数 n，请你输出所有的满足条件的棋子摆法。

#### 输入格式

共一行，包含整数 n。

#### 输出格式

每个解决方案占 n 行，每行输出一个长度为 n 的字符串，用来表示完整的棋盘状态。

其中 `.` 表示某一个位置的方格状态为空，`Q` 表示某一个位置的方格上摆着皇后。

每个方案输出完成后，输出一个空行。

**注意：行末不能有多余空格。**

输出方案的顺序任意，只要不重复且没有遗漏即可。

#### 数据范围

1≤n≤9

#### 输入样例：

```
4
```

#### 输出样例：

```
.Q..
...Q
Q...
..Q.

..Q.
Q...
...Q
.Q..
```



### y总第一种搜索顺序

事先把问题进行抽线，从行列的角度枚举皇后的位置，进行条件检测

```c++
#include <iostream>

using namespace std;

const int N = 10;

int n;
char g[N][N];
bool col[N], dg[N * 2], udg[N * 2];

void dfs(int u)
{
    if (u == n)
    {
        for (int i = 0; i < n; i ++ ) puts(g[i]);
        puts("");
        return;
    }

    for (int i = 0; i < n; i ++ )// 确定了第 u 行，枚举第 i 列
        if (!col[i] && !dg[u + i] && !udg[n - u + i])
        {
            g[u][i] = 'Q';
            col[i] = dg[u + i] = udg[n - u + i] = true;
            dfs(u + 1);
            col[i] = dg[u + i] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < n; j ++ )
            g[i][j] = '.';

    dfs(0);

    return 0;
}
```

### y总第二种搜索顺序

不进行抽象，直接暴力枚举每个位置是皇后或者没有皇后的情况

```c++
#include <iostream>

using namespace std;

const int N = 10;

int n;
bool row[N], col[N], dg[N * 2], udg[N * 2];
char g[N][N];

void dfs(int x, int y, int s)
{
    if (s > n) return;
    if (y == n) y = 0, x ++ ;

    if (x == n)
    {
        if (s == n)
        {
            for (int i = 0; i < n; i ++ ) puts(g[i]);
            puts("");
        }
        return;
    }

    g[x][y] = '.';
    dfs(x, y + 1, s);

    if (!row[x] && !col[y] && !dg[x + y] && !udg[x - y + n])
    {
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = true;
        g[x][y] = 'Q';
        dfs(x, y + 1, s + 1);
        g[x][y] = '.';
        row[x] = col[y] = dg[x + y] = udg[x - y + n] = false;
    }
}

int main()
{
    cin >> n;

    dfs(0, 0, 0);

    return 0;
}
```

# BFS

> 讲解 BFS 非常好的一个博文：
>
> https://blog.csdn.net/weixin_72060925/article/details/128145585?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128145585%22%2C%22source%22%3A%22weixin_72060925%22%7D

所有边权都是 1 的时候才可以用 BFS 求最短路

一般情况下，用最短路算法求解最短路相关问题，而不是 BFS

```c++
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```



**为什么要用队列？**

BFS要保证的第一件事就是我们需要先走最近的，因此，队列的作用就是基于此的。

![在这里插入图片描述](%E5%BA%93/18247067a3dc4be4bba2e1cdd419d236.png)

![在这里插入图片描述](%E5%BA%93/119658ef1c7f4e4bb24f4c50f3afde74.png)

![在这里插入图片描述](%E5%BA%93/737970fb878645cf9ff27a57bc1bf47d.png)



**方向向量：**

![](%E5%BA%93/2ed6ee0c3be44d3c8a790287a1a63de0.png)

将上面的方向变化可以写成如下的数组

![](%E5%BA%93/11bfe693053f4ec08f187b1e2bba074d.png)

## AcWing 844. 走迷宫

https://www.acwing.com/problem/content/846/

给定一个 n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1) 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

数据保证 (1,1) 处和 (n,m) 处的数字为 00，且一定至少存在一条通路。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

#### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

#### 数据范围

1≤n,m≤100

#### 输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
8
```

### y总 STL

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 110;

int n, m;// 二维整数数组，用来表示一个迷宫
int g[N][N], d[N][N];// g 数组表示障碍物和可以走的地方  d 数组表示该点到出发点的距离

int bfs()
{
    queue<PII> q;

    memset(d, -1, sizeof d);
    d[0][0] = 0;
    q.push({0, 0});

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        for (int i = 0; i < 4; i ++ )
        {
            int x = t.first + dx[i], y = t.second + dy[i];

            if (x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1)
            {
                d[x][y] = d[t.first][t.second] + 1;
                q.push({x, y});
            }
        }
    }

    return d[n - 1][m - 1];
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i ++ )
        for (int j = 0; j < m; j ++ )
            cin >> g[i][j];

    cout << bfs() << endl;

    return 0;
}
```



![在这里插入图片描述](%E5%BA%93/94938a3f9ef24a1888e36a35eb69eb95.png)



### 手写迷宫求解

整理了格式，方便看

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 110;
int g[N][N],d[N][N];
int n,m;

int bfs(){
    
    queue<pair<int,int>> q;
    q.push({0,0});
    
    
    memset(d,-1,sizeof d);
    d[0][0]=0;
    
    int dx[4]={1,-1,0,0};
    int dy[4]={0,0,1,-1};
    
    while(q.size()){
        
        auto t = q.front();
        q.pop();
        
        for(int i=0;i<4;++i){
            
            int x=t.first+dx[i];
            int y=t.second+dy[i];
            
            if(x>=0 && y>=0 && x<n && y<m && g[x][y]==0 && d[x][y]==-1){
                d[x][y]=d[t.first][t.second]+1;
                q.push({x,y});
            }
            
        }
    }
    
    return d[n-1][m-1];
    
}

int main(){
    cin>>n>>m;
    for(int i=0;i<n;++i)
        for(int j=0;j<m;++j)
            scanf("%d",&g[i][j]);
            
    cout<<bfs()<<endl;

    return 0;
}
```

## AcWing 845.八数码

https://www.acwing.com/problem/content/847/

在一个 3×3 的网格中，1∼8 这 8 个数字和一个 `x` 恰好不重不漏地分布在这 3×3 的网格中。

例如：

```
1 2 3
x 4 6
7 5 8
```

在游戏过程中，可以把 `x` 与其上、下、左、右四个方向之一的数字交换（如果存在）。

我们的目的是通过交换，使得网格变为如下排列（称为正确排列）：

```
1 2 3
4 5 6
7 8 x
```

例如，示例中图形就可以通过让 `x` 先后与右、下、右三个方向的数字交换成功得到正确排列。

交换过程如下：

```
1 2 3   1 2 3   1 2 3   1 2 3
x 4 6   4 x 6   4 5 6   4 5 6
7 5 8   7 5 8   7 x 8   7 8 x
```

现在，给你一个初始网格，请你求出得到正确排列至少需要进行多少次交换。

#### 输入格式

输入占一行，将 3×3 的初始网格描绘出来。

例如，如果初始网格如下所示：

```
1 2 3 
x 4 6 
7 5 8 
```

则输入为：`1 2 3 x 4 6 7 5 8`

#### 输出格式

输出占一行，包含一个整数，表示最少交换次数。

如果不存在解决方案，则输出 −1。

#### 输入样例：

```
2 3 4 1 5 x 7 6 8
```

#### 输出样例

```
19
```

### y总 STL

```c++
#include <iostream>
#include <algorithm>
#include <unordered_map>
#include <queue>

using namespace std;

int bfs(string state)
{
    queue<string> q;
    unordered_map<string, int> d;// 用 d 表示距离

    q.push(state);
    d[state] = 0;

    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

    string end = "12345678x";
    while (q.size())
    {
        auto t = q.front();
        q.pop();

        if (t == end) return d[t];

        int distance = d[t];
        int k = t.find('x');
        int x = k / 3, y = k % 3; // x y == i j
        for (int i = 0; i < 4; i ++ )
        {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < 3 && b >= 0 && b < 3)
            {
                swap(t[a * 3 + b], t[k]);
                if (!d.count(t))
                {
                    d[t] = distance + 1;
                    q.push(t);
                }
                swap(t[a * 3 + b], t[k]);
            }
        }
    }

    return -1;
}

int main()
{
    char s[2];

    string state;
    for (int i = 0; i < 9; i ++ )
    {
        cin >> s;
        state += *s;
    }

    cout << bfs(state) << endl;

    return 0;
}
```



**针对代码的注解：**

为什么这里要swap(t[a * 3 + b], t[k]);两次呢？因为这个for循环是遍历t的上下左右四个点，swap一下意味着xy和ab两个点换了位置，t现在是ab。判断完ab之后还要从xy出发去遍历其他三个点，所以要还原一下。

为什么要用d.count(t)是不是0来判断这个点是否为有效点呢？因为我们要找到最短距离，要是不为零的话意味着用之前的换法已经换到这个状态过了，用现在这个状态接着换还如接着以前的状态换，以前的步数还少一些，而且这样才能把所有可能换到的状态全部枚举一遍。



**注意：在蓝桥杯里需要加上这两个头文件以及文件命名空间才能使用。**

有时用不了unordered_map或者unordered_set时，加上

```c++
#include<tr1/unordered_set>
#include<tr1/unordered_map>
using namespace std::tr1;
```



## C++ string find

> https://blog.csdn.net/Hao_ge_666/article/details/90695409



```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
	string a;
	string b;
	
	getline(cin,a);
	getline(cin,b);
	
	int post=b.find(a);
	
	cout<<post<<endl;
	return 0;
}
```

首先定义两个string类型的变量a和b，getline（）是string中的一个方法，从键盘读取一行。

b.find(a);这句代码的意思就是从b字符串中查找a字符串。

公式可以理解为————>母字符串.find(子字符串)；

返回值的类型为int类型，返回的是字符串的下标。



```c++
#include<iostream>
#include<string>
using namespace std;
int main()
{
 
 	string st1("babbabab");
    cout << st1.find('a') << endl;//1   由原型知，若省略第2个参数，则默认从位置0（即第1个字符）起开始查找
    cout << st1.find('a', 0) << endl;//1
    cout << st1.find('a', 1) << endl;//1   
    cout << st1.find('a', 2) << endl;//4
 
    return 0；
}
```

st1.find('a',1);后面的数字代表从什么位置开始查找。如果不加，默认从位置0（即第一个字符）开始查找。

如果你要查找的字符不是单个字母，用法和查找单个字母一样，它会返回第一个字符的位置。



**在这里说一下，如果计算机没有找到，就会返回npos！！**

```c++
if(b.find(a)==string::npos)
{
    cout<<"no find"<<endl;
}
```



## C++ string rfind

rfind()就是倒着查找。。。。

后面的数字代表着就是从倒数第几个开始查找。



## unordered_map用法详解

> http://c.biancheng.net/view/7231.html



- unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。
- key值应该是唯一的，key和value的数据类型可以不相同。
- unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。
- unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低。
- 可以使用[]操作符来访问key值对应的value值。



**简单使用：**

```c++
std::unordered_map<std::string, std::int> umap; //定义

umap.insert(Map::value_type("test", 1));//增加

//根据key删除,如果没找到n=0
auto n = umap.erase("test")   //删除

//没找到返回 end() 迭代器
auto it = umap.find(key) //改
if(it != umap.end()) 
    it->second = new_value; 

//map中查找x是否存在
umap.find(x) != map.end()//查
//或者
umap.count(x) != 0
```



c++中 map 与 unordered_map 的区别：

- **运行效率方面**：unordered_map最高，而map效率较低但 提供了稳定效率和有序的序列。
- **占用内存方面**：map内存占用略低，unordered_map内存占用略高,而且是线性成比例的。



内部实现机理：

- map： map内部实现了一个红黑树，该结构具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素，因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了map的效率。
- unordered_map: unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的



优点、缺点、使用场景：

map

**优点**：**有序性**，这是map结构最大的优点，其元素的有序性在很多应用中都会简化很多的操作。**红黑树**，内部实现一个红黑书使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率非常的高。
**缺点**：空间占用率高，因为map内部实现了红黑树，虽然提高了运行效率，但是因为每一个节点都需要额外保存父节点，孩子节点以及红/黑性质，使得每一个节点都占用大量的空间
**适用处**：对于那些有顺序要求的问题，用map会更高效一些。

unordered_map

**优点**：内部实现了哈希表，因此其查找速度是常量级别的。
**缺点**：哈希表的建立比较耗费时间
**适用处**：对于查找问题，unordered_map会更加高效一些，因此遇到查找问题，常会考虑一下用unordered_map



<u>对于unordered_map或者unordered_set容器，其遍历顺序与创建该容器时输入元素的顺序是不一定一致的，遍历是按照哈希表从前往后依次遍历的</u>



map的基本操作如下

```c++
#include<iostream> 
#include<map>
#include<string>
 
using namespace std;
 
int main()
{
	// 构造函数
	map<string, int> dict;
	
	// 插入数据的三种方式
	dict.insert(pair<string,int>("apple",2));
	dict.insert(map<string, int>::value_type("orange",3));
	dict["banana"] = 6;
 
	// 判断是否有元素
	if(dict.empty())
		cout<<"该字典无元素"<<endl;
	else
		cout<<"该字典共有"<<dict.size()<<"个元素"<<endl;
 
	// 遍历
	map<string, int>::iterator iter;
	for(iter=dict.begin();iter!=dict.end();iter++)
		cout<<iter->first<<ends<<iter->second<<endl;
 
	// 查找
	if((iter=dict.find("banana"))!=dict.end()) //  返回一个迭代器指向键值为key的元素，如果没找到就返回end()
		cout<<"已找到banana,其value为"<<iter->second<<"."<<endl;
	else
		cout<<"未找到banana."<<endl;
 
	if(dict.count("watermelon")==0) // 返回键值等于key的元素的个数
		cout<<"watermelon不存在"<<endl;
	else
		cout<<"watermelon存在"<<endl;
	
	pair<map<string, int>::iterator, map<string, int>::iterator> ret;
	ret = dict.equal_range("banana"); // 查找键值等于 key 的元素区间为[start,end)，指示范围的两个迭代器以 pair 返回
	cout<<ret.first->first<<ends<<ret.first->second<<endl;
	cout<<ret.second->first<<ends<<ret.second->second<<endl;
 
	iter = dict.lower_bound("boluo"); // 返回一个迭代器，指向键值>=key的第一个元素。
	cout<<iter->first<<endl;
	iter = dict.upper_bound("boluo"); // 返回一个迭代器，指向值键值>key的第一个元素。
	cout<<iter->first<<endl;
	return 0;
```

```c++
#include<string>    
#include<iostream>  
#include<unordered_map>
using namespace std;  
  
int main()
{
	unordered_map<string, int>  dict; // 声明unordered_map对象
	
	// 插入数据的三种方式
	dict.insert(pair<string,int>("apple",2));
	dict.insert(unordered_map<string, int>::value_type("orange",3));
	dict["banana"] = 6;
	
	// 判断是否有元素
	if(dict.empty())
		cout<<"该字典无元素"<<endl;
	else
		cout<<"该字典共有"<<dict.size()<<"个元素"<<endl;
	
	// 遍历
	unordered_map<string, int>::iterator iter;
	for(iter=dict.begin();iter!=dict.end();iter++)
		cout<<iter->first<<ends<<iter->second<<endl;
	
	// 查找
	if(dict.count("boluo")==0)
		cout<<"can't find boluo!"<<endl;
	else
		cout<<"find boluo!"<<endl;
	
	if((iter=dict.find("banana"))!=dict.end())
		cout<<"banana="<<iter->second<<endl;
	else
		cout<<"can't find boluo!"<<endl;
	
	return 0;
}
```



# 树与图的存储

树与图的存储
树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储

1. 邻接矩阵：g[a][b] 存储边a->b

2. 使用邻接表存储图：

    ```c++
    // 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
    int h[N], e[N], ne[N], idx;
    
    // 添加一条边a->b
    void add(int a, int b)
    {
        e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
    }
    
    // 初始化
    idx = 0;
    memset(h, -1, sizeof h);
    ```



# 树与图的遍历

时间复杂度 O(n+m)，n 表示点数，m 表示边数

## 深度优先遍历

> 模板题 AcWing 846. 树的重心
>
> https://www.acwing.com/problem/content/848/

```c++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```





<img src="%E5%BA%93/605c689bb7b24791908e1b2e8aacc540.png" alt="在这里插入图片描述" style="zoom:50%;" /><img src="%E5%BA%93/cb732c9b58954ba5a24b48dedbd7f9c8.png" alt="在这里插入图片描述" style="zoom:50%;" />

先走A，然后到B，到了B有三种情况，意味着这条路还没走完，那我就接着走，从B走到E，走到E之后没路了。那我就回溯到B,为什么呢？

因为我原本走到B的时候就有三种情况，但是刚刚只走了一种情况，因此我要回到B再去尝试第二条路，于是我们就从E回到B，然后从B去F。到了F，又没路了，那我们就回到B走第三种情况，从B到G。这样我们就走完了从A->B的三种情况。又因为在A处其实还有三种情况，因此我们走完B的三种情况后，回到A,去走除了从A->B的第二种情况，即A->C。由此以往。

简而言之，就是我们一头扎进去，撞了南墙，我就退一步，但是决不放弃，在原基础上做出局部的改变去尝试第二条路，直到所有的情况我都试了，实在没有其他情况了，那我就回到A，从头出发，再做选择，再一头扎进去，直到成功。



## AcWing 846. 树的重心

https://www.acwing.com/problem/content/848/

给定一颗树，树中包含 n 个结点（编号 1∼n）和 n−1 条无向边。

请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。

重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。

#### 输入格式

第一行包含整数 n，表示树的结点数。

接下来 n−1 行，每行包含两个整数 a 和 b，表示点 a 和点 b 之间存在一条边。

#### 输出格式

输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。

#### 数据范围

1≤n≤105

#### 输入样例

```
9
1 2
1 7
1 4
2 8
2 5
4 3
3 9
4 6
```

#### 输出样例：

```
4
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
const int M = 2 * N;
int h[N], e[M], ne[M], idx;
bool st[N];
int ans = N;
int n;

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dfs(int u) {
    st[u] = true;

    int sum = 1, res = 0;// sum返回这个树的结点数量， res返回最大子树的结点数量
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            int s = dfs(j);
            res = max(res, s);
            sum += s;
        }
    }
    res = max(n - sum, res);
    ans = min(ans, res);
    return sum;
}

int main() {
    //使用链表的时候要将头结点赋为 -1
    memset(h, -1, sizeof(h));

    cin >> n;
    int a, b;
    for (int i = 0; i < n - 1; i++) {
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }

    dfs(1);

    printf("%d", ans);

    return 0;
}
```



## 宽度优先遍历

> 模板题 AcWing 847. 图中点的层次
>
> https://www.acwing.com/problem/content/849/

```c++
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```



BFS即Breadth First Search，即广度优先搜索。如果说DFS是一条路走到黑的话，BFS就完全相反了。BFS会在每个岔路口都各向前走一步。因此其遍历顺序如下图所示：

<img src="%E5%BA%93/56d032278b434d27a32e7e5ce60dabe6.png" alt="在这里插入图片描述" style="zoom:67%;" />

我们发现每次搜索的位置都是距离当前节点最近的点。因此，BFS是具有最短路的性质的。为什么呢？这就类似于我们后面要学习的贪心策略。这里简单地介绍一下贪心，假设我们可以做出12次选择。我们想得到一个最好的方案。那么我们可以在第一次选择的时候，做出当前最好的选择，在第二次选择的时候，再做出那时候最好的选择，由此积累。当我们在每次的选择面前，都做到了当前最好的选择，那么我们就可以由局部最优推出整体最优。

这里也是类似的，我们可以在每次出发的时候，走到离自己最近的点，由此我们每次都保证走最近的，那从局部最近推整体最近，必有一条路是整体最近的。所以我们可以利用BFS做最短路问题。



**另作解释有：**

<img src="%E5%BA%93/6bc354a235ee496e9a5eb4fe814295f6.png" alt="在这里插入图片描述" style="zoom: 50%;" />

上图中的遍历顺序就是以A为起点开始的广度优先搜索。先遍历距离A点最近的距离，然后再依次向外拓展。



## AcWing 847. 图中点的层次

https://www.acwing.com/problem/content/849/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环。

所有边的长度都是 1，点的编号为 1∼n。

请你求出 1 号点到 n 号点的最短距离，如果从 1 号点无法走到 n 号点，输出 −1。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 a 和 b，表示存在一条从 a 走到 b 的长度为 11 的边。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

#### 数据范围

1≤n,m≤105

#### 输入样例：

```
4 5
1 2
2 3
3 4
1 3
1 4
```

#### 输出样例：

```
1
```

### y总 STL

```c++
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

int bfs()
{
    memset(d, -1, sizeof d);

    queue<int> q;
    d[1] = 0;
    q.push(1);

    while (q.size())
    {
        int t = q.front();
        q.pop();

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (d[j] == -1)
            {
                d[j] = d[t] + 1;
                q.push(j);
            }
        }
    }

    return d[n];
}

int main()
{
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; i ++ )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    cout << bfs() << endl;

    return 0;
}
```

### 手写模拟队列

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 100010;

int n, m;
int h[N], e[N], ne[N], idx;
int d[N];
int q[N];

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int bfs() {
    int hh = 0, tt = 0;
    q[hh] = 1;

    memset(d, -1, sizeof d);
    d[1] = 0;

    while (hh <= tt) {
        int t = q[hh++];
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (d[j] == -1) {
                d[j] = d[t] + 1;
                q[++tt] = j;
            }
        }
    }
    return d[n];
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);

    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        add(a, b);
    }

    cout << bfs() << endl;
    return 0;
}
```



## 拓扑排序

**注意：拓扑排序仅对有向无环图而言，有向无环图也叫做拓扑图**

> 模板题 AcWing 848. 有向图的拓扑序列
>
> https://www.acwing.com/problem/content/850/

时间复杂度 O(n+m)，n 表示点数，m 表示边数

```c++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```



> **图的BFS与拓扑序列**
>
> https://blog.csdn.net/weixin_72060925/article/details/128163868?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22128163868%22%2C%22source%22%3A%22weixin_72060925%22%7D



**引入：**

在生活中，我们经常会遇到类似一下的场景。

<img src="%E5%BA%93/2bb3caf8ae1a4365afab61594fbda16d.png" alt="在这里插入图片描述" style="zoom:50%;" />

我们想要去上学的话，我们必须完成前面的一系列任务。不起床，怎么吃饭呢？不穿衣服，怎么上学呢？（当然，正常人的话）
那么我们有一下两条路可走：

- 起床–》穿鞋–》穿衣服–》吃饭–》背书包–》上学
- 起床–》穿衣服–》穿鞋–》吃饭–》背书包–》上学

这两条路都可以走，所以这两条路线都是正确的，这就是**拓扑序列**。



**什么是拓扑序列？**

<img src="%E5%BA%93/63d7d5728c5a478d9d34d1077cde883d.png" alt="在这里插入图片描述" style="zoom: 50%;" />

简单的说，拓扑序列就是有顺序地去访问图中的点。按照我们刚才的例子，我们发现，当一个点没有被指向的时候，这个点就相当于没有限制的，那么我们就可以直接访问，类似于A和E。那么被指向的路线个数称作：**入度**。从该点指出的路线个数叫做：**出度**。

比如：A点的入度为0,出度为1。D点的入度为2，出度为3。

**所以，我们只有当某个点的入度是0的时候，才能够访问。**

那么上图中，我们可以直接访问A和E，但是先访问谁都可以，因此拓扑序列并不唯一。例如上图中，我们可以写出一条可能的拓扑序列：

<img src="%E5%BA%93/6fbcc3a3314343b1bd62bc8b04707172.png" alt="在这里插入图片描述" style="zoom: 67%;" />



**什么情况下没有拓扑序列呢？**

<img src="%E5%BA%93/d765c4bd10e54130a0b5e39e48c0d0ca.png" alt="在这里插入图片描述" style="zoom:33%;" />

当一个图中出现这种环的时候，我们是无法写出拓扑序列的，因为图中没有度为0的点，因此我们无从下手。



**算法设计：**

很明显，我们想要写出一个拓扑序列，就要从一个入度为0的点开始，当我们访问结束后，就可以删除这个点以及和这个点相关的边，然后再找下一个入度为0的点。即：**逐个击破！**

部分过程如下图所示：

![在这里插入图片描述](%E5%BA%93/a768c9964c4246398853aeaf94d60427.png)

那么我们的思路就是先找到所有入度为0的点，然后通过BFS的逻辑，扫描该入度为零的点周围相连的点。为什么这样做呢？我们的目的就是通过BFS的扫描去删除该点所连的边。就如同上图中的D点。

我们通过D点，去扫描离他最近的CFG点，然后删除DC边，DF边，DG边。当删除以后，我们发现，C点从入度为1变成了入度为0，也就是说这个点可以访问了，那么我们让这个点进队。最后，我们发现这个队中的数据就是拓扑序列。具体的例子可以可以看图中左侧的红色字母序列。



```c++
#include<iostream>
#include<cstring>
using namespace std;
const int N=1e5+10,M=3*N;
int h[N],e[M],ne[M],q[N],d[N],idx;
int n,m;
void add(int x,int y)
{
    e[idx]=y,ne[idx]=h[x],h[x]=idx++;
}
bool topsort()
{
    int hh=0,tt=-1;
    for(int i=1;i<=n;i++)if(!d[i])q[++tt]=i;
    while(hh<=tt)
    {
        int front=q[hh++];
        for(int i=h[front];i!=-1;i=ne[i])
        {
            if(--d[e[i]]==0)q[++tt]=e[i];
        }
    }
    int size=tt+1;
    return size==n;
}
int main()
{
    memset(h,-1,sizeof h);
    scanf("%d %d",&n,&m);
    for(int i=0;i<m;i++)
    {
        int x,y;
        scanf("%d %d",&x,&y);
        add(x,y),d[y]++;
    }
    if(!topsort())puts("-1");
    else
    {
        for(int i=0;i<n;i++)printf("%d ",q[i]);
    }
    
}
```



![在这里插入图片描述](%E5%BA%93/5cc4f33bbeac45e29c405d218c2e4a14.png)

**STL 中的队列行不行？**

这里不能使用STL中的队列，因为STL中的队列，会把队头真的删掉，但是我们知道，队列中的数据存储的是我们的答案，我们只能通过模拟队列的方式，伪删头部，即通过指针的偏移来删除。这样做的话，我们的答案是会被保留下来的。

**为什么这里的BFS不用标记？**

我们这里只是采用了BFS的思想，但不是真正的BFS，所以我们会发现如果一个点的入度大于1的话，那么这个点是会被重复遍历的。所以，并不是BFS。我们只是通过一个入度为0的点，去扫描与他相连的最近的点，从而达到删除边的效果，类似于BFS。

**如何判断是否成功？**

如果一个图是拓扑排序的话，那么我们能利用逐个击破的思路访问到每一个点，也就是说我们的每一个点都会入队。我们的尾部指针指向的是当前的尾部元素的下标。但是我们的头是从下标为0的点开始的。所以我们的元素个数等于尾部指针+1。比如，尾指针指向1，但是我们的元素有q[0],q[1]，此时我们的个数是2。



## AcWing 848. 有向图的拓扑序列

给定一个 n 个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。

请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。

若一个由图中所有点构成的序列 AA 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，则称 A 是该图的一个拓扑序列。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)

#### 输出格式

共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。

否则输出 −1。

#### 数据范围

1≤n,m≤105

#### 输入样例：

```
3 3
1 2
2 3
1 3
```

#### 输出样例：

```
1 2 3
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 100010;

int h[N], e[N], q[N], ne[N], idx, n, m;
int d[N];

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

bool topsort() {
    int hh = 0, tt = -1;

    for (int i = 1; i <= n; ++i) {
        if (!d[i]) q[++tt] = i;
    }

    while (hh <= tt) {
        int t = q[hh++];

        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            d[j]--;
            if (d[j] == 0) q[++tt] = j;
        }
    }
    return tt == n - 1;
}

int main() {
    cin >> n >> m;

	memset(h, -1, sizeof h);

    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b]++;
    }

    if (topsort()) {
        for (int i = 0; i < n; ++i) printf("%d ", q[i]);
    } else puts("-1");

    return 0;
}
```



# 最短路问题

![image-20221217131147811](%E5%BA%93/image-20221217131147811.png)

所谓的稠密和稀疏是指边相较于点的数量而言的——稠密图 m 和 n^2 是一个级别的， 稀疏图 m 和 n 是一个级别的

最短路问题的考察要点：如何将问题抽象成为最短路问题，如何抽象点和边，建图完成后如何依靠模板做题。



**朴素dijkstra算法解决重边问题的方法：**

```c++
g[a][b] = min(g[a][b], c);
```

**堆优化版dijkstra算法解决重边问题的方法：**
		因为是小根堆，所以最短距离肯定会出现在最前面，所以除了在堆顶的元素，底下那些元素都算是冗余备份元素，可以舍弃掉了，直接 continue 就行

**Bellman_ford算法解决重边问题的方法：**
		把每条边都遍历一遍



dijkstra 用邻接矩阵**存的时候还需要处理下重边**，如果用邻接表存就不用处理了
原因是：矩阵1个边只能有1个值，类似 g[i] [j]=123,所以要处理一下，保证存的是最小值，但邻接表重边也可以存多次，**在算法里保证最小就可以了**



## 朴素dijkstra算法

时间复杂是 O(n^2+m)，n 表示点数，m 表示边数

```c++
int g[N][N];  // 存储每条边
int dist[N];  // 存储1号点到每个点的最短距离
bool st[N];   // 存储每个点的最短路是否已经确定

// 求1号点到n号点的最短路，如果不存在则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        // 用t更新其他点的距离
        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



## AcWing 849. Dijkstra求最短路 I

https://www.acwing.com/problem/content/851/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z 表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

#### 数据范围

1≤n≤500
1≤m≤105
图中涉及边长均不超过10000。

#### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

#### 输出样例：

```
3
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510;

int n, m;
int g[N][N];
int dist[N];
bool st[N];

int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    for (int i = 0; i < n - 1; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        for (int j = 1; j <= n; j ++ )
            dist[j] = min(dist[j], dist[t] + g[t][j]);// 更新所有与 t 邻接的 j 点到源点的距离

        st[t] = true;
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(g, 0x3f, sizeof g);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);

        g[a][b] = min(g[a][b], c);
    }

    printf("%d\n", dijkstra());

    return 0;
}
```

有人说外部循环 n-1 次是因为第一个节点不需要被再次考虑——这是错的。

算法模板中第一个节点实际上被再次遍历了，同时初始化了下一层的所有节点距离——因为 st[1] 并没有被设置。这里减 1 是因为最后一个节点没有被考虑——最后一个点只更新了距离并且已经确定是最短距离，所以不需要再考虑加入 st[n] 的操作。



注意：这段代码非常巧妙

```c++
int t = -1;
for (int j = 1; j <= n; j ++ )
    if (!st[j] && (t == -1 || dist[t] > dist[j]))
        t = j;
```

利用这段代码在未加入 st[n] 的点中寻找到源点最短的点



## 堆优化版dijkstra算法

时间复杂度 O(mlogn)，n 表示点数，m 表示边数

```c++
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储节点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```

![image-20221225192017949](%E5%BA%93/image-20221225192017949.png)



## AcWing 850. Dijkstra求最短路 II

https://www.acwing.com/problem/content/852/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为非负值。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z 表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 −1。

#### 数据范围

1≤n,m≤1.5×105
图中涉及边长均不小于 00，且不超过 10000
数据保证：如果最短路存在，则最短路的长度不超过 109

#### 输入样例：

```
3 3
1 2 2
2 3 1
1 3 4
```

#### 输出样例：

```
3
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

typedef pair<int, int> PII;

const int N = 1e6 + 10;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int dijkstra(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});// first 是距离    second 是编号
    //priority_queue 是按照pair的第一个进行排序的
    //因为是小根堆，所以最短距离肯定会出现在最前面，所以除了在堆顶的元素，底下那些元素都算是冗余备份元素，可以舍弃掉了，直接continue就行

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[ver] + w[i])//这一步将选出重边中权值最小的边
            {
                dist[j] = dist[ver] + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    cout << dijkstra() << endl;

    return 0;
}
```



### priority_queue常见用法详解

priority_queue又称为优先队列，其底层是用堆来进行实现的。

priority_queue可以解决一些贪心问题，也可以对Dijkstra算法进行优化(因为优先队列的本质是堆)
有一点需要注意的是，使用pop()函数前，必须用empty()判断优先队列是否为空,否则可能因为队空而出现错误。

在优先队列中，队首元素一定是当前队列中优先级最高的那一个(默认是大根堆)。也可以规定数字越小的优先级越大。

可以在任何时候往优先队列里面加入(push)元素。而优先队列底层的数据结构堆(heap)会随时调整结构，使得每次的队首元素都是优先级最大的。



**priority_queue容器内元素的访问：**

和队列不一样的是，优先队列没有front()和back()函数，而只能通过top()函数来访问队首元素(也可以称为堆顶元素)，也就是优先级最高的元素。



**priority_queue常用函数：**

- push(x)将令x入队，时间复杂度为O(logN)，其中N为当前优先队列中的元素个数
- top()可以获得队首元素(即堆顶元素)，时间复杂度为O(1)
- pop()令队首元素(即堆顶元素)出队，时间复杂度为O(logN)，其中N为当前优先队列中的元素个数
- empty()检测优先队列是否为空，返回true则为空，返回false则为非空。时间复杂度为O(1)
- size()返回优先队列内元素的个数，时间复杂度为O(1)



**priority_queue内元素优先级的设置：**

如何定义优先级队列内元素的优先级是运用好优先队列的关键，下面分别介绍基本数据类型(例如 int 、double、char)与结构体类型的优先级设置方法

- **基本数据类型的优先级设置**

    此处指的基本数据类型就是int型、double 型、char型等可以直接使用的数据类型，优先队列对它们的优先级设置一般是数字大的优先级越高， 因此队首元索就是优先队列内元素最大的那个(如果char 型，则是字典序最大的)。

    对基本数据类型来说，下面两种优先队列的定义是等价的(以int型为例，注意最后两个>之间有一个空格)：

    ```c++
    priority_queue<int> q;
    priority_queue<int , vector<int> , less<int> > q;
    ```

    可以发现，第二种定义方式的尖括号内多出了两个参数：一个是vector，另一个是less。其中vector (也就是第二个参数)填写的是来承载底层数据结构堆(heap)的容器，如果第一个参数是double型或char型，则此处只需要填写vector-或vector;而第三个参数**less-则是对第一个参数的比较类， less表示数字大的优先级越大，而greater表示数字小的优先级越大。**

    因此，如果想让优先队列总是把最小的元素放在队首，只需进行如下定义：

    ```c++
    priority_queue<int, vector<int>, greater<int> >a;
    ```

    事实上，即便是基本数据类型，也可以使用下面讲解的结构体的优先级设置方法，只不过第三个参数的写法不太一样。

- **结构体的优先级设置**

    以一个水果的名称和价格为例：

    ```c++
    struct fruit
    {
    	string name;
    	int price;
    };
    ```

    现在希望按水果的价格高的为优先级高，就需要重载( overload )小于号 " < "。重载是指对已有的运算符进行重新定义。也就是说，可以改变小于号的功能(例如把它重载为大于号的功能)

    ```c++
    struct fruit
    {
    	string name;
    	int price;
    	friend bool operator < (fruit f1,fruit f2)
    	{
    		return f1.peice<f2.price;
    	}
    };
    ```

    同理，如果想要以价格低的水果为优先级高，那么只需要把 return 中的小于号改为大于号即可。

    ```c++
    struct fruit
    {
    	string name;
    	int price;
    	friend bool operator < (fruit f1,fruit f2)
    	{
    		return f1.price > f2.price;
    	}
    };
    ```



## Bellman-Ford算法

Bellman-Ford 算法可以解决限制边数的最短路径，而 spfa 算法虽然优化了时间复杂度，但是不能解决限制变数的最短路问题

![1.png](%E5%BA%93/652_fa97a4d6a4-1.png)

时间复杂度 O(nm)，n 表示点数，m 表示边数

注意在模板题中需要对下面的模板稍作修改，加上备份数组，详情见模板题

https://www.acwing.com/problem/content/855/

```c++
int n, m;       // n表示点数，m表示边数
int dist[N];        // dist[x]存储1到x的最短路距离

struct Edge     // 边，a表示出点，b表示入点，w表示边的权重
{
    int a, b, w;
}edges[M];

// 求1到n的最短路距离，如果无法从1走到n，则返回-1。
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    // 如果第n次迭代仍然会松弛三角不等式，就说明存在一条长度是n+1的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在负权回路。
    for (int i = 0; i < n; i ++ )
    {
        for (int j = 0; j < m; j ++ )
        {
            int a = edges[j].a, b = edges[j].b, w = edges[j].w;
            if (dist[b] > dist[a] + w)
                dist[b] = dist[a] + w;
        }
    }

    if (dist[n] > 0x3f3f3f3f / 2) return -1;
    return dist[n];
}
```



## AcWing 853. 有边数限制的最短路

https://www.acwing.com/problem/content/855/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出从 1 号点到 n 号点的最多经过 k 条边的最短距离，如果无法从 1 号点走到 n 号点，输出 `impossible`。

**注意：图中可能存在负权回路**

#### 输入格式

第一行包含三个整数 n,m,k

接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

点的编号为 1∼n

#### 输出格式

输出一个整数，表示从 1 号点到 n 号点的最多经过 k 条边的最短距离。

如果不存在满足条件的路径，则输出 `impossible`。

#### 数据范围

1≤n,k≤500
1≤m≤10000
1≤x,y≤n
任意边长的绝对值不超过 10000

#### 输入样例：

```
3 3 1
1 2 1
2 3 1
1 3 3
```

#### 输出样例：

```
3
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 10010;

struct Edge
{
    int a, b, c;
}edges[M];

int n, m, k;
int dist[N];
int last[N];

void bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);

    dist[1] = 0;
    for (int i = 0; i < k; i ++ )
    {
        memcpy(last, dist, sizeof dist);
        for (int j = 0; j < m; j ++ )
        {
            auto e = edges[j];
            dist[e.b] = min(dist[e.b], last[e.a] + e.c);
        }
    }
}

int main()
{
    scanf("%d%d%d", &n, &m, &k);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        edges[i] = {a, b, c};
    }

    bellman_ford();

    if (dist[n] > 0x3f3f3f3f / 2) puts("impossible");
    else printf("%d\n", dist[n]);

    return 0;
}
```



> 写得比较全的一个题解：
>
> https://www.acwing.com/solution/content/14088/
>
> 不过给出的代码在加强数据之后无法 AC，需要加入 if 判断条件



**为什么需要 last[] 数组：**

在限制边数为 k 的情况下，需要 last[] 数组，因为会出现串联的情况；若只是在带负权的图中搜索最短路则不需要 last[] 数组

为了避免如下的串联情况， 在边数限制为一条的情况下，节点3的距离应该是3，但是由于串联情况，利用本轮更新的节点2更新了节点3的距离，所以现在节点3的距离是2

![2.PNG](%E5%BA%93/652_8fb5d1dca4-2.png)

正确做法是用上轮节点2更新的距离--无穷大，来更新节点3， 再取最小值，所以节点3离起点的距离是3

![3.PNG](%E5%BA%93/652_bf119614a4-3.png)



**为什么是dist[n]>0x3f3f3f3f/2， 而不是dist[n]>0x3f3f3f3f**

5号节点距离起点的距离是无穷大，利用5号节点更新n号节点距离起点的距离，将得到10^9−2, 虽然小于10^9, 但并不存在最短路，(在边数限制在k条的条件下)

![4.PNG](%E5%BA%93/652_1aa3df28a4-4.png)



`dijkstra`不能解决负权边是因为 `dijkstra`要求每个点被确定后`st[j] = true`，`dist[j]`就是最短距离了，之后就不能再被更新了（一锤子买卖），而如果有负权边的话，那已经确定的点的`dist[j]`不一定是最短了



## SPFA 算法

队列优化的 Bellman-Ford 算法

时间复杂度 平均情况下 O(m)，最坏情况下 O(nm)，n 表示点数，m 表示边数

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



## AcWing 851. spfa求最短路

https://www.acwing.com/problem/content/853/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 `impossible`。

数据保证不存在负权回路。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z 表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

输出一个整数，表示 1 号点到 n 号点的最短距离。

如果路径不存在，则输出 `impossible`。

#### 数据范围

1≤n,m≤105
图中涉及边长绝对值均不超过 10000

#### 输入样例：

```
3 3
1 2 5
2 3 -3
1 3 4
```

#### 输出样例：

```
2
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n, m;
int h[N], w[N], e[N], ne[N], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int t = spfa();

    if (t == 0x3f3f3f3f) puts("impossible");
    else printf("%d\n", t);

    return 0;
}
```



1. **SPFA不需要dist[n] > 0x3f3f3f3f / 2的条件：**因为队列里都是由起点更新到的点，不存在bellman-ford算法中未更新的点同样被边更新的情况。另解：spfa只会更新所有能从起点走到的点，所以如果无解，那么起点就走不到终点，那么终点的距离就是 0x3f3f3f3f
2. **曾经加入过队列的点出队后，会不会再次被加入队列？再次加入后继续更新与它联通的点？**会的
3. 现在用该方法解决 dijskra 2 那一题会超时（注意数据范围改变了，由100000变成了150000，复制y总该代码时注意改数据范围），这就是因为加强了数据被卡了，数据范围指 N 的值
4. **啥时候用spfa 啥时候用dijkstra（除了负权边）：**能用 dijkstra 的就别用 spfa
5. st 数组去掉之后不影响算法正确性，但队列中会存储重复元素，效率会下降。另解：st 数组的作用是判断是否在队列中，如果重复入队，效率会下降。
6. 有负权回路的话，spfa 可能会陷入死循环。
7. 由于SPFA算法是由Bellman_ford算法优化而来，在最坏的情况下时间复杂度和它一样即时间复杂度为 O(nm)。假如题目时间允许可以直接用SPFA算法去解Dijkstra算法的题目。(好像SPFA有点小小万能的感觉?)
8. Bellman_ford算法可以存在负权回路，是因为其循环的次数是有限制的因此最终不会发生死循环；但是SPFA算法不可以，由于用了队列来存储，只要发生了更新就会不断的入队，因此假如有负权回路请你不要用SPFA否则会死循环。



## SPFA判断负环

时间复杂度是 O(nm)，n 表示点数，m 表示边数

```c++
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N], cnt[N];        // dist[x]存储1号点到x的最短距离，cnt[x]存储1到x的最短路中经过的点数
bool st[N];     // 存储每个点是否在队列中

// 如果存在负环，则返回true，否则返回false。
bool spfa()
{
    // 不需要初始化dist数组
    // 原理：如果某条最短路径上有n个点（除了自己），那么加上自己之后一共有n+1个点，由抽屉原理一定有两个点相同，所以存在环。

    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // 如果从1号点到x的最短路中包含至少n个点（不包括自己），则说明存在环
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}
```



## AcWing 852. spfa判断负环

https://www.acwing.com/problem/content/854/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你判断图中是否存在负权回路。

#### 输入格式

第一行包含整数 n 和 m。

接下来 m 行每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

#### 输出格式

如果图中**存在**负权回路，则输出 `Yes`，否则输出 `No`。

#### 数据范围

1≤n≤2000
1≤m≤10000
图中涉及边长绝对值均不超过 10000

#### 输入样例：

```
3 3
1 2 -1
2 3 4
3 1 -4
```

#### 输出样例：

```
Yes
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 2010, M = 10010;

int n, m;
int h[N], w[M], e[M], ne[M], idx;
int dist[N], cnt[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

bool spfa()
{
    queue<int> q;

    for (int i = 1; i <= n; i ++ )
    {
        st[i] = true;
        q.push(i);
    }

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;

                if (cnt[j] >= n) return true;
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    if (spfa()) puts("Yes");
    else puts("No");

    return 0;
}
```



求负环一般使用SPFA算法，方法是用一个cnt数组记录每个点到源点的边数，一个点被更新一次就+1，一旦有点的边数达到了n那就证明存在了负环。

1. 本题需要注意的是

    ```c++
    for (int i = 1; i <= n; i ++ ) q.push(i);
    ```

    **题目没有说一定是一个连通图**

2. **这里为什么不用初始化dist数组了**

    dist 数组一开始已经是0了，所以接下来只会更新小于0的边权，也就是负权边，存在负环的话就会不停的更新

    **另解：**因为你是把所有的顶点都入队了，所以可以看成所有顶点都是初始起点，如果你只设例如1为起点，那样对负权回路的判断就很困难，但是如果你设所有顶点都为起点，那样一定有起点处于负权回路中，而且我们是要求负权回路，所以初始化就没有那么重要了，因为如果有父权回路那样  q.size(）>=1  恒成立

    **另解：**dist 数组一开始已经是0了，所以接下来只会更新小于0的边权，也就是负权边，存在负环的话就会不停的更新，这里不需要求最短路，所以不用初始化为正无穷。cnt [j] 记录的不是当前 j 这个点的最短路经过的边数，如果等于 n 的话经过了 n 条边这个路径必然有 n+1 个点，所以就有负权值回路了

    **另解：**if 判断最开始只有在有负权值的时候符合，然后如果存在负环，就会在负环里面转起来，cnt 逐渐累加，加到 cnt[j] >=n



## Floyd 算法

时间复杂度是 O(n^3)，n 表示点数

```c++
//初始化：
for (int i = 1; i <= n; i ++ )
    for (int j = 1; j <= n; j ++ )
        if (i == j) d[i][j] = 0;
		else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

## AcWing 854. Floyd求最短路

https://www.acwing.com/problem/content/856/

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定 k 个询问，每个询问包含两个整数 x 和 y，表示查询从点 x 到点 y 的最短距离，如果路径不存在，则输出 `impossible`。

数据保证图中不存在负权回路。

#### 输入格式

第一行包含三个整数 n,m,k

接下来 m 行，每行包含三个整数 x,y,z，表示存在一条从点 x 到点 y 的有向边，边长为 z。

接下来 k 行，每行包含两个整数 x,y 表示询问点 x 到点 y 的最短距离。

#### 输出格式

共 k 行，每行输出一个整数，表示询问的结果，若询问两点间不存在路径，则输出 `impossible`。

#### 数据范围

1≤n≤200
1≤k≤n2
1≤m≤20000
图中涉及边长绝对值均不超过 1000010000。

#### 输入样例：

```
3 3 2
1 2 1
2 3 2
1 3 1
2 1
1 3
```

#### 输出样例：

```
impossible
1
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 210, INF = 1e9;

int n, m, Q;
int d[N][N];

void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main()
{
    scanf("%d%d%d", &n, &m, &Q);

    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        d[a][b] = min(d[a][b], c);
    }

    floyd();

    while (Q -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);

        int t = d[a][b];
        if (t > INF / 2) puts("impossible");
        else printf("%d\n", t);
    }

    return 0;
}
```

**注意：计算状态的时候 for (int k = 1; k <= n; k++) 要放到最外层**

<img src="%E5%BA%93/image-20221218163336249.png" alt="image-20221218163336249" style="zoom:80%;" />

![image-20221218163500745](%E5%BA%93/image-20221218163500745.png)

![image-20221218163640536](%E5%BA%93/image-20221218163640536.png)



# 最小生成树

【最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示】 https://www.bilibili.com/video/BV1Eb41177d1/?share_source=copy_web&vd_source=8fa0ddfc571cb8e214b881be981477a4



![image-20221219093911987](%E5%BA%93/image-20221219093911987.png)



## 朴素版Prim 算法

时间复杂度是 O(n^2+m)，n 表示点数，m 表示边数

```c++
int n;      // n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     // 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        if (i && dist[t] == INF) return INF;

        if (i) res += dist[t];
        st[t] = true;

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```



## AcWing 858. Prim算法求最小生成树

https://www.acwing.com/problem/content/860/

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)，其中 VV 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。

由 V 中的全部 n 个顶点和 EE 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。

#### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

#### 数据范围

1≤n≤500
1≤m≤105
图中涉及边的边权的绝对值均不超过 10000

#### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

#### 输出样例：

```
6
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, INF = 0x3f3f3f3f;

int n, m;
int g[N][N];
int dist[N];
bool st[N];


int prim()
{
    memset(dist, 0x3f, sizeof dist);

    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        //选择到集合距离最短的点
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;

        //如果不是连通图
        if (i && dist[t] == INF) return INF;

        //将这个点加入集合
        if (i) res += dist[t];
        st[t] = true;

        //更新距离
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);//更新这个点到其他点的距离
    }

    return res;
}


int main()
{
    scanf("%d%d", &n, &m);

    memset(g, 0x3f, sizeof g);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = g[b][a] = min(g[a][b], c);
    }

    int t = prim();

    if (t == INF) puts("impossible");
    else printf("%d\n", t);

    return 0;
}
```



## Kruskal算法

时间复杂度是 O(mlogm)，n 表示点数，m 表示边数

```c++
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父节点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集核心操作
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```



## AcWing 859. Kruskal算法求最小生成树

https://www.acwing.com/problem/content/861/

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 G=(V,E)，其中 V 表示图中点的集合，E 表示图中边的集合，n=|V|，m=|E|。

由 V 中的全部 n 个顶点和 EE 中 n−1 条边构成的无向连通子图被称为 G 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 G 的最小生成树。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含三个整数 u,v,w，表示点 u 和点 v 之间存在一条权值为 w 的边。

#### 输出格式

共一行，若存在最小生成树，则输出一个整数，表示最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

#### 数据范围

1≤n≤105
1≤m≤2∗105
图中涉及边的边权的绝对值均不超过 1000

#### 输入样例：

```
4 5
1 2 1
1 3 2
1 4 3
2 3 2
3 4 4
```

#### 输出样例：

```
6
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010, INF = 0x3f3f3f3f;

int n, m;
int p[N];

struct Edge
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}

int main()
{
    scanf("%d%d", &n, &m);

    for (int i = 0; i < m; i ++ )
    {
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }

    int t = kruskal();

    if (t == INF) puts("impossible");
    else printf("%d\n", t);

    return 0;
}
```



# 二分图

![image-20221219093929930](%E5%BA%93/image-20221219093929930.png)



## 染色法判别二分图

时间复杂度是 O(n+m)，n 表示点数，m 表示边数

```c++
int n;      // n表示点数
int h[N], e[M], ne[M], idx;     // 邻接表存储图
int color[N];       // 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前节点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```



## AcWing 860. 染色法判定二分图

https://www.acwing.com/problem/content/862/

给定一个 n 个点 m 条边的无向图，图中可能存在重边和自环。

请你判断这个图是否是二分图。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 u 和 v，表示点 u 和点 v 之间存在一条边。

#### 输出格式

如果给定图是二分图，则输出 `Yes`，否则输出 `No`。

#### 数据范围

1≤n,m≤105

#### 输入样例：

```
4 4
1 3
1 4
2 3
2 4
```

#### 输出样例：

```
Yes
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c)
{
    color[u] = c;

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }

    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (!color[i])//没染过色就染色
        {
            if (!dfs(i, 1))//染色冲突就报错
            {
                flag = false;
                break;
            }
        }

    if (flag) puts("Yes");
    else puts("No");

    return 0;
}
```



1. **二分图一定是连通图嘛？**不一定。只要能将所有点分成两个集合，使得所有边只出现在集合之间，就是二分图。
2. 如果有自环的话，就会发现自环这条边的两端颜色相同，就矛盾了。模板题里有很多“包含自环、重边”的描述，是为了告诉大家算法本身可以有效处理这种边界问题



## 匈牙利算法

时间复杂度是 O(nm)，n 表示点数，m 表示边数

```c++
int n1, n2;     // n1表示第一个集合中的点数，n2表示第二个集合中的点数
int h[N], e[M], ne[M], idx;     // 邻接表存储所有边，匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边
int match[N];       // 存储第二个集合中的每个点当前匹配的第一个集合中的点是哪个
bool st[N];     // 表示第二个集合中的每个点是否已经被遍历过

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```



## AcWing 861. 二分图的最大匹配

https://www.acwing.com/problem/content/863/

给定一个二分图，其中左半部包含 n1 个点（编号 1∼n1），右半部包含 n2 个点（编号 1∼n2），二分图共包含 m 条边。

数据保证任意一条边的两个端点都不可能在同一部分中。

请你求出二分图的最大匹配数。

> 二分图的匹配：给定一个二分图 G，在 G 的一个子图 M 中，M 的边集 {E} 中的任意两条边都不依附于同一个顶点，则称 M 是一个匹配。
>
> 二分图的最大匹配：所有匹配中包含边数最多的一组匹配被称为二分图的最大匹配，其边数即为最大匹配数。

#### 输入格式

第一行包含三个整数 n1、n2 和 m。

接下来 m 行，每行包含两个整数 u 和 v，表示左半部点集中的点 u 和右半部点集中的点 v 之间存在一条边。

#### 输出格式

输出一个整数，表示二分图的最大匹配数。

#### 数据范围

1≤n1,n2≤500
1≤u≤n1
1≤v≤n2
1≤m≤105

#### 输入样例：

```
2 2 4
1 1
1 2
2 1
2 2
```

#### 输出样例：

```
2
```

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510, M = 100010;

int n1, n2, m;
int h[N], e[M], ne[M], idx;
int match[N];
bool st[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }

    return false;
}

int main()
{
    scanf("%d%d%d", &n1, &n2, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }

    int res = 0;
    for (int i = 1; i <= n1; i ++ )
    {
        memset(st, false, sizeof st);
        if (find(i)) res ++ ;
    }

    printf("%d\n", res);

    return 0;
}
```



对于st数组的理解：

1. 必须要存在，不存在就会出现 find 无限递归同一个女孩
2. 必须每次要全部更新为 false ，否则男孩无法挖墙脚，从而会得不到最大匹配
3. 必须每次刷新，因为如果不刷新，st 和 match 作用就完全一样了，st 数组希望给每个渣男全部的机会，但又不至于死循环
