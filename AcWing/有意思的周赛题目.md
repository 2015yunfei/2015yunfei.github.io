# 第九十六场周赛

## AcWing 4877. 最大价值

https://www.acwing.com/problem/content/4880/

有一个容量为 *n* 的背包和 *m*+1 种物品，每种物品都有无限多个。

物品种类编号为 0∼*m*。第 *i* 种物品的体积为 *vi*，价值为 *wi*。

在使用背包装入物品时，每种物品的限重如下：

- 第 0 种物品：重量忽略不计，在装入时没有重量限制。
- 第 1∼*m* 种物品：第 *i* 种物品的单个重量为 *hi*，如果该种物品的装入总重量超过 *li*，则视为超重。

现在，请你挑选物品装入背包，要求：

- 所有装入物品的总体积不得超过背包容量。
- 所有存在重量限制的物品均不得超重。
- 满足以上所有条件的前提下，所有装入物品的总价值尽可能大。

输出总价值的最大可能值。

注意审题，不要将 *n*,*m* 的含义弄混。

#### 输入格式

第一行包含四个整数 *n*,*m*,*v*0,*w*0。接下来 *m* 行，每行包含四个整数 *li*,*hi*,*vi*,*wi*。

#### 输出格式

一个整数，表示总价值的最大可能值。

#### 数据范围

前 4 个测试点满足 1≤*n*≤100，1≤*m*≤2。 所有测试点满足 1≤*n*≤1000，1≤*m*≤10，1≤*li*,*hi*,*vi*,*wi*≤100。

#### 输入样例1：

```
10 2 2 1
7 3 2 100
12 3 1 10
```

#### 输出样例1：

```
241
```

#### 输入样例2：

```
100 1 25 50
15 5 20 10
```

#### 输出样例2：

```
200
```

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1010;

int n, m, v, w;
int f[N];

int main() {
    cin >> n >> m >> v >> w;
    for (int i = v; i <= n; ++i) f[i] = f[i - v] + w;

    for (int i = 1; i <= m; ++i) {
        int l, h;
        scanf("%d%d%d%d", &l, &h, &v, &w);
        for (int j = n; j >= 0; j--) {
            for (int k = 1; k <= l / h && v * k <= j; ++k) {
                f[j] = max(f[j], f[j - v * k] + w * k);
            }
        }
    }
    cout << f[n];
    return 0;
}
```

看到这道题，一眼就是背包问题，但是这个题目多了些条件。其实就是多重背包多了些条件，`l`和`h`就是确定了这个物品的数量。体积为`0`的物品预处理一下就行



## AcWing 4878. 维护数组

https://www.acwing.com/problem/content/4881/

给定一个长度为 *n* 的整数序列 *d*1,*d*2,…,*dn* 以及三个整数 *k*,*a*,*b*。初始时，所有 *di* 均为 0。

你需要对序列依次进行 *q* 次操作，操作分为以下两种：

- `1 x y`，将 *dx* 增加 *y*。

- `2 p`，计算并输出 ∑*i*=1*p*−1min(*di*,*b*)+∑*i*=*p*+*kn*min(*di*,*a*)。![image-20230326002801219](./库/image-20230326002801219.png)

#### 输入格式

第一行包含 5 个整数 *n*,*k*,*a*,*b*,*q*。接下来 *q* 行，每行描述一个操作，格式如题面所述。

#### 输出格式

每个 `2 p` 操作，输出一行一个整数表示结果。

#### 数据范围

前 3 个测试点满足 1≤*k*≤*n*≤10，1≤*q*≤10。

所有测试点满足 1≤*k*≤*n*≤2×105，1≤*b*<*a*≤10000，1≤*q*≤2×105，1≤*x*≤*n*，1≤*y*≤100001≤*p*≤*n*−*k*+1。

#### 输入样例1：

```
5 2 2 1 8
1 1 2
1 5 3
1 2 1
2 2
1 4 2
1 3 2
2 1
2 3
```

#### 输出样例1：

```
3
6
4
```

#### 输入样例2：

```
5 4 10 1 6
1 1 5
1 5 5
1 3 2
1 5 2
2 1
2 2
```

#### 输出样例2：

```
7
1
```

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 10;
int n, k, a, b, q;

struct node {
    int l, r, w, mina, minb;
} tr[N * 4];

void build(int u, int l, int r) {
    tr[u] = {l, r};
    if (l == r) return;
    int mid = l + r >> 1;
    if (l <= mid) build(u << 1, l, mid);
    if (r >= mid + 1) build(u << 1 | 1, mid + 1, r);
}

void pushup(int u) {
    tr[u].mina = tr[u << 1].mina + tr[u << 1 | 1].mina;
    tr[u].minb = tr[u << 1].minb + tr[u << 1 | 1].minb;
}

void modify(int u, int x, int v) {
    if (tr[u].l == tr[u].r) {
        tr[u].w += v;
        tr[u].mina = min(tr[u].w, a);
        tr[u].minb = min(tr[u].w, b);
        return;
    }
    int mid = tr[u].l + tr[u].r >> 1;
    if (x <= mid) modify(u << 1, x, v);
    else modify(u << 1 | 1, x, v);
    pushup(u);
}

int queryl(int u, int l, int r);

int queryr(int u, int l, int r) {
    if (r < l) return 0;
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].mina;
    int mid = tr[u].l + tr[u].r >> 1;
    int res = 0;
    if (l <= mid) res += queryl(u << 1, l, r);
    if (r >= mid + 1) res += queryr(u << 1 | 1, l, r);
    return res;
}

int queryl(int u, int l, int r) {
    if (r < l) return 0;
    if (l <= tr[u].l && tr[u].r <= r) return tr[u].minb;
    int mid = tr[u].l + tr[u].r >> 1;
    int res = 0;
    if (l <= mid) res += queryl(u << 1, l, r);
    if (r >= mid + 1) res += queryr(u << 1 | 1, l, r);
    return res;
}

int main() {
    cin >> n >> k >> a >> b >> q;
    build(1, 1, n);
    int op, x, y;
    for (int i = 0; i < q; ++i) {
        scanf("%d%d", &op, &x);
        if (op == 1) {
            scanf("%d", &y);
            modify(1, x, y);
        } else printf("%d\n", queryl(1, 1, x - 1) + queryr(1, x + k, n));
    }
    return 0;
}
```

线段树需要维护的东西比较多，主要有三个

`w`记录已经加入的`v`，这项必须记录，因为可以多次添加`v`

`mina`表示当前区间内每个点`min(v,a)`的和

`minb`表示当前区间内每个点`min(v,b)`的和

每次更新时，需要将左右子区间的`mina`和`minb`相加即可，不要想复杂了！



# 第九十五场周赛

## AcWing 4874. 约数

https://www.acwing.com/problem/content/4877/

如果一个正整数的约数个数恰好为 3，则称该数为美丽数。

给定 *n* 个正整数 *a*1,*a*2,…,*an*，请你依次判断每个数是否是美丽数。

#### 输入格式

第一行包含整数 *n*。第二行包含 *n* 个整数 *a*1,*a*2,…,*an*。

#### 输出格式

共 *n* 行，其中第 *i* 行输出对 *ai* 的判断，如果 *ai* 是美丽数，则输出 `YES`，否则输出 `NO`。

#### 数据范围

前 6 个测试点满足 1≤*n*≤10。 所有测试点满足 1≤*n*≤10^5^，1≤a~i~≤10^12^。

#### 输入样例：

```
3
4 5 6
```

#### 输出样例：

```
YES
NO
NO
```

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 1e6 + 10;

int primes[N], cnt;
bool st[N];

void get_primes(int n) // 线性筛
{
    st[1] = true;
    for (int i = 2; i <= n; i++) {
        if (!st[i]) primes[cnt++] = i;
        for (int j = 0; primes[j] <= n / i; j++) {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

int main() {
    int n;
    cin >> n;
    get_primes(N);
    while (n--) {
        LL x;
        cin >> x;
        int t = sqrt(x);
        if ((LL) t * t == x && st[t] == false) puts("YES");
        else puts("NO");
    }
    return 0;
}
```

如果想要一个数只有3个约数，那么这个数必然是一个素数的平方

我们只需要判断一下这个数开根号之后是否是一个素数即可

通过线性筛把10^6^以内的素数筛一遍，并通过`st`数组存储一下一个数是否是素数



## AcWing 4875. 整数游戏

https://www.acwing.com/problem/content/4878/

Alice 和 Bob 在玩一个游戏。

首先，给定一个长度为 *n* 的正整数数列 *a*1,*a*2,…,*an*。

随后，两人轮流展开行动，由 Alice 先手行动。

当轮到一人采取行动时，如果 *a*1=0，则该玩家输掉游戏，否则该玩家需要：

1. 在 [2,*n*] 范围内选择一个整数 *i*。
2. 将 *a*1 的值减少 1。
3. 交换 *a*1 和 *ai*的值。

假设双方都采取最优策略，请你判断谁将获胜。

#### 输入格式

第一行包含整数 *T*，表示共有 *T* 组测试数据。每组数据第一行包含整数 *n*。

第二行包含 *n* 个整数 *a*1,*a*2,…,*an*。

#### 输出格式

每组数据输出一行结果，如果 Alice 获胜，则输出 `Alice`，如果 Bob 获胜，则输出 `Bob`。

#### 数据范围

前 3 个测试点满足 1≤*T*≤10，2≤*n*≤3。 所有测试点满足 1≤*T*≤2×10^4^，2≤*n*≤10^5^，1≤a~i~≤10^9^，一个测试点的所有的 *n* 相加之和不超过 2×10^5^。

#### 输入样例：

```
3
2
1 1
2
2 1
3
5 4 4
```

#### 输出样例：

```
Bob
Alice
Alice
```

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, g[N];

void solve() {
    cin >> n;
    int minn = 2e9, x;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &g[i]);
        minn = min(minn, g[i]);
    }
    if (minn == g[0]) puts("Bob");
    else puts("Alice");
}

int main() {
    int t;
    cin >> t;
    while (t--) solve();
    return 0;
}
```

最小值是最快变成 0 的，如果第一个元素是最小值则先手必败，否则后手必败

- 若第一个元素是最小值且不是 0 (是 0 直接输了，没必要讨论)：

则先手 Alice 减 1 后，不管与谁交换值，交换后都比之前大， 由于第一个元素不是 0 , 所以交换后轮到 Bob 也必然不是 0。而 Bob 只需要做一件事，不断将最小值扔回给 Alice ， 则 Alice 必然最先达到 0， 必败。

- 若第一个元素不是最小值

则 Alice 在减 1 后， 直接选择最小值扔给 Bob，转变为 Bob 先手拿到最小值，则转变上面那种情况，必败。



# 第九十四场周赛

## AcWing 4871. 最早时刻

https://www.acwing.com/problem/content/4874/

给定一个 *n* 个点 *m* 条边的**不含重边和自环**的**无向图**。

点的编号为 1∼*n*，边的编号为 1∼*m*。

在 *t*=0 时刻，你位于 1 号点。

你的任务是尽可能早的抵达 *n* 号点。

第 *i* 条边连接点 *ai* 和点 *bi*，通过此边需要花费的时间为 *ci*。

在整个移动过程中，你只有在**整数时刻**才能离开某一点前往另一点。

此外，第 *i* 个点有 *ki* 个禁止离开时刻。

在每个点的禁止离开时刻，你无法离开该点前往其它点。

请你计算抵达 *n* 号点的最早可能时刻。

#### 输入格式

第一行包含两个整数 *n*,*m*。

接下来 *m* 行，其中第 *i* 行包含三个整数 *ai*,*bi*,*ci*，表示第 *i* 条边连接点 *ai* 和 *bi*，通过此边需要花费的时间为 *ci*。

接下来 *n* 行，其中第 *i* 行首先包含一个整数 *ki*，表示第 *i* 个点有 *ki* 个禁止离开时刻，随后包含 *ki* 个互不相同的**升序排序**的整数 *t~ij~*，表示所有禁止离开时刻。

#### 输出格式

一个整数，表示抵达 *n*

 号点的最早可能时刻。

如果无法抵达 *n*

 号点，则输出 `-1`。

#### 数据范围

前 4 个测试点满足 2≤*n*≤4。 所有测试点满足 2≤*n*≤10^5^，0≤*m*≤10^5^，1≤*ai*,*bi*≤*n*，*ai*≠*bi*，1≤*ci*≤10^4^ 0≤*ki*≤10^5^，0≤*t~ij~*<10^9^，所有 *ki* 相加之和不超过 10^5^。

#### 输入样例1：

```
4 6
1 2 2
1 3 3
1 4 8
2 3 4
2 4 5
3 4 3
0
1 3
2 3 4
0
```

#### 输出样例1：

```
7
```

#### 样例1解释

从点 1 到点 4，考虑如下三条路线：

- 在时刻 0 通过第 3 条边离开点 1，并于时刻 8 抵达点 4。
- 在时刻 0 通过第 2 条边离开点 1，并于时刻 3 抵达点 3，由于点 3 在时刻 3,4 禁止离开，所以在时刻 5 通过第 6 条边离开点 3，并于时刻 8 抵达点 4。
- 在时刻 0 通过第 1 条边离开点 1，并于时刻 2 抵达点 2，在时刻 2 通过第 5 条边离开点 2，并于时刻 7 抵达点 4。

- 最佳方案为第三条路线，抵达点 4 的最早可能时刻为 7。

#### 输入样例2：

```
3 1
1 2 3
0
1 3
0
```

#### 输出样例2：

```
-1
```

```c++
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 1e5 + 10, M = 2 * N;

int n, m, h[N], e[M], ne[M], w[M], idx, dist[N];
bool st[N];
vector<int> delay[N];

void add(int a, int b, int c) {
    e[idx] = b;
    ne[idx] = h[a];
    w[idx] = c;
    h[a] = idx++;
}

int add_delay(int ver, int distance) {
    for (auto s: delay[ver]) {
        if (s == distance) distance++;
        else if (s > distance) break;
    }
    return distance;
}

void dijkstra() {
    memset(dist, 0x3f, sizeof dist);
    priority_queue<PII, vector<PII>, greater<PII> > q;
    q.push({0, 1});
    dist[0] = 1;
    while (q.size()) {
        auto t = q.top();
        q.pop();
        int ver = t.second;
        if (st[ver]) continue;
        else st[ver] = true;
        int distance = add_delay(ver, t.first);
        for (int i = h[ver]; ~i; i = ne[i]) {
            int j = e[i];
            if (dist[j] > distance + w[i]) {
                dist[j] = distance + w[i];
                q.push({dist[j], j});
            }
        }
    }
}

int main() {
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; ++i) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }
    for (int i = 1; i <= n; ++i) {
        int k;
        scanf("%d", &k);
        delay[i].resize(k);
        for (int j = 0; j < k; ++j) scanf("%d", &delay[i][j]);
    }
    dijkstra();
    if (dist[n] == 0x3f3f3f3f) cout << -1;
    else cout << dist[n];
    return 0;
} 
```



## AcWing 4872. 最短路之和

https://www.acwing.com/problem/content/4875/

给定一个 *n* 个点的加权有向图，点的编号为 1∼*n*。

图中任意两点之间都有两条方向相反的边连接两点。从点 *i* 到点 *j* 的边的长度为 *a~ij~*。

给定一个 1∼*n* 的排列 *x*1,*x*2,…,*xn*。

你需要对该图依次进行 *n* 个操作。

其中，第 *i* 个操作是将点 *xi* 以及该点的所有入边和出边从图中移除。

在执行每一个操作**之前**，你还需要进行如下计算：

- 对于每个当前剩余点对 (*u*,*v*)，计算从点 *u* 到点 *v* 的最短路长度。

- 将这些最短路长度全部相加得到最短路之和。

注意：

- 剩余点对 (*u*,*v*)：两个还未被移除的点 *u*,*v*（*u*≠*v*）组成的点对。(*u*,*v*)和 (*v*,*u*)是两个不同点对，需分别计算最短路长度并计入最短路之和。

- *n* 个操作是按顺序依次执行的，前面的操作会对后面的计算产生影响。

请你输出执行每个操作前计算得到的最短路之和。

#### 输入格式

第一行包含整数 *n*。

接下来 *n* 行，每行包含 *n* 个整数，其中第 *i* 行第 *j* 个数为 *a**i**j*。

最后一行包含 *n* 个整数 *x*1,*x*2,…,*x**n*。

#### 输出格式

共一行，输出 *n* 个整数，其中第 *i* 个整数表示执行第 *i* 个操作**之前**，计算得到的最短路之和。

#### 数据范围

前 4 个测试点满足 1≤*n*≤4。 所有测试点满足 1≤*n*≤500，1≤*a~ij~*≤105，*a**i**i*=0，1≤*xi*≤*n*，保证 *x*1∼*xn* 是一个 1∼*n* 的排列。

#### 输入样例1：

```
1
0
1
```

#### 输出样例1：

```
0
```

#### 输入样例2：

```
2
0 5
4 0
1 2
```

#### 输出样例2：

```
9 0
```

#### 输入样例3：

```
4
0 3 1 1
6 0 400 1
2 4 0 1
1 1 1 0
4 1 2 3
```

#### 输出样例3：

```
17 23 404 0
```

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long LL;
const int N = 510;

int n;
int d[N][N];
int p[N];
LL ans[N];
bool st[N];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            scanf("%d", &d[i][j]);
    for (int i = 1; i <= n; i++) scanf("%d", &p[i]);

    for (int u = n; u; u--) {
        int k = p[u];
        st[k] = true;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);

        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++)
                if (st[i] && st[j])
                    ans[u] += d[i][j];
    }
    for (int i = 1; i <= n; i++) printf("%lld ", ans[i]);
    return 0;
}
```