## AcWing 905. 区间选点

https://www.acwing.com/problem/content/907/

给定 N 个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，使得每个区间内至少包含一个选出的点。

输出选择的点的最小数量。

位于区间端点上的点也算作区间内。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示所需的点的最小数量。

#### 数据范围

1≤N≤10^5^
−10^9^≤ai≤bi≤10^9^

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (range[i].l > ed)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}
```



![image-20230101094855404](%E5%BA%93/image-20230101094855404.png)



本贪心策略可以求出最少取的点数，原因分析如下：

首先每个区间内必须都有点，而按右端点排序后，对于右端点最小的那个区间，取哪个点最好呢？

显然取右端点最好，因为右端点更容易被后面的区间覆盖，而所有被这个点覆盖的区间不用再考虑，而在其之后第一个没有覆盖的区间，又回到之前的问题，这个区间一定要被点覆盖，而最优点在右端点处，这是一个循环的过程，因为最后全局最优解是每个区间覆盖所需要的点数之和，即最优解= x1+x2+x3+..+xn，xi 为右端点排序后覆盖第i个区间是否需要再添加点，需要为 1 ，不需要为 0 。而贪心的过程是从左向右依次确定xi的过程，可以发现 xi 的值与 xj(j>i) 无关，理解为覆盖本区间是否需要添加点与它右面的区间无关，因为点是按照区间又端点排序后各区间按从左向右依次添加的，那么每个 xi 尽量小则总体最小。对于一个没有被前面区间的右端点覆盖的第 i 个区间，假设第 i 个到第 j 个区间为一组，它们满足第 i 个区间右端点同时被该组其他所有区间包括，那么该组整体即取到最小值 1，显然不可能更小，之后只需要考虑 x(j+1) 以后的变量值了，如此循环操作，所有 xi 值都能确定，所以该贪心策略可以取到全局最优。





> 讲解重载运算符的博文：
>
> https://blog.csdn.net/m0_51940505/article/details/118274408



**C++运算符重载**

运算符重载的本质为函数重载，但有一定的规则需要遵循

- 重载运算符时，运算符的运算顺序和优先级不变，操作数个数不变

- 不能创造新的运算符，只能重载C++中已有的运算符，并且规定有6个运算符不能重载，如表所示

    | 不能重载的运算符 | 含义             |
    | ---------------- | ---------------- |
    | **.**            | 类属关系运算符   |
    | **.***           | 成员指针运算符   |
    | **::**           | 作用域运算符     |
    | **?:**           | 条件运算符       |
    | #                | 编译预处理符号   |
    | sizeof           | 取数据类型的长度 |

- 运算符重载是针对新类型的实际需求，对原有的运算符进行适当的改造。一般来讲，重载后的运算符的功能应当与运算符的实际意义相符



由于运算符种类与数量较多，我在此将运算符重载粗浅分为4类：

- 赋值运算符的重载
- 算术运算符的重载
- 关系运算符的重载
- 其他较为特殊的重载



## AcWing 908. 最大不相交区间数量

https://www.acwing.com/problem/content/910/

给定 N 个闭区间 [ai,bi]，请你在数轴上选择若干区间，使得选中的区间之间互不相交（包括端点）。

输出可选取区间的最大数量。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示可选取区间的最大数量。

#### 数据范围

1≤N≤10^5^
−10^9^≤ai≤bi≤10^9^

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return r < W.r;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &range[i].l, &range[i].r);

    sort(range, range + n);

    int res = 0, ed = -2e9;
    for (int i = 0; i < n; i ++ )
        if (range[i].l > ed)
        {
            res ++ ;
            ed = range[i].r;
        }

    printf("%d\n", res);

    return 0;
}
```



## AcWing 906. 区间分组

https://www.acwing.com/problem/content/908/

给定 N 个闭区间 [ai,bi]，请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，并使得组数尽可能小。

输出最小组数。

#### 输入格式

第一行包含整数 N，表示区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示最小组数。

#### 数据范围

1≤N≤10^5^
−10^9^≤ai≤bi≤10^9^

#### 输入样例：

```
3
-1 1
2 4
3 5
```

#### 输出样例：

```
2
```

```c++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {
        auto r = range[i];
        if (heap.empty() || heap.top() >= r.l) heap.push(r.r);
        else
        {
            heap.pop();
            heap.push(r.r);
        }
    }

    printf("%d\n", heap.size());

    return 0;
}
```

![image-20230101105308987](%E5%BA%93/image-20230101105308987.png)

用堆来维护每个组的最小值



## AcWing 907. 区间覆盖

https://www.acwing.com/activity/content/problem/content/1114/

给定 N 个闭区间 [ai,bi] 以及一个线段区间 [s,t]，请你选择尽量少的区间，将指定线段区间完全覆盖。

输出最少区间数，如果无法完全覆盖则输出 −1。

#### 输入格式

第一行包含两个整数 s 和 t，表示给定线段区间的两个端点。

第二行包含整数 N，表示给定区间数。

接下来 N 行，每行包含两个整数 ai,bi，表示一个区间的两个端点。

#### 输出格式

输出一个整数，表示所需最少区间数。

如果无解，则输出 −1。

#### 数据范围

1≤N≤10^5^
−10^9^≤ai≤bi≤10^9^
−10^9^≤s≤t≤10^9^

#### 输入样例：

```
1 5
3
-1 3
2 4
3 5
```

#### 输出样例：

```
2
```

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    int st, ed;
    scanf("%d%d", &st, &ed);
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    int res = 0;
    bool success = false;
    for (int i = 0; i < n; i ++ )
    {
        int j = i, r = -2e9;
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j ++ ;
        }

        if (r < st)
        {
            res = -1;
            break;
        }

        res ++ ;
        if (r >= ed)
        {
            success = true;
            break;
        }

        st = r;
        i = j - 1;//大循环外面有一个 i++
    }

    if (!success) res = -1;
    printf("%d\n", res);

    return 0;
}
```



## AcWing 148. 合并果子

https://www.acwing.com/problem/content/150/

在一个果园里，达达已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。

达达决定把所有的果子合成一堆。

每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。

可以看出，所有的果子经过 n−1 次合并之后，就只剩下一堆了。

达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以达达在合并果子时要尽可能地节省体力。

假定每个果子重量都为 1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使达达耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 1，2，9

可以先将 1、2 堆合并，新堆数目为 3，耗费体力为 3。

接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12，耗费体力为 12。

所以达达总共耗费体力=3+12=15。

可以证明 15 为最小的体力耗费值。

#### 输入格式

输入包括两行，第一行是一个整数 n，表示果子的种类数。

第二行包含 n 个整数，用空格分隔，第 i 个整数 ai 是第 i 种果子的数目。

#### 输出格式

输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。

输入数据保证这个值小于 2^31^

#### 数据范围

1≤n≤10000
1≤ai≤20000

#### 输入样例：

```
3 
1 2 9 
```

#### 输出样例：

```
15
```

```c++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);

    priority_queue<int, vector<int>, greater<int>> heap;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        heap.push(x);
    }

    int res = 0;
    while (heap.size() > 1)
    {
        int a = heap.top(); heap.pop();
        int b = heap.top(); heap.pop();
        res += a + b;
        heap.push(a + b);
    }

    printf("%d\n", res);
    return 0;
}
```

算法
(贪心,哈夫曼树,堆,优先队列) O(nlogn)
经典哈夫曼树的模型，每次合并重量最小的两堆果子即可。

时间复杂度
使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。

每次操作会将果子的堆数减一，一共操作 n−1 次即可将所有果子合并成1堆。每次操作涉及到2次堆的删除操作和1次堆的插入操作，计算量是 O(logn)。因此总时间复杂度是 O(nlogn)



**贪心问题的证明主要是反证法、数学归纳法、极限演绎法**

比如这个题目，就可以想象一下只有两个人打水的情况



## AcWing 913. 排队打水

https://www.acwing.com/problem/content/description/915/

有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

#### 输入格式

第一行包含整数 n。

第二行包含 n 个整数，其中第 i 个整数表示第 i 个人装满水桶所花费的时间 ti。

#### 输出格式

输出一个整数，表示最小的等待时间之和。

#### 数据范围

1≤n≤10^5^
1≤ti≤10^4^

#### 输入样例：

```
7
3 6 1 4 2 5 7
```

#### 输出样例：

```
56
```

**自己写的**

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
int a[N];
int n;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> a[i];

    sort(a, a + n);

    long long int res = 0;
    for (int i = 0; i < n; i++) res += a[i] * (n - i - 1);

    cout << res;
    return 0;
}
```

**y总代码**

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n;
int t[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &t[i]);

    sort(t, t + n);
    reverse(t, t + n);

    LL res = 0;
    for (int i = 0; i < n; i ++ ) res += t[i] * i;//这里也很巧妙啊，下标就是等待次数

    printf("%lld\n", res);

    return 0;
}
```



## AcWing 104. 货仓选址

https://www.acwing.com/problem/content/description/106/

在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

#### 输入格式

第一行输入整数 N

第二行 N 个整数 A1∼AN

#### 输出格式

输出一个整数，表示距离之和的最小值。

#### 数据范围

1≤N≤100000
0≤Ai≤40000

#### 输入样例：

```
4
6 2 9 1
```

#### 输出样例：

```
12
```

**自己写的**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n;
int a[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);

    sort(a, a + n);

    int res = 0;
    for (int i = 0; n - i - 1 > i; i++) res += (a[n - i - 1] - a[i]);

    cout << res;
    return 0;
}
```

**y总代码**

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int q[N];

int main()
{
    scanf("%d", &n);

    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);

    sort(q, q + n);

    int res = 0;
    for (int i = 0; i < n; i ++ ) res += abs(q[i] - q[n / 2]);

    printf("%d\n", res);

    return 0;
}
```



## AcWing 125. 耍杂技的牛

https://www.acwing.com/problem/content/127/

农民约翰的 N 头奶牛（编号为 1..N）计划逃跑并加入马戏团，为此它们决定练习表演杂技。

奶牛们不是非常有创意，只提出了一个杂技表演：

叠罗汉，表演时，奶牛们站在彼此的身上，形成一个高高的垂直堆叠。

奶牛们正在试图找到自己在这个堆叠中应该所处的位置顺序。

这 N 头奶牛中的每一头都有着自己的重量 Wi 以及自己的强壮程度 Si。

一头牛支撑不住的可能性取决于它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，现在称该数值为风险值，风险值越大，这只牛撑不住的可能性越高。

您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。

#### 输入格式

第一行输入整数 N，表示奶牛数量。

接下来 N 行，每行输入两个整数，表示牛的重量和强壮程度，第 i 行表示第 i 头牛的重量 Wi 以及它的强壮程度 Si。

#### 输出格式

输出一个整数，表示最大风险值的最小可能值。

#### 数据范围

1≤N≤50000
1≤Wi≤10,000
1≤Si≤1,000,000,000

#### 输入样例：

```
3
10 3
2 5
3 3
```

#### 输出样例：

```
2
```

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int, int> PII;

const int N = 50010;

int n;
PII cow[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int s, w;
        scanf("%d%d", &w, &s);
        cow[i] = {w + s, w};
    }

    sort(cow, cow + n);

    int res = -2e9, sum = 0;
    for (int i = 0; i < n; i ++ )
    {
        int s = cow[i].first - cow[i].second, w = cow[i].second;
        res = max(res, sum - s);
        sum += w;
    }

    printf("%d\n", res);

    return 0;
}
```

感觉牛牛的那道题里面有个弹幕讲的很好的就是：初始想的时候：叠牛汉，那肯定是又重由强壮的牛放在下面，弱鸡牛放在上面
