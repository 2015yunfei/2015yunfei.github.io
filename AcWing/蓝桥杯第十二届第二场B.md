## AcWing 3496. 特殊年份

https://www.acwing.com/problem/content/3499/

今年是 2021 年，2021 这个数字非常特殊，它的千位和十位相等，个位比百位大 1，我们称满足这样条件的年份为特殊年份。

输入 5 个年份，请计算这里面有多少个特殊年份。

#### 输入格式

输入 5 行，每行一个 4 位十进制数（数值范围为 1000 至 9999），表示一个年份。

#### 输出格式

输出一个整数，表示输入的 5 个年份中有多少个特殊年份。

#### 输入样例：

```
2019
2021
1920
2120
9899
```

#### 输出样例：

```
2
```

#### 样例解释

2021 和 9899 是特殊年份，其它不是特殊年份。

```c++
#include<bits/stdc++.h>

using namespace std;

int main() {
    int cnt = 0;
    string s;
    cin >> s;
    if (s[0] == s[2] && s[3] == s[1] + 1) cnt++;
    cin >> s;
    if (s[0] == s[2] && s[3] == s[1] + 1) cnt++;
    cin >> s;
    if (s[0] == s[2] && s[3] == s[1] + 1) cnt++;
    cin >> s;
    if (s[0] == s[2] && s[3] == s[1] + 1) cnt++;
    cin >> s;
    if (s[0] == s[2] && s[3] == s[1] + 1) cnt++;
    cout << cnt;
    return 0;
}
```



## AcWing 3490. 小平方

https://www.acwing.com/problem/content/3493/

小蓝发现，对于一个正整数 *n* 和一个小于 *n* 的正整数 *v*，将 *v* 平方后对 *n* 取余可能小于 *n* 的一半，也可能大于等于 *n*的一半。

请问，在 1到 *n*−1 中，有多少个数平方后除以 *n* 的余数小于 *n*的一半。

例如，当 *n*=4时，1,2,3 的平方除以 4 的余数都小于 4的一半。又如，当 *n*=5时，1,4 的平方除以 5 的余数都是 1，小于 5的一半。而 2,3的平方除以 5 的余数都是 4，大于等于 5的一半。

#### 输入格式

输入一行包含一个整数 *n*

#### 输出格式

输出一个整数，表示满足条件的数的数量。

#### 数据范围

1≤*n*≤10000

#### 输入样例：

```
5
```

#### 输出样例：

```
2
```

```c++
#include <bits/stdc++.h>

using namespace std;
int sum, n;

bool check(int x) {
    if (x * x % n < n / 2.0) return true;// 注意是浮点数的运算
    return false;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n - 1; ++i) {
        if (check(i)) sum++;
    }
    cout << sum;
    return 0;
}
```



## AcWing 3491. 完全平方数

https://www.acwing.com/problem/content/3494/

一个整数 *a* 是一个完全平方数，是指它是某一个整数的平方，即存在一个整数 *b*，使得 *a*=*b*^2^

给定一个正整数 *n*，请找到最小的正整数 *x*，使得它们的乘积是一个完全平方数。

#### 输入格式

输入一行包含一个正整数 *n*

#### 输出格式

输出找到的最小的正整数 *x*

#### 数据范围

对于 30%的评测用例，1≤*n*≤1000，答案不超过 1000。
对于 60% 的评测用例，1≤*n*≤10^8^，答案不超过 10^8^。
对于所有评测用例，1≤*n*≤10^12^，答案不超过 10^12^

#### 输入样例1：

```
12
```

#### 输出样例1：

```
3
```

#### 输入样例2：

```
15
```

#### 输出样例2：

```
15
```

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;

int main() {
    LL n;
    cin >> n;
    LL res = 1;
    for (int i = 2; (LL) i * i <= n; ++i) {
        if (n % i == 0) {
            int s = 0;
            while (n % i == 0) {
                s++;
                n /= i;
            }
            if (s % 2) res = res * i;
        }
    }
    if (n > 1) res *= n;
    cout << res;
    return 0;
}
```

本质是输入数字的所有质因数都必须是偶数次方，如果不是则统计一下。



## AcWing 3492. 负载均衡

https://www.acwing.com/problem/content/3495/

有 *n* 台计算机，第 *i* 台计算机的运算能力为 *vi*。有一系列的任务被指派到各个计算机上，第 *i*个任务在 *ai* 时刻分配，指定计算机编号为 *bi*，耗时为 *ci* 且算力消耗为 *di*。

如果此任务成功分配，将立刻开始运行，期间持续占用 *bi* 号计算机 *di* 的算力，持续 *ci *秒。对于每次任务分配，如果计算机剩余的运算能力不足则输出 −1，并取消这次分配，否则输出分配完这个任务后这台计算机的剩余运算能力。

#### 输入格式

输入的第一行包含两个整数 *n*,*m* ，分别表示计算机数目和要分配的任务数。

第二行包含 *n* 个整数 *v*1,*v*2,⋅⋅⋅*vn*，分别表示每个计算机的运算能力。接下来 *m* 行每行 4 个整数 a,b,c,v，意义如上所述。数据保证 *a* 严格递增

#### 输出格式

输出 *m* 行，每行包含一个数，对应每次任务分配的结果。

#### 数据范围

对于 20%的评测用例，*n*,*m*≤200
对于 40% 的评测用例，*n*,*m*≤2000
对于所有评测用例，1≤*n*,*m*≤200000，1≤a,b,c,v≤10^9^，1≤*b*≤*n*

#### 输入样例：

```
2 6
5 5
1 1 5 3
2 2 2 6
3 1 2 3
4 1 6 1
5 1 3 3
6 1 3 4
```

#### 输出样例：

```
2
-1
-1
1
-1
0
```

#### 样例解释

时刻 1，第 1 个任务被分配到第 1 台计算机，耗时为 5，这个任务时刻 6 会结束，占用计算机 1 的算力 3。

时刻 2，第 2 个任务需要的算力不足，所以分配失败了。

时刻 3，第 1 个计算机仍然正在计算第 1 个任务，剩余算力不足 3，所以失败。

时刻 4，第 1 个计算机仍然正在计算第 1 个任务，但剩余算力足够，分配后剩余算力 1。

时刻 5，第 1 个计算机仍然正在计算第 1,4 个任务，剩余算力不足 4，失败。

时刻 6，第 1 个计算机仍然正在计算第 4 个任务，剩余算力足够，且恰好用完。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10;
typedef pair<int, int> PII;
int n, m;
int s[N];
priority_queue<PII, vector<PII>, greater<PII>> q[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) scanf("%d", &s[i]);
    while (m--) {
        int a, b, c, d;
        scanf("%d%d%d%d", &a, &b, &c, &d);
        while (q[b].size() && q[b].top().first <= a) {
            s[b] += q[b].top().second;
            q[b].pop();
        }
        if (s[b] >= d) {
            s[b] -= d;
            q[b].push({a + c, d});
            printf("%d\n", s[b]);
        } else {
            puts("-1");
        }
    }
    return 0;
}
```

对每个计算机维护一个堆,堆中存每一个任务对应的<任务结束时刻,消耗的算力>,
当在ai时刻分配任务d,则把堆中任务结束时刻小于ai的全部弹出\恢复算力,
然后加入当前任务d(要判断能否加入)即可.