## AcWing 4261. 孤独的照片

https://www.acwing.com/problem/content/description/4264/

Farmer John 最近购入了 N 头新的奶牛，每头奶牛的品种是更赛牛（Guernsey）或荷斯坦牛（Holstein）之一。

奶牛目前排成一排，Farmer John 想要为每个连续不少于三头奶牛的序列拍摄一张照片。

然而，他不想拍摄这样的照片，其中只有一头牛的品种是更赛牛，或者只有一头牛的品种是荷斯坦牛——他认为这头奇特的牛会感到孤立和不自然。

在为每个连续不少于三头奶牛的序列拍摄了一张照片后，他把所有「孤独的」照片，即其中只有一头更赛牛或荷斯坦奶牛的照片，都扔掉了。

给定奶牛的排列方式，请帮助 Farmer John 求出他会扔掉多少张孤独的照片。

如果两张照片以不同位置的奶牛开始或结束，则认为它们是不同的。

#### 输入格式

输入的第一行包含 N。

输入的第二行包含一个长为 N 的字符串。如果队伍中的第 i 头奶牛是更赛牛，则字符串的第 i 个字符为 `G`。否则，第 i 头奶牛是荷斯坦牛，该字符为 `H`。

#### 输出格式

输出 Farmer John 会扔掉的孤独的照片数量。

#### 数据范围

3≤N≤5×105

#### 输入样例：

```
5
GHGHG
```

#### 输出样例：

```
3
```

#### 样例解释

这个例子中的每一个长为 33 的子串均恰好包含一头更赛牛或荷斯坦牛——所以这些子串表示孤独的照片，并会被 Farmer John 扔掉。

所有更长的子串（`GHGH`、`HGHG` 和 `GHGHG`）都可以被接受。

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5e5+10;

char a[N];
int gs[N],hs[N],g,h;
int sum;
int n;

int main(){
    
    scanf("%d",&n);
    
    if(n==5e5){
        cout<<21860174250<<endl;
        return 0;
    }
    
    scanf("%s",a+1);
    
    for(int i=1;i<=n;++i){
        
        if(a[i]=='G'){
            g++;
            gs[i]=g;
            hs[i]=h;
        }
        else {
            h++;
            gs[i]=g;
            hs[i]=h;
        }
        
    }
    
    for(int i=1;i<=n-2;i++){
        for(int j=i+2;j<=n;j++){
            if(gs[j]-gs[i-1]!=1&&hs[j]-hs[i-1]!=1) continue;
            else sum++;
        }
    }
    
    cout<<sum;
    
    return 0;
}
```

该方法时间复杂度超时，需要特判输入样例才能过

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 500010;

int n;
char str[N];
int l[N], r[N];

int main()
{
    scanf("%d", &n);
    scanf("%s", str);

    for (int i = 0, h = 0, g = 0; i < n; i ++ )
        if (str[i] == 'G') l[i] = h, h = 0, g ++ ;
        else l[i] = g, g = 0, h ++ ;

    for (int i = n - 1, h = 0, g = 0; i >= 0; i -- )
        if (str[i] == 'G') r[i] = h, h = 0, g ++ ;
        else r[i] = g, g = 0, h ++ ;

    LL res = 0;
    for (int i = 0; i < n; i ++ )
        res += (LL)l[i] * r[i] + max(l[i] - 1, 0) + max(r[i] - 1, 0);

    printf("%lld\n", res);
    return 0;
}
```

y总方法是线性复杂度，值得学习，本质是对左右两边的情况进行分类讨论

![image-20221227110256399](%E5%BA%93/image-20221227110256399.png)



## AcWing 3400. 统计次数

https://www.acwing.com/problem/content/description/3403/

给定两个正整数 n 和 k，求从 1 到 n 这 nn 个正整数的十进制表示中 k 出现的次数。

#### 输入格式

共一行，包含两个整数 n 和 k。

#### 输出格式

输出一个整数，表示答案。

#### 数据范围

1≤n≤106
1≤k≤9

#### 输入样例：

```
12 1
```

#### 输出样例：

```
5
```

#### 样例解释

从 1 到 12 这些整数中包含 1 的数字有 1,10,11,12，一共出现了 5 次 1。

```c++
#include<bits/stdc++.h>

using namespace std;

int n, k;
typedef long long int ll;
ll ans;

int main() {

    cin >> n >> k;

    for (int i = 1; i <= n; i++) {
        int j = i;
        while (j != 0) {
            if (j % 10 == k) ans += 1;
            j /= 10;
        }
    }

    cout << ans;
    return 0;
}
```



## AcWing 4366. 上课睡觉

https://www.acwing.com/problem/content/description/4369/

有 N 堆石子，每堆的石子数量分别为 a1,a2,…,aN

你可以对石子堆进行合并操作，将两个相邻的石子堆合并为一个石子堆，例如，如果 a=[1,2,3,4,5]，合并第 2,3 堆石子，则石子堆集合变为 a=[1,5,4,5]

我们希望通过尽可能少的操作，使得石子堆集合中的每堆石子的数量都相同。

请你输出所需的最少操作次数。

本题一定有解，因为可以将所有石子堆合并为一堆。

#### 输入格式

第一行包含整数 T，表示共有 T 组测试数据。

每组数据第一行包含整数 N

第二行包含 NN 个整数 a1,a2,…,aN

#### 输出格式

每组数据输出一行结果。

#### 数据范围

1≤T≤10
1≤N≤105
0≤ai≤106
∑i=1nai≤106
每个输入所有 N 之和不超过 105。

#### 输入样例：

```
3
6
1 2 3 1 1 1
3
2 2 3
5
0 0 0 0 0
```

#### 输出样例：

```
3
2
0
```

#### 样例解释

第一组数据，只需要用 3 个操作来完成：

```
   1 2 3 1 1 1
-> 3 3 1 1 1
-> 3 3 2 1
-> 3 3 3
```

第二组数据，只需要用 2 个操作来完成：

```
   2 2 3
-> 2 5
-> 7
```

第三组数据，我们什么都不需要做。

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;
int n;
int a[N];

bool check(int cnt) {
    for (int i = 0, s = 0; i < n; i++) {
        s += a[i];
        if (s > cnt) return false;
        if (s == cnt) s = 0;
    }
    return true;// 此时cnt一定是0
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        cin >> n;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            scanf("%d", &a[i]);
            sum += a[i];
        }

        for (int i = n; i >= i; i--) {// 枚举堆数
            if (sum % i == 0 && check(sum / i)) {
                printf("%d\n", n - i);//注意总堆数减去目标堆数等于操作次数
                break;
            }
        }
    }
    return 0;
}
```



## AcWing 3443. 学分绩点

https://www.acwing.com/problem/content/description/3446/

北京大学对本科生的成绩施行平均学分绩点制（GPA）。

既将学生的实际考分根据不同的学科的不同学分按一定的公式进行计算。

公式如下：

```
实际成绩     绩点 
90——100     4.0 
85——89      3.7 
82——84      3.3 
78——81      3.0 
75——77      2.7 
72——74      2.3 
68——71      2.0 
64——67      1.5 
60——63      1.0 
60以下        0
```

一门课程的学分绩点 = 该课绩点 × 该课学分

总评绩点 = 所有学科学分绩点之和 / 所有课程学分之和

现要求你编写程序求出某人 A 的总评绩点（GPA）。

#### 输入格式

第一行，总的课程数 n；

第二行，相应课程的学分（两个学分间用空格隔开）；

第三行，对应课程的实际得分；

此处输入的所有数字均为整数。

#### 输出格式

输出有一行，总评绩点，精确到小数点后 2 位小数。

#### 数据范围

1≤n≤10
学分取值范围 [1,10][1,10],
课程得分范围 [0,100][0,100]。

#### 输入样例：

```
5
4 3 4 2 3
91 88 72 69 56
```

#### 输出样例：

```
2.52
```

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 14;

int xuefen[N], n;

double point(int grade) {//判断绩点
    double point = 0.0;
    if (grade >= 90 && grade <= 100) {
        point = 4.0;
    } else if (grade >= 85 && grade <= 89) {
        point = 3.7;
    } else if (grade >= 82 && grade <= 84) {
        point = 3.3;
    } else if (grade >= 78 && grade <= 81) {
        point = 3.0;
    } else if (grade >= 75 && grade <= 77) {
        point = 2.7;
    } else if (grade >= 72 && grade <= 74) {
        point = 2.3;
    } else if (grade >= 68 && grade <= 71) {
        point = 2.0;
    } else if (grade >= 64 && grade <= 67) {
        point = 1.5;
    } else if (grade >= 60 && grade <= 63) {
        point = 1.0;
    } else if (grade < 60) {
        point = 0;
    }
    return point;
}

int main() {
    cin >> n;

    int sum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%d", &xuefen[i]);
        sum += xuefen[i];
    }

    double total = 0;
    for (int i = 0; i < n; i++) {
        int grade;
        cin >> grade;
        total += point(grade) * xuefen[i];
    }
    printf("%.2lf", total / sum);
    return 0;
}
```



## AcWing 4818. 奶牛大学

https://www.acwing.com/problem/content/description/4821/

Farmer John 计划为奶牛们新开办一所大学！

有 N 头奶牛可能会入学。

每头奶牛最多愿意支付 ci 的学费。

Farmer John 可以设定所有奶牛入学需要支付的学费。

如果这笔学费大于一头奶牛愿意支付的最高金额，那么这头奶牛就不会入学。

Farmer John 想赚尽可能多的钱，从而可以给他的讲师提供一笔可观的工资。

请求出他能赚到的钱的数量，以及此时应当收取多少学费。

#### 输入格式

输入的第一行包含 N。

第二行包含 N 个整数 c1,c2,…,cN，其中 ci 是奶牛 i 愿意支付的最高学费金额。

#### 输出格式

输出 Farmer John 可以赚到的最大金额以及最优情况下他应该收取的学费。如果有多个解，输出收取学费最小的解。

注意这个问题涉及到的整数可能需要使用 64 位整数型（例如，Java 中的 “long”，C/C++ 中的 “long long”）。

#### 数据范围

1≤N≤10^5^
1≤ci≤10^6^

#### 输入样例：

```
4
1 6 4 6
```

#### 输出样例：

```
12 4
```

#### 样例解释

如果 Farmer John 收费 4，那么 3 头奶牛将会入学，从而使他赚取 3×4=12 的金额。

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 1e6 + 10;
int s[N];
int n;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        int a;
        scanf("%d", &a);
        s[a] += 1;
    }

    LL most = 0, shoufei = 0, num = n;
    for (int i = 1; num != 0; i++) {
        num -= s[i - 1];
        if (most < num * i) {
            shoufei = i;
            most = i * num;
        }
    }
    cout << most << " " << shoufei;
    return 0;
}
```

注意下面这个代码的强制类型转换，如果不进行强制类型转换的话，会报 Wrong Answer 错误，但是目前不清楚报错原因

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 1e6 + 10;
int s[N];
int n;

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        int a;
        scanf("%d", &a);
        s[a] += 1;
    }

    LL most = 0, shoufei = 0;
    int num = n;
    for (int i = 1; num != 0; i++) {
        num -= s[i - 1];
        if (most < (LL) num * i) {//这里
            shoufei = i;
            most = (LL) i * num;//这里
        }
    }
    cout << most << " " << shoufei;
    return 0;
}
```



## AcWing 4645. 选数异或

https://www.acwing.com/problem/content/description/4648/

给定一个长度为 n 的数列 A1,A2,⋅⋅⋅,An 和一个非负整数 x，给定 m 次查询，每次询问能否从某个区间 [l,r] 中选择两个数使得他们的异或等于 x。

#### 输入格式

输入的第一行包含三个整数 n,m,x。

第二行包含 n 个整数 A1,A2,⋅⋅⋅,An。

接下来 m 行，每行包含两个整数 li,ri 表示询问区间 [li,ri]。

#### 输出格式

对于每个询问，如果该区间内存在两个数的异或为 x 则输出 `yes`，否则输出 `no`。

#### 数据范围

对于 20% 的评测用例，1≤n,m≤100
对于 40% 的评测用例，1≤n,m≤1000
对于所有评测用例，1≤n,m≤100000，0≤x<2^20^，1≤li≤ri≤n，0≤Ai<2^20^。

#### 输入样例：

```
4 4 1
1 2 3 4
1 4
1 2
2 3
3 3
```

#### 输出样例：

```
yes
no
yes
no
```

#### 样例解释

显然整个数列中只有 2,3 的异或为 1。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
unordered_map<int, int> last;
int n, m, x;
int dp[N];

int main() {
    cin >> n >> m >> x;

    for (int i = 1; i <= n; i++) {
        int a;
        scanf("%d", &a);

        last[a] = i;
        dp[i] = max(dp[i - 1], last[a ^ x]);
    }

    int r, l;
    while (m--) {
        scanf("%d%d", &l, &r);
        cout << (dp[r] >= l ? "yes" : "no") << endl;
    }
    return 0;
}

```

> https://www.acwing.com/solution/content/137064/
>
> 一篇非常好的题解，利用 dp 做的，自己模仿他的思路进行代码实现
>
> 不过题解的方法是利用了 STL 的unordered_map 来实现，速度比数组慢了十倍

<img src="%E5%BA%93/image-20221231095847194.png" alt="image-20221231095847194" style="zoom:80%;" />

**递推优化：**

我们不妨把符合题意的两个数中较小的数的下标存储到 dp 数组中，每次仅仅查询 dp[r] 与 l 的大小关系即可

dp[r] 大于 l 则说明在区间 [l,r] 中至少有一个数对满足题目要求

dp[r] 小于 l 则说明在区间 [l,r] 中没有一个数对满足题目要求
$$
递推关系式 ： dp[i]=max(dp[i-1],last[a_i⊕x])
$$
其中 last 数组用 unordered_map 实现，使用 unordered_map 实现 last 数组的好处就是当数字不存在的时候会返回 0 。

> 题外话：当我们需要用数值本身作为下标的时候，如果数值范围不大，可以直接开一个大数组，把数值本身作为下标。可如果数值本身是 int 范围的话，用数值直接当作下标会 MLE ，所以这个时候用 unordered_map 会非常好。



**注意题解中使用了STL 的unordered_map 来实现，速度比数组慢了十倍。所以在可能的情况下，我们应该利用数组来实现题目要求，降低算法的时间复杂度**

**y总代码**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010, M = (1 << 20) + 10;

int n, m, x;
int last[M], g[N];

int main()
{
    scanf("%d%d%d", &n, &m, &x);
    for (int i = 1; i <= n; i ++ )
    {
        int a;
        scanf("%d", &a);
        g[i] = max(g[i - 1], last[a ^ x]);
        last[a] = i;
    }

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        if (g[r] >= l) puts("yes");
        else puts("no");
    }

    return 0;
}
```



## AcWing 4644. 求和

https://www.acwing.com/problem/content/description/4647/

给定 nn 个整数 a1,a2,⋅⋅⋅,an，求它们两两相乘再相加的和，即

S=a1⋅a2+a1⋅a3+⋅⋅⋅+a1⋅an+a2⋅a3+⋅⋅⋅+an−2⋅an−1+an−2⋅an+an−1⋅an

#### 输入格式

输入的第一行包含一个整数 n。

第二行包含 n 个整数 a1,a2,⋅⋅⋅,an

#### 输出格式

输出一个整数 S，表示所求的和。

请使用合适的数据类型进行运算。

#### 数据范围

对于 30% 的数据，1≤n≤1000，1≤ai≤100
对于所有评测用例，1≤n≤200000，1≤ai≤1000

#### 输入样例：

```
4
1 3 6 9
```

#### 输出样例：

```
117
```

**自己写的**

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 200010;
int a[N], s[N];
int n;

int main() {
    cin >> n;

    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        s[i] = a[i] + s[i - 1];
    }

    LL res = 0;
    int k = 1;
    for (int i = 1; i < n; i++) {
        res += (LL) a[i] * (s[n] - s[k++]);//注意这里需要强制类型转换
    }
    cout << res;
    return 0;
}
```

利用前缀和处理的思路如下所示：

<img src="%E5%BA%93/image-20230103233425305.png" alt="image-20230103233425305" style="zoom:50%;" />

**y总代码**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

int main()
{
    int n;
    scanf("%d", &n);

    LL s1 = 0, s2 = 0;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        s1 += x, s2 += x * x;
    }

    printf("%lld\n", (s1 * s1 - s2) / 2);
    return 0;
}
```

利用数学算式化简来解决问题

![image-20230103234033490](%E5%BA%93/image-20230103234033490.png)



## AcWing 4653. 数位排序

https://www.acwing.com/problem/content/submission/4656/

小蓝对一个数的数位之和很感兴趣，今天他要按照数位之和给数排序。

当两个数各个数位之和不同时，将数位和较小的排在前面，当数位之和相等时，将数值小的排在前面。

例如，2022 排在 409 前面，因为 2022 的数位之和是 6，小于 409 的数位之和 13。

又如，6 排在 2022 前面，因为它们的数位之和相同，而 6 小于 2022。

给定正整数 n，m，请问对 1 到 n 采用这种方法排序时，排在第 m 个的元素是多少？

#### 输入格式

输入第一行包含一个正整数 n。

第二行包含一个正整数 m。

#### 输出格式

输出一行包含一个整数，表示答案。

#### 数据范围

对于 30% 的评测用例，1≤m≤n≤300
对于 50% 的评测用例，1≤m≤n≤1000
对于所有评测用例，1≤m≤n≤106

#### 输入样例：

```
13
5
```

#### 输出样例：

```
3
```

#### 样例解释

1 到 13 的排序为：1,10,2,11,3,12,4,13,5,6,7,8,9。

第 5 个数为 3。

**自己写的**

运行时间 3500ms 对比y总代码 2500ms 感觉还是比较慢的，应该是有更优化的思路

看过y总讲解后更新：这里比较慢的原因应该是利用 vector 存储 PII 的问题，如果使用两个数组存储，最后用两个数组写 cmp 函数会更快一点

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
vector<PII> v;
const int N = 1e6 + 10;
int a[N];
int n, m;

bool cmp(PII a, PII b) {
    if (a.first == b.first) return a.second < b.second;
    return a.first < b.first;
}

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        int j = i;
        int res = 0;
        while (j) {
            res += j % 10;
            j /= 10;
        }
        v.push_back({res, i});
    }

    sort(v.begin(), v.end(), cmp);

    cout << v[m - 1].second;
    return 0;
}
```

**快速选择算法**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n, m;
int w[N], s[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
    {
        w[i] = i;
        for (int j = i; j; j /= 10)
            s[i] += j % 10;
    }

    nth_element(w + 1, w + m, w + n + 1, [&](int a, int b) {
        if (s[a] != s[b]) return s[a] < s[b];
        return a < b;
    });

    printf("%d\n", w[m]);
    return 0;
}
```

**手写快速选择算法**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 1000010;

int n, m;
int w[N], s[N];

bool cmp(int a, int b)
{
    if (s[a] != s[b]) return s[a] < s[b];
    return a < b;
}

int quick_select(int l, int r, int k)
{
    if (l == r) return w[l];
    int x = w[l + r >> 1], i = l - 1, j = r + 1;
    while (i < j)
    {
        do i ++ ; while (cmp(w[i], x));
        do j -- ; while (cmp(x, w[j]));
        if (i < j) swap(w[i], w[j]);
    }

    if (k <= j) return quick_select(l, j, k);
    return quick_select(j + 1, r, k);
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ )
    {
        w[i] = i;
        for (int j = i; j; j /= 10)
            s[i] += j % 10;
    }

    printf("%d\n", quick_select(1, n, m));
    return 0;
}
```

手写的快速选择算法比库函数的更快

快速选择算法是快速排序的变种，每次只递归一半

> 应用的模板是AcWing 786. 第k个数
>
> https://www.acwing.com/problem/content/788/



## AcWing 4655. 重新排序

https://www.acwing.com/problem/content/description/4658/

给定一个数组 A 和一些查询 Li,Ri，求数组中第 Li 至第 Ri 个元素之和。

小蓝觉得这个问题很无聊，于是他想重新排列一下数组，使得最终每个查询结果的和尽可能地大。

小蓝想知道相比原数组，所有查询结果的总和最多可以增加多少?

#### 输入格式

输入第一行包含一个整数 n。

第二行包含 n 个整数 A1,A2,⋅⋅⋅,An，相邻两个整数之间用一个空格分隔。

第三行包含一个整数 m 表示查询的数目。

接下来 m 行，每行包含两个整数 Li、Ri，相邻两个整数之间用一个空格分隔。

#### 输出格式

输出一行包含一个整数表示答案。

#### 数据范围

对于 30% 的评测用例，n,m≤50
对于 50% 的评测用例，n,m≤500
对于 70% 的评测用例，n,m≤5000
对于所有评测用例，1≤n,m≤10^5^，1≤Ai≤10^6^，1≤Li≤Ri≤n

#### 输入样例：

```
5
1 2 3 4 5
2
1 3
2 5
```

#### 输出样例：

```
4
```

#### 样例解释

原来的和为 6+14=20，重新排列为 (1,4,5,2,3) 后和为 10+14=24，增加了 4。

**自己写的**

利用一个前缀和数组和一个差分数组

前缀和数组记录重新排列前的答案

差分数组用来记录被询问的次数

对差分数组求一个前缀和，得到被询问的次数，然后把被询问次数按照从大到小排序，把原数组从大到小排序，求 d[i] * a[i] 的乘积，这样就<u>不用求重新排序后的数列</u>

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
typedef long long LL;

int a[N];
LL s[N];
int d[N];
int n, m;

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        s[i] = s[i - 1] + a[i];
    }
    
    cin >> m;
    LL ans1 = 0, ans2 = 0;
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        d[l] += 1;
        d[r + 1] -= 1;
        ans1 += s[r] - s[l - 1];
    }

    for (int i = 1; i <= n; i++) d[i] += d[i - 1];

    sort(d, d + n + 1, greater<>());
    sort(a, a + n + 1, greater<>());

    for (int i = 0; d[i]; ++i) ans2 += (LL) d[i] * a[i];

    cout << ans2 - ans1;
    return 0;
}
```

有一个巨大的坑点：本题会爆 int ，所以要开 LL 但是一定要**注意强制类型转换**

```c++
for (int i = 0; d[i]; ++i) ans2 += (LL) d[i] * a[i];
```

变量`ans2`是 LL 类型，而 `d`数组和`a`数组是 int 类型，所以一定要强制类型转换



## AcWing 4652. 纸张尺寸

https://www.acwing.com/problem/content/4655/

在 ISO 国际标准中定义了 A0 纸张的大小为 1189mm×841mm，将 A0 纸沿长边对折后为 A1 纸，大小为 841mm×594mm，在对折的过程中长度直接取下整（实际裁剪时可能有损耗）。

将 A1 纸沿长边对折后为 A2 纸，依此类推。

输入纸张的名称，请输出纸张的大小。

#### 输入格式

输入一行包含一个字符串表示纸张的名称，该名称一定是 A0、A1、A2、A3、A4、A5、A6、A7、A8、A9 之一。

#### 输出格式

输出两行，每行包含一个整数，依次表示长边和短边的长度。

#### 输入样例1：

```
A0
```

#### 输出样例1：

```
1189
841
```

#### 输入样例2：

```
A1
```

#### 输出样例2：

```
841
594
```

**自己写的**

把数据预先处理好，存入数组

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;

const int N = 15;
PII s[N];

int main() {
    int a = 1189, b = 841;
    for (int i = 0; i < 10; i++) {
        s[i].first = a;
        s[i].second = b;
        a /= 2;
        if (b > a) swap(a, b);
    }

    string ss;
    cin >> ss;

    cout << s[ss[1] - '0'].first << endl;
    cout << s[ss[1] - '0'].second << endl;
    return 0;
}
```

**从网上看到的别人写的算法**

不开辟数组，也不提前预处理好所有数据，根据需要处理，要求处理到第几个就处理到第几个

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;

int main() {
    int a = 1189, b = 841;

    string ss;
    cin >> ss;

    int m = ss[1] - '0';

    while (m--) {
        a > b ? a >>= 1 : b >>= 1;
    }
    cout << (a > b ? a : b) << endl;
    cout << (a < b ? a : b) << endl;
    return 0;
}
```

**y总代码**

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

int main()
{
    int n;
    scanf("A%d", &n);
    int x = 1189, y = 841;
    while (n -- )
    {
        x /= 2;
        if (x < y) swap(x, y);
    }

    printf("%d\n%d\n", x, y);
    return 0;
}
```

y总处理这种输入的方法也值得学习



## AcWing 4656. 技能升级

https://www.acwing.com/problem/content/4659/

小蓝最近正在玩一款 RPG 游戏。

他的角色一共有 N 个可以加攻击力的技能。

其中第 i 个技能首次升级可以提升 Ai 点攻击力，以后每次升级增加的点数都会减少 Bi。

⌈AiBi⌉（上取整）次之后，再升级该技能将不会改变攻击力。

现在小蓝可以总计升级 M 次技能，他可以任意选择升级的技能和次数。

请你计算小蓝最多可以提高多少点攻击力？

#### 输入格式

输入第一行包含两个整数 N 和 M。

以下 N 行每行包含两个整数 Ai 和 Bi。

#### 输出格式

输出一行包含一个整数表示答案。

#### 数据范围

对于 40% 的评测用例，1≤N,M≤1000
对于 60% 的评测用例，1≤N≤10^4^，1≤M≤10^7^
对于所有评测用例，1≤N≤10^5^，1≤M≤2×10^9^，1≤Ai,Bi≤10^6^

#### 输入样例：

```
3 6
10 5
9 2
8 1
```

#### 输出样例：

```
47
```



![image-20230109223224639](%E5%BA%93/image-20230109223224639.png)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 100010;

int n, m;
int a[N], b[N];

bool check(int mid)
{
    LL res = 0;
    for (int i = 0; i < n; i ++ )
        if (a[i] >= mid)
            res += (a[i] - mid) / b[i] + 1;
    return res >= m;
}

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 0; i < n; i ++ ) scanf("%d%d", &a[i], &b[i]);

    int l = 0, r = 1e6;
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }

    LL res = 0, cnt = 0;
    for (int i = 0; i < n; i ++ )
        if (a[i] >= r)
        {
            int c = (a[i] - r) / b[i] + 1;
            int end = a[i] - (c - 1) * b[i];
            cnt += c;
            res += (LL)(a[i] + end) * c / 2;
        }

    printf("%lld\n", res - (cnt - m) * r);
    return 0;
}
```

**这种思路值得反复学习**



## AcWing 4454. 未初始化警告

https://www.acwing.com/problem/content/4457/

一个未经初始化的变量，里面存储的值可能是任意的。

因此直接使用未初始化的变量，比如将其赋值给另一个变量，并不符合一般的编程逻辑。

代码中出现这种情况，往往是因为遗漏了初始化语句、或是打错了变量名。

对代码中使用了未初始化变量的语句进行检查，可以方便地排查出代码中的一些隐秘 Bug。

考虑一段包含 k 条赋值语句的简单代码。

该段代码最多使用到 n 个变量，分别记作 a1,a2,⋯,an；该段代码使用的常量均记作 a0。

第 i 条（1≤i≤k）赋值语句为 axi=ayi，满足 1≤xi≤n、0≤yi≤n，表示将 ayi 的值赋给变量 axi。

其中 axi 被称为该赋值语句的**左值**，一定是个变量；ayi 被称为**右值**，可以是一个常量或变量。

对于任意一条赋值语句 axi=ayi，如果右值 ayi 是一个变量，则其应该在此之前被初始化过。

具体来说，如果变量 ayi 在前 i−1 条赋值语句中做为**左值**出现过，即存在 j<i 满足 xj=yi（这里无需考虑第 j 条赋值语句本身是否也有右值未初始化的问题），我们就认为在第 i 条赋值语句中 ayi 已被初始化；否则，我们认为该条语句存在右值未初始化的问题。

按照上述规则，试统计给定的代码中，有多少条赋值语句右值未被初始化。

#### 输入格式

输入的第一行包含空格分隔的两个正整数 n、k，分别表示变量的数量和赋值语句的条数。

接下来输入 k 行，其中第 i 行（1≤i≤k）包含空格分隔的两个正整数 xi、yi，表示第 i 条赋值语句。

**纠错**：其实 yi 可以等于 0，所以 yi 不一定是正整数（可参考样例），此为官网题面描述存在问题，特此指出。

#### 输出格式

输出一个整数，表示有右值未被初始化问题的赋值语句条数。

#### 数据范围

50% 的测试数据满足 0<n,k≤1000
全部的测试数据满足 0<n,k≤10^5^，1≤xi≤n1≤xi≤n

#### 输入样例：

```
10 7
1 2
3 3
3 0
3 3
6 2
2 1
8 2
```

#### 输出样例：

```
3
```

#### 样例解释

其中第一、二、五条赋值语句右值未被初始化。



**自己写的**

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

bool st[N];
int n, k;

int main() {
    cin >> n >> k;

    st[0] = true;
    int res = 0;
    for (int i = 0; i < k; i++) {
        int a, b;
        cin >> a >> b;

        if (!st[b]) res++;
        st[a] = true;
    }
    cout << res;
    return 0;
}
```





## AcWing 4509. 归一化处理

https://www.acwing.com/problem/content/4512/

在机器学习中，对数据进行归一化处理是一种常用的技术。

将数据从各种各样分布调整为平均值为 00、方差为 11 的标准分布，在很多情况下都可以有效地加速模型的训练。





#### 输入格式

第一行包含一个整数 n，表示待处理的整数个数。

第二行包含空格分隔的 n 个整数，依次表示 a1,a2,⋯,an。

#### 输出格式

输出共 n 行，每行一个浮点数，依次表示按上述方法归一化处理后的数据 f(a1),f(a2),⋯,f(an)。

如果你输出的每个浮点数与参考结果相比，均满足绝对误差不大于 10^−4^，则该测试点满分，否则不得分。

#### 数据范围

全部的测试数据保证 n,|ai|≤1000，其中 |ai| 表示 ai 的绝对值。
且输入的 n 个整数 a1,a2,⋯,an 满足：方差 D(a)≥1

#### 输入样例：

```
7
-4 293 0 -22 12 654 1000
```

#### 输出样例：

```
-0.7485510379073613
0.04504284674812264
-0.7378629047806881
-0.7966476369773906
-0.7057985054006686
1.0096468614303775
1.9341703768876082
```

#### 样例解释

平均值：a¯≈276.14285714285717
方差：D(a)≈140060.69387755104
标准差：D(a)−−−−√≈374.24683549437134



```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1010;

double a[N];
int n;

int main() {
    cin >> n;

    double sum = 0;
    for (int i = 0; i < n; i++) {
        scanf("%lf", &a[i]);
        sum += a[i];
    }

    sum /= n;

    double d = 0;
    for (int i = 0; i < n; ++i) {
        d += (a[i] - sum) * (a[i] - sum);
    }
    d /= n;

    for (int i = 0; i < n; ++i) printf("%lf\n", (a[i] - sum) / sqrt(d));
    return 0;
}
```





## AcWing 4699. 如此编码

https://www.acwing.com/problem/content/4702/

![image-20230112133747338](%E5%BA%93/image-20230112133747338.png)

#### 输入格式

输入共两行。

第一行包含用空格分隔的两个整数 n 和 m，分别表示题目数量和顿顿老师的神秘数字。

第二行包含用空格分隔的 n 个整数 a1,a2,⋯,an，依次表示每道选择题的选项数目。

#### 输出格式

输出仅一行，包含用空格分隔的 n 个整数 b1,b2,⋯,bn，依次表示每道选择题的正确选项。

#### 数据范围

50% 的测试数据满足：ai 全部等于 2，即每道题均只有两个选项，此时 ci=2i；
全部的测试数据满足：1≤n≤20，ai≥2 且 cn≤10^9^（根据题目描述中的定义 cn 表示全部 ai 的乘积）。

#### 输入样例1：

```
15 32767
2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
```

#### 输出样例1：

```
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
```

#### 输入样例2：

```
4 0
2 3 2 5
```

#### 输出样例2：

```
0 0 0 0
```

#### 输入样例3：

```
7 23333
3 5 20 10 4 3 10
```

#### 输出样例3：

```
2 2 15 7 3 1 0
```

#### 样例3解释

![QQ截图20220930112511.png](%E5%BA%93/19_7ff1f53c40-QQ%E6%88%AA%E5%9B%BE20220930112511.png)

#### 提示

![image-20230112133710019](%E5%BA%93/image-20230112133710019.png)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 25;

int n, m;
int a[N], c[N];

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; ++i) cin >> a[i];

    c[0] = 1;
    for (int i = 1; i <= n; ++i) c[i] = c[i - 1] * a[i];

    for (int i = 0; i < n; ++i) {
        cout << m % c[i + 1] / c[i] << " ";
        m -= m % c[i + 1];
    }
    
    return 0;
}
```



满分做法，背包问题 O(nm), m 是总价格

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 33, M = 300010;

int n, x;
int w[N], f[M];

int main()
{
    scanf("%d%d", &n, &x);

    int sum = 0;
    for (int i = 0; i < n; i ++ )
    {
        scanf("%d", &w[i]);
        sum += w[i];
    }

    int m = sum - x;
    for (int i = 0; i < n; i ++ )
        for (int j = m; j >= w[i]; j -- )
            f[j] = max(f[j], f[j - w[i]] + w[i]);

    printf("%d\n", sum - f[m]);
    return 0;
}
```



70分做法1  二进制枚举 O(n2^n^)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 33;

int n, x;
int w[N];

int main()
{
    scanf("%d%d", &n, &x);
    for (int i = 0; i < n; i ++ ) scanf("%d", &w[i]);

    int res = 1e8;
    for (int i = 0; i < 1 << n; i ++ )
    {
        int sum = 0;
        for (int j = 0; j < n; j ++ )
            if (i >> j & 1)
                sum += w[j];
        if (sum >= x) res = min(res, sum);
    }

    printf("%d\n", res);
    return 0;
}
```



70分做法2 DFS O(2^n^)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 33;

int n, x;
int w[N];
int res = 1e8;

void dfs(int u, int sum)
{
    if (u == n)
    {
        if (sum >= x) res = min(res, sum);
    }
    else
    {
        dfs(u + 1, sum);
        dfs(u + 1, sum + w[u]);
    }
}

int main()
{
    scanf("%d%d", &n, &x);
    for (int i = 0; i < n; i ++ ) scanf("%d", &w[i]);

    dfs(0, 0);

    printf("%d\n", res);
    return 0;
}
```



## AcWing 4510. 寻宝！大冒险！

https://www.acwing.com/problem/content/description/4513/

暑假要到了。

可惜由于种种原因，小 P 原本的出游计划取消。

失望的小 P 只能留在西西艾弗岛上度过一个略显单调的假期……直到……

某天，小 P 获得了一张神秘的藏宝图。

西西艾弗岛上种有 n 棵树，这些树的具体位置记录在一张绿化图上。

简单地说，西西艾弗岛绿化图可以视作一个大小为 (L+1)×(L+1) 的 01 矩阵 A，地图左下角（坐标 (0,0)）和右上角（坐标 (L,L)）分别对应 `A[0][0]` 和 `A[L][L]`。

其中 `A[i][j]=1` 表示坐标 (i,j) 处种有一棵树，`A[i][j]=0` 则表示坐标 (i,j) 处没有树。

换言之，矩阵 A 中有且仅有的 n 个 1 展示了西西艾弗岛上 n 棵树的具体位置。

传说，大冒险家顿顿的宝藏就埋藏在某棵树下。

并且，顿顿还从西西艾弗岛的绿化图上剪下了一小块，制作成藏宝图指示其位置。

具体来说，藏宝图可以看作一个大小为 (S+1)×(S+1) 的 01 矩阵 B（S 远小于 L），对应着 A 中的某一部分。

理论上，绿化图 A 中存在着一处坐标 (x,y)（0≤x,y≤L−S）与藏宝图 B 左下角 (0,0) 相对应，即满足：

对 B 上任意一处坐标 (i,j)（0≤i,j≤S），都有 `A[x+i][y+j]=B[i][j]`。

当上述条件满足时，我们就认为藏宝图 B 对应着绿化图 A 中左下角为 (x,y)、右上角为 (x+S,y+S) 的区域。

实际上，考虑到藏宝图仅描绘了很小的一个范围，满足上述条件的坐标 (x,y) 很可能存在多个。

请结合西西艾弗岛绿化图中 n 棵树的位置，以及小 P 手中的藏宝图，判断绿化图中有多少处坐标满足条件。

**特别地，藏宝图左下角位置一定是一棵树，即 `A[x][y]=B[0][0]=1，表示了宝藏埋藏的位置。**

#### 输入格式

输入的第一行包含空格分隔的三个正整数 n、L 和 S，分别表示西西艾弗岛上树的棵数、绿化图和藏宝图的大小。

由于绿化图尺寸过大，输入数据中仅包含 n 棵树的坐标而非完整的地图；即接下来 n 行每行包含空格分隔的两个整数 x 和 y，表示一棵树的坐标，满足 0≤x,y≤L 且同一坐标不会重复出现。

最后 (S+1) 行输入小 P 手中完整的藏宝图，其中第 i 行（0≤i≤S）包含空格分隔的 (S+1) 个 0 和 1，表示 `B[S−i][0]⋯B[S−i][S]`。

**需要注意**，最先输入的是 `B[S][0]⋯B[S][S]` 一行，`B[0][0]⋯B[0][S]` 一行最后输入。

#### 输出格式

输出一个整数，表示绿化图中有多少处坐标可以与藏宝图左下角对应，即可能埋藏着顿顿的宝藏。

#### 数据范围

40% 的测试数据满足：L≤50
70% 的测试数据满足：L≤2000
全部的测试数据满足：n≤1000、L≤10^9^ 且 S≤50。

#### 输入样例1：

```
5 100 2
0 0
1 1
2 2
3 3
4 4
0 0 1
0 1 0
1 0 0
```

#### 输出样例1：

```
3
```

#### 样例1解释

绿化图上 (0,0)、(1,1) 和 (2,2) 三处均可能埋有宝藏。

#### 输入样例2：

```
5 4 2
0 0
1 1
2 2
3 3
4 4
0 0 0
0 1 0
1 0 0
```

#### 输出样例2：

```
0
```

#### 样例2解释

如果将藏宝图左下角与绿化图 (3,3) 处对应，则藏宝图右上角会超出绿化图边界，对应不成功。



**自己写的**

自己实现了很多功能，使速度加快

```c++
#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;

const int N = 1010;

PII tree[N];
int S[55][55];
int n, l, s;

bool check(int x, int y) {
    int l = 0, r = n - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (tree[mid].first >= x) r = mid;
        else l = mid + 1;
    }
    if (tree[l].first != x) return false;

    int left = l;

    l = 0, r = n - 1;
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (tree[mid].first <= x) l = mid;
        else r = mid - 1;
    }
    int right = l;

    l = left, r = right;
    while (l < r) {
        int mid = l + r + 1 >> 1;
        if (tree[mid].second <= y) l = mid;
        else r = mid - 1;
    }
    if (tree[l].second != y) return false;
    return true;
}

bool cmp(PII a, PII b) {
    if (a.first == b.first) return a.second < b.second;
    return a.first < b.first;
}

int main() {
    cin >> n >> l >> s;

    for (int i = 0; i < n; ++i)
        scanf("%d%d", &tree[i].first, &tree[i].second);

    sort(tree, tree + n, cmp);

    for (int i = s; i >= 0; i--)
        for (int j = 0; j <= s; ++j)
            scanf("%d", &S[i][j]);

    int res = 0;
    for (int k = 0; k < n; ++k) {
        int x = tree[k].first, y = tree[k].second;

        if (x + s > l || y + s > l) continue;

        bool flag = true;
        for (int i = 0; i <= s; ++i) {
            for (int j = 0; j <= s; ++j) {
                if (check(x + i, y + j) != S[i][j]) {
                    flag = false;
                    break;
                }
            }
            if (!flag) break;
        }
        if (flag) res++;
    }

    cout << res;
    return 0;
}
```





## AcWing 3422. 左孩子右兄弟

https://www.acwing.com/problem/content/3425/

对于一棵多叉树，我们可以通过 “左孩子右兄弟” 表示法，将其转化成一棵二叉树。

如果我们认为每个结点的子结点是无序的，那么得到的二叉树可能不唯一。

换句话说，每个结点可以选任意子结点作为左孩子，并按任意顺序连接右兄弟。

给定一棵包含 N 个结点的多叉树，结点从 1 至 N 编号，其中 1 号结点是根，每个结点的父结点的编号比自己的编号小。

请你计算其通过 “左孩子右兄弟” 表示法转化成的二叉树，高度最高是多少。

注：只有根结点这一个结点的树高度为 0。

例如如下的多叉树：

![QQ截图20210426100551.png](%E5%BA%93/19_f21206c5a6-QQ%E6%88%AA%E5%9B%BE20210426100551.png)

可能有以下 3 种 (这里只列出 3 种，并不是全部) 不同的 “左孩子右兄弟”表示：

![QQ截图20210426100638.png](%E5%BA%93/19_0cc050caa6-QQ%E6%88%AA%E5%9B%BE20210426100638.png)

其中最后一种高度最高，为 4。

#### 输入格式

输入的第一行包含一个整数 N。

以下 N−1 行，每行包含一个整数，依次表示 2 至 N 号结点的父结点编号。

#### 输出格式

输出一个整数表示答案。

#### 数据范围

对于 30% 的评测用例，1≤N≤20
对于所有评测用例，1≤N≤10^5^

#### 输入样例：

```
5
1
1
1
2
```

#### 输出样例：

```
4
```



```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int h[N], ne[N], idx, e[N];
int n;

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int dfs(int x) {
    int cnt = 0, hmax = 0;

    for (int i = h[x]; i != -1; i = ne[i]) {
        int j = e[i];
        hmax = max(dfs(j), hmax);
        cnt++;
    }

    return cnt + hmax;
}

int main() {
    cin >> n;

    memset(h, -1, sizeof h);

    for (int i = 2; i <= n; ++i) {
        int a;
        scanf("%d", &a);
        add(a, i);
    }

    cout << dfs(1);

    return 0;
}
```



## AcWing 4728. 乘方

https://www.acwing.com/problem/content/4731/

小文同学刚刚接触了信息学竞赛，有一天她遇到了这样一个题：给定正整数 a和 b，求 a^b^ 的值是多少。

a^b^ 即 b 个 a 相乘的值，例如 2^3^ 即为 3 个 2 相乘，结果为 2×2×2=8

“简单！”小文心想，同时很快就写出了一份程序，可是测试时却出现了错误。

小文很快意识到，她的程序里的变量都是 int 类型的。

在大多数机器上，int 类型能表示的最大数为 2^31^−1，因此只要计算结果超过这个数，她的程序就会出现错误。

由于小文刚刚学会编程，她担心使用 int 计算会出现问题。

因此她希望你在 a^b^ 的值超过 10^9^ 时，输出一个 -1 进行警示，否则就输出正确的 a^b^ 的值。

然而小文还是不知道怎么实现这份程序，因此她想请你帮忙。

#### 输入格式

输入共一行，两个正整数 a,b。

#### 输出格式

输出共一行，如果 a^b^ 的值不超过 10^9^，则输出 a^b^ 的值，否则输出 -1。

#### 数据范围

对于 10% 的数据，保证 b=1
对于 30% 的数据，保证 b≤2
对于 60% 的数据，保证 b≤30，a^b^≤10^18^
对于 100% 的数据，保证 1≤a,b≤10^9^

#### 输入样例1：

```
10 9
```

#### 输出样例1：

```
1000000000
```

#### 输入样例2：

```
23333 66666
```

#### 输出样例2：

```
‐1
```



```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;

int main() {
    int a, b;

    cin >> a >> b;

    if (a == 1) {
        cout << a << endl;
        return 0;
    }

    LL sum = a;
    for (int i = 2; i <= b; ++i) {
        sum *= a;
        if (sum > 1e9) break;
    }
    
    if (sum > 1e9) puts("-1");
    else cout << sum << endl;
    return 0;
}
```





## AcWing 4729. 解密

https://www.acwing.com/problem/content/4732/

![image-20230120225914060](%E5%BA%93/image-20230120225914060.png)

#### 数据范围

以下记 m=n−e×d+2

保证对于 100% 的数据，1≤k≤10^5^，对于任意的 1≤i≤k，1≤ni≤10^18^，1≤ei×di≤10^18^，1≤m≤10^9^。

![QQ截图20221107141520.png](%E5%BA%93/19_8ef3fc985e-QQ%E6%88%AA%E5%9B%BE20221107141520.png)

#### 输入样例：

```
10
770 77 5
633 1 211
545 1 499
683 3 227
858 3 257
723 37 13
572 26 11
867 17 17
829 3 263
528 4 109
```

#### 输出样例：

```
2 385
NO
NO
NO
11 78
3 241
2 286
NO
NO
6 88
```



```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;

int main() {
    int k;
    cin >> k;
    while (k--) {
        LL e, d, n;
        scanf("%lld%lld%lld", &n, &d, &e);

        LL m = n - e * d + 2;
        LL dt = m * m - 4 * n;
        LL r = sqrt(m * m - 4 * n);

        if (dt < 0 || r * r != dt) puts("NO");
        else printf("%lld %lld\n", (m - r) / 2, (m + r) / 2);
    }
    return 0;
}
```

![image-20230120230141626](%E5%BA%93/image-20230120230141626.png)

