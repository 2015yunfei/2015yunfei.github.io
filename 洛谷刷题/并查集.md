# 并查集【模板】

## 题目描述

如题，现在有一个并查集，你需要完成合并和查询操作。

## 输入格式

第一行包含两个整数 $N,M$ ,表示共有 $N$ 个元素和 $M$ 个操作。

接下来 $M$ 行，每行包含三个整数 $Z_i,X_i,Y_i$ 。

当 $Z_i=1$ 时，将 $X_i$ 与 $Y_i$ 所在的集合合并。

当 $Z_i=2$ 时，输出 $X_i$ 与 $Y_i$ 是否在同一集合内，是的输出 
 `Y` ；否则输出 `N` 。

## 输出格式

对于每一个 $Z_i=2$ 的操作，都有一行输出，每行包含一个大写字母，为 `Y` 或者 `N` 。

## 样例 #1

### 样例输入 #1

```
4 7
2 1 2
1 1 2
2 1 2
1 3 4
2 1 4
1 2 3
2 1 4
```

### 样例输出 #1

```
N
Y
N
Y
```

## 提示

对于 $30\%$ 的数据，$N \le 10$，$M \le 20$。

对于 $70\%$ 的数据，$N \le 100$，$M \le 10^3$。

对于 $100\%$ 的数据，$1\le N \le 10^4$，$1\le M \le 2\times 10^5$，$1 \le X_i, Y_i \le N$，$Z_i \in \{ 1, 2 \}$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e4 + 10;

int s[N];
int n, m;

int find(int x) {
    if (s[x] != x) s[x] = find(s[x]);
    return s[x];
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) s[i] = i;

    while (m--) {
        int a, b, c;
        cin >> a >> b >> c;

        if (a == 1) {
            s[find(b)] = find(c);
        } else {
            if (find(b) == find(c)) puts("Y");
            else puts("N");
        }
    }

    return 0;
} 
```



# 亲戚

## 题目背景

若某个家族人员过于庞大，要判断两个是否是亲戚，确实还很不容易，现在给出某个亲戚关系图，求任意给出的两个人是否具有亲戚关系。

## 题目描述

规定：$x$ 和 $y$ 是亲戚，$y$ 和 $z$ 是亲戚，那么 $x$ 和 $z$ 也是亲戚。如果 $x$，$y$ 是亲戚，那么 $x$ 的亲戚都是 $y$ 的亲戚，$y$ 的亲戚也都是 $x$ 的亲戚。

## 输入格式

第一行：三个整数 $n,m,p$，（$n,m,p \le 5000$），分别表示有 $n$ 个人，$m$ 个亲戚关系，询问 $p$ 对亲戚关系。

以下 $m$ 行：每行两个数 $M_i$，$M_j$，$1 \le M_i,~M_j\le N$，表示 $M_i$ 和 $M_j$ 具有亲戚关系。

接下来 $p$ 行：每行两个数 $P_i,P_j$，询问 $P_i$ 和 $P_j$ 是否具有亲戚关系。

## 输出格式

$p$ 行，每行一个 `Yes` 或 `No`。表示第 $i$ 个询问的答案为“具有”或“不具有”亲戚关系。

## 样例 #1

### 样例输入 #1

```
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6
```

### 样例输出 #1

```
Yes
Yes
No
```



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 5050;

int s[N];
int n, m, p;

int find(int x) {
    if (s[x] != x) s[x] = find(s[x]);
    return s[x];
}

int main() {
    cin >> n >> m >> p;
    for (int i = 1; i <= n; i++) s[i] = i;

    while (m--) {
        int a, b;
        cin >> a >> b;
        s[find(b)] = find(a);
    }

    while (p--) {
        int b, c;
        cin >> b >> c;
        if (find(b) == find(c)) puts("Yes");
        else puts("No");
    }

    return 0;
}
```



# 一中校运会之百米跑

## 题目背景

在一大堆秀恩爱的 \*\* 之中，来不及秀恩爱的苏大学神踏着坚定（？）的步伐走向了 $100$ 米跑的起点。这时苏大学神发现，百米赛跑的参赛同学实在是太多了，连体育老师也忙不过来。这时体育老师发现了身为体育委员的苏大学神，便来找他帮忙。

可是苏大学神需要热身，不然跑到一半就会抽（筋）、于是他就找到了你。。。如果你帮助体育老师解决了问题，老师就会给你 $5$ 个积分。

## 题目描述

假设一共有 $N$（$2\leq N\leq 2\times 10^4$）个参赛选手。（尼玛全校学生都没这么多吧）

老师会告诉你这 $N$ 个选手的名字。

接着会告诉你 $M$（$1\leq M\leq 10^6$）句话，即告诉你学生 A 与学生 B 在同一个组里。

如果学生 A 与学生 B 在同一组里，学生 B 与学生 C 也在同一组里，就说明学生 A 与学生 C 在同一组。

然后老师会问你 $K$（$1\leq K\leq 10^6$）句话，即学生 X 和学生 Y 是否在同一组里。

若是则输出 `Yes.`，否则输出 `No.`。

## 输入格式

第一行输入 $N$ 和 $M$。

接下来 $N$ 行输入每一个同学的名字。

再往下 $M$ 行每行输入两个名字，且保证这两个名字都在上面的 $N$ 行中出现过，表示这两个参赛选手在同一个组里。

再来输入 $K$。

接下来输入 $K$ 个体育老师的询问。

## 输出格式

对于每一个体育老师的询问，输出 `Yes.` 或 `No.`。

## 样例 #1

### 样例输入 #1

```
10 6
Jack
Mike
ASDA
Michel
brabrabra
HeHe
HeHE
papapa
HeY
Obama
Jack Obama
HeHe HeHE
brabrabra HeHe
Obama ASDA
papapa Obama
Obama HeHE
3
Mike Obama
HeHE Jack
papapa brabrabra
```

### 样例输出 #1

```
No.
Yes.
Yes.
```



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 2e4 + 10, mod = 13331;

int s[N];
int n, m;
map<string, int> h;

int find(int x) {
    if (s[x] != x) s[x] = find(s[x]);
    return s[x];
}

int main() {
    cin >> n >> m;

    for (int i = 1; i <= n; i++) {
        string y;
        cin >> y;
        h.insert({y, i});
        s[i] = i;
    }

    while (m--) {
        string y, t;
        cin >> y >> t;

        s[find(h[y])] = find(h[t]);
    }

    int p;
    cin >> p;
    while (p--) {
        string y, t;
        cin >> y >> t;

        if (find(h[y]) == find(h[t])) puts("Yes.");
        else puts("No.");
    }

    return 0;
} 
```

题目背景和题目描述非常直接地告诉我们：

这就是个并查集模板，只不过改成了字符串

因此我们的问题就成了如何处理字符串

当然，可以用结构体，结构体的成员包含编号和名字

但是，还有一个更好用的东西：STL中的 **map**

直接**建立一个由字符串到字符串的映射**代替数组

然后把并查集的模板粘上去改一改就成了



什么是并查集？并查集，是用来求两者是否同属一个单位的一种思路。**同时可以利用并查集来维护一些额外的信息。**



> 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。这一类问题近几年来反复出现在信息学的国际国内赛题中，其特点是看似并不复杂，但数据量极大，若用正常的数据结构来描述的话，往往在空间上过大，计算机无法承受；即使在空间上勉强通过，运行的时间复杂度也极高，根本就不可能在比赛规定的运行时间（1～3秒）内计算出试题需要的结果，只能用并查集来描述。



> 并查集是一种树型的数据结构，用于处理一些不相交集合（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。 —百度百科



# 家谱

## 题目背景

现代的人对于本家族血统越来越感兴趣。

## 题目描述

给出充足的父子关系，请你编写程序找到某个人的最早的祖先。

## 输入格式

输入由多行组成，首先是一系列有关父子关系的描述，其中每一组父子关系中父亲只有一行，儿子可能有若干行，用 `#name` 的形式描写一组父子关系中的父亲的名字，用 `+name` 的形式描写一组父子关系中的儿子的名字；接下来用 `?name` 的形式表示要求该人的最早的祖先；最后用单独的一个 `$` 表示文件结束。

## 输出格式

按照输入文件的要求顺序，求出每一个要找祖先的人的祖先，格式为：本人的名字 $+$ 一个空格 $+$ 祖先的名字 $+$ 回车。

## 样例 #1

### 样例输入 #1

```
#George
+Rodney
#Arthur
+Gareth
+Walter
#Gareth
+Edward
?Edward
?Walter
?Rodney
?Arthur
$
```

### 样例输出 #1

```
Edward Arthur
Walter Arthur
Rodney George
Arthur Arthur
```

## 提示

规定每个人的名字都有且只有 $6$ 个字符，而且首字母大写，且没有任意两个人的名字相同。最多可能有 $10^3$ 组父子关系，总人数最多可能达到 $5 \times 10^4$ 人，家谱中的记载不超过 $30$ 代。



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 5e4 + 10;

int s[N];
map<string, int> h;

int find(int x) {
    if (s[x] != x) s[x] = find(s[x]);
    return s[x];
}

int main() {
    for (int i = 1; i < N; i++) s[i] = i;
    int i = 1;
    string sonname, faname;
    char w;
    while (1) {
        cin >> w;
        if (w == '$') break;
        if (w == '#') {
            cin >> faname;
            if (h.find(faname) == h.end()) h[faname] = i++;

        } else if (w == '+') {
            cin >> sonname;
            if (h.find(sonname) == h.end()) h[sonname] = i++;
            s[find(h[sonname])] = find(h[faname]);
        } else {
            string q;
            cin >> q;
            cout << q << " ";
            for (auto t: h) {
                if (t.second == find(h[q])) {
                    cout << t.first << endl;
                    break;
                }
            }
        }
    }
    return 0;
}
```



这个题提醒我一定**不要忘记初始化 s 数组**

```c++
for (int i = 1; i < N; i++) s[i] = i;
```

不然后面的语句

```c++
s[find(h[sonname])] = find(h[faname]);
```

毫无意义，只是在不断赋值0 罢了



**另外一种仅仅使用 Map ，不需要转化成序号的做法**

太妙了，非常值得学习

```c++
#include<cstdio>
#include<iostream>
#include<map>

using namespace std;
map<string, string> p;

string find(string x) {
    if (x != p[x]) p[x] = find(p[x]);
    return p[x];
}

string s, s1;

int main() {
    char ch;
    cin >> ch;
    while (ch != '$') {
        cin >> s;
        if (ch == '#') {
            s1 = s;
            if (p[s] == "") p[s] = s;
        } else if (ch == '+') p[s] = s1;
        else
            cout << s << ' ' << find(s) << endl;

        cin >> ch;
    }
    return 0;
}
```



# [NOI2002] 银河英雄传说

## 题目背景

公元 $5801$ 年，地球居民迁至金牛座 $\alpha$ 第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。

宇宙历 $799$ 年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。

## 题目描述

杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成 $30000$ 列，每列依次编号为 $1, 2,\ldots ,30000$。之后，他把自己的战舰也依次编号为 $1, 2, \ldots , 30000$，让第 $i$ 号战舰处于第 $i$ 列，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。合并指令为 `M i j`，含义为第 $i$ 号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第 $j$ 号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。  

然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。

在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令：`C i j`。该指令意思是，询问电脑，杨威利的第 $i$ 号战舰与第 $j$ 号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。

作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。

## 输入格式

第一行有一个整数 $T$（$1 \le T \le 5 \times 10^5$），表示总共有 $T$ 条指令。

以下有 $T$ 行，每行有一条指令。指令有两种格式：

1. `M i j`：$i$ 和 $j$ 是两个整数（$1 \le i,j \le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第 $i$ 号战舰与第 $j$ 号战舰不在同一列。

2. `C i j`：$i$ 和 $j$ 是两个整数（$1 \le i,j \le 30000$），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。

## 输出格式

依次对输入的每一条指令进行分析和处理：

- 如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息。
- 如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 $i$ 号战舰与第 $j$ 号战舰之间布置的战舰数目。如果第 $i$ 号战舰与第 $j$ 号战舰当前不在同一列上，则输出 $-1$。

## 样例 #1

### 样例输入 #1

```
4
M 2 3
C 1 2
M 2 4
C 4 2
```

### 样例输出 #1

```
-1
1
```

## 提示

### 样例解释

战舰位置图：表格中阿拉伯数字表示战舰编号。

![](image/并查集.image/30avp4af.png)

**带权并查集**

```C++
#include <bits/stdc++.h>

using namespace std;
const int N = 30010;
int n, t, p[N], d[N], sz[N]; //根节点到根节点的距离d数组

int find(int x) {
    if (p[x] != x) {
        int rt = find(p[x]);
        d[x] += d[p[x]];
        p[x] = rt;
    }
    return p[x];
}

int main() {
    n = 30010;
    for (int i = 1; i <= n; ++i) p[i] = i, sz[i] = 1;
    cin >> t;
    while (t--) {
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        int ra = find(a), rb = find(b);
        if (op[0] == 'M') {
            if (ra != rb) {
                d[ra] += sz[rb];
                sz[rb] += sz[ra];
                p[ra] = rb;
            }
        } else {
            if (ra != rb) puts("-1");
            else printf("%d\n", max(0, abs(d[a] - d[b]) - 1));
        }
    }
    return 0;
}
```



# 修复公路

## 题目背景

A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。

## 题目描述

给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。

## 输入格式

第 $1$ 行两个正整数 $N,M$。

下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间t时能修复完成这条公路。

## 输出格式

如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。

## 样例 #1

### 样例输入 #1

```
4 4
1 2 6
1 3 4
1 4 5
4 2 3
```

### 样例输出 #1

```
5
```

## 提示

$1\leq x, y\leq N \le 10 ^ 3$，$1\leq M, t \le 10 ^ 5$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1010, M = 1e5 + 10;
int n, m, p[N];

struct node {
    int x, y, t;

    bool operator<(const node &g) const {
        return t < g.t;
    }
} s[M];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> s[i].x >> s[i].y >> s[i].t;
    }
    sort(s, s + m);
    int sum = n;
    int ans = 0;
    for (int i = 1; i <= n; ++i) p[i] = i;
    for (int i = 0; i < m; ++i) {
        if (find(s[i].x) == find(s[i].y)) continue;
        sum--;
        ans = s[i].t;
        p[find(s[i].x)] = find(s[i].y);
    }
    if (sum == 1) cout << ans << endl;
    else cout << -1 << endl;
    return 0;
}
```



# 朋友

## 题目背景

小明在 A 公司工作，小红在 B 公司工作。

## 题目描述

这两个公司的员工有一个特点：一个公司的员工都是同性。

A 公司有 $N$ 名员工，其中有 $P$ 对朋友关系。B 公司有 $M$ 名员工，其中有 $Q$ 对朋友关系。朋友的朋友一定还是朋友。

每对朋友关系用两个整数 $(X_i,Y_i)$ 组成，表示朋友的编号分别为 $X_i,Y_i$。男人的编号是正数，女人的编号是负数。小明的编号是 $1$，小红的编号是 $-1$。

大家都知道，小明和小红是朋友，那么，请你写一个程序求出两公司之间，通过小明和小红认识的人最多一共能配成多少对情侣（包括他们自己）。

## 输入格式

输入的第一行，包含 $4$ 个空格隔开的正整数 $N,M,P,Q$。

之后 $P$ 行，每行两个正整数 $X_i,Y_i$。

之后 $Q$ 行，每行两个负整数 $X_i,Y_i$。

## 输出格式

输出一行一个正整数，表示通过小明和小红认识的人最多一共能配成多少对情侣（包括他们自己）。

## 样例 #1

### 样例输入 #1

```
4 3 4 2
1 1
1 2
2 3
1 3
-1 -2
-3 -3
```

### 样例输出 #1

```
2
```

## 提示

对于 $30 \%$ 的数据，$N,M \le 100$，$P,Q \le 200$；

对于 $80 \%$ 的数据，$N,M \le 4 \times 10^3$，$P,Q \le 10^4$；

对于 $100 \%$ 的数据，$N,M \le 10^4$，$P,Q \le 2 \times 10^4$。

**扩展域并查集**

![image-20231123181622064](image/并查集.image/image-20231123181622064.png)

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e4 + 10;
int n, m, pp, q, p[N * 2];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m >> pp >> q;
    for (int i = 1; i <= N * 2 - 1; ++i) p[i] = i;
    p[1] = find(N * 2 - 1);
    for (int i = 0; i < pp; ++i) {
        int x, y;
        cin >> x >> y;
        if (x < 0) x += N * 2;
        if (y < 0) y += N * 2;
        p[find(x)] = find(y);
    }

    for (int i = 0; i < q; ++i) {
        int x, y;
        cin >> x >> y;
        if (x < 0) x += N * 2;
        if (y < 0) y += N * 2;
        p[find(x)] = find(y);
    }
    int man = 0, woman = 0;
    for (int i = 1; i <= N; ++i) {
        if (p[find(i)] == p[find(1)]) man++;
    }
    for (int i = N; i <= N * 2 - 1; ++i) {
        if (p[find(i)] == p[find(N * 2 - 1)]) woman++;
    }
    cout << min(man, woman) << endl;
    return 0;
}
```



# [BOI2003] 团伙

## 题目描述

现在有 $n$ 个人，他们之间有两种关系：朋友和敌人。我们知道：

- 一个人的朋友的朋友是朋友
- 一个人的敌人的敌人是朋友

现在要对这些人进行组团。两个人在一个团体内当且仅当这两个人是朋友。请求出这些人中最多可能有的团体数。

## 输入格式

第一行输入一个整数 $n$ 代表人数。

第二行输入一个整数 $m$ 表示接下来要列出 $m$ 个关系。

接下来 $m$ 行，每行一个字符 $opt$ 和两个整数 $p,q$，分别代表关系（朋友或敌人），有关系的两个人之中的第一个人和第二个人。其中 $opt$ 有两种可能：

- 如果 $opt$ 为 `F`，则表明 $p$ 和 $q$ 是朋友。
- 如果 $opt$ 为 `E`，则表明 $p$ 和 $q$ 是敌人。

## 输出格式

一行一个整数代表最多的团体数。

## 样例 #1

### 样例输入 #1

```
6
4
E 1 4
F 3 5
F 4 6
E 1 2
```

### 样例输出 #1

```
3
```

## 提示

对于 $100\%$ 的数据，$2 \le n \le 1000$，$1 \le m \le 5000$，$1 \le p,q \le n$。

**扩展域并查集**

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 2010;
int n, p[N], m;

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    for (int i = 0; i <= 2 * n; ++i) p[i] = i;
    while (m--) {
        string s;
        int a, b;
        cin >> s >> a >> b;
        if (s == "E") {
            p[find(a + n)] = find(b);
            p[find(b + n)] = find(a);
        } else {
            p[find(a)] = find(b);
        }
    }
    int cnt = 0;
    for (int i = 1; i <= n; ++i) if (p[i] == i) cnt++;
    cout << cnt;
    return 0;
} 
```

本质是拓展域并查集，注意一定要和实际意义紧密贴合，具体看注释



# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。

## 输入格式

第一行两个整数，$N,K$，表示有 $N$ 个动物，$K$ 句话。

第二行开始每行一句话（按照题目要求，见样例）

## 输出格式

一行，一个整数，表示假话的总数。

## 样例 #1

### 样例输入 #1

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 样例输出 #1

```
3
```

## 提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。

**扩展域并查集**

![image-20231123183116119](image/并查集.image/image-20231123183116119.png)

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 5e4 + 10;
int n, k, p[N * 3];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

bool same(int x, int y) {
    return find(x) == find(y);
}

void uni(int x, int y) {
    int xx = find(x);
    int yy = find(y);
    if (xx != yy) p[xx] = yy;
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n * 3; ++i) p[i] = i;
    int cnt = 0;
    while (k--) {
        int d, x, y;
        scanf("%d%d%d", &d, &x, &y);
        if (x > n || y > n) {
            cnt++;
            continue;
        }
        if (d == 1) {
            if (same(x, y + n) || same(x, y + 2 * n)) {
                cnt++;
                continue;
            }
            uni(x, y);
            uni(x + n, y + n);
            uni(x + 2 * n, y + 2 * n);
        } else {
            if (same(x, y) || same(x, y + n)) {
                cnt++;
                continue;
            }
            uni(x, y + 2 * n);
            uni(x + n, y);
            uni(x + 2 * n, y + n);
        }
    }
    cout << cnt;
    return 0;
}
```



# 村村通

## 题目描述

某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 "村村通工程" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？

## 输入格式

输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。

注意：两个城市间可以有多条道路相通。

**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**

## 输出格式

对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。

## 样例 #1

### 样例输入 #1

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

### 样例输出 #1

```
1
0
2
998
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n < 1000$ 。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1010;
int s[N];

int find(int x) {
    if (s[x] != x) s[x] = find(s[x]);
    return s[x];
}

int main() {
    while (1) {
        int n, m;
        cin >> n >> m;
        if (!n) break;
        for (int i = 1; i <= n; ++i) s[i] = i;

        int a, b;
        for (int k = 0; k < m; ++k) {
            scanf("%d%d", &a, &b);
            s[find(a)] = find(b);
        }

        int res = 0;
        for (int i = 1; i <= n; ++i) if (s[i] == i) res++;
        cout << res - 1 << endl;
    }
    return 0;
}
```

就是寻找有多少个连通图，答案就是连通图的数量减去一。



# [CEOI1999] Parity Game

## 题目描述

Alice 和 Bob 在玩一个游戏：他写一个由 $0$ 和 $1$ 组成的序列。Alice 选其中的一段（比如第 $3$ 位到第 $5$ 位），问他这段里面有奇数个 $1$ 还是偶数个 $1$。Bob 回答你的问题，然后 Alice 继续问。Alice 要检查 Bob 的答案，指出在 Bob 的第几个回答一定有问题。有问题的意思就是存在一个 $01$ 序列满足这个回答前的所有回答，而且不存在序列满足这个回答前的所有回答及这个回答。

## 输入格式

第 $1$ 行一个整数 $n$，是这个 $01$ 序列的长度。

第 $2$ 行一个整数 $m$，是问题和答案的个数。

第 $3$ 行开始是问题和答案，每行先有两个整数，表示你询问的段的开始位置和结束位置。然后是 Bob 的回答。`odd`表示有奇数个 $1$，`even` 表示有偶数个 $1$。

## 输出格式

输出一行，一个数 $x$，表示存在一个 $01$ 序列满足第 $1$ 到第 $x$ 个回答，但是不存在序列满足第 $1$ 到第 $x+1$ 个回答。如果所有回答都没问题，你就输出所有回答的个数。

## 样例 #1

### 样例输入 #1

```
10
5
1 2 even
3 4 odd
5 6 even
1 6 even
7 10 odd
```

### 样例输出 #1

```
3
```

## 提示

对于 $100\%$ 的数据，$1 \le  n \leq 10^9$，$m \leq 5 \times 10^3$。

**扩展域并查集加上了离散化**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 40010, Base = N / 2;

int n, m;
int p[N];
unordered_map<int, int> S;

int get(int x) {
    if (S.count(x) == 0) S[x] = ++n;
    return S[x];
}

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    n = 0;

    for (int i = 0; i < N; i++) p[i] = i;

    int res = m;
    for (int i = 1; i <= m; i++) {
        int a, b;
        string type;
        cin >> a >> b >> type;
        a = get(a - 1), b = get(b);

        if (type == "even") {
            if (find(a + Base) == find(b)) {
                res = i - 1;
                break;
            }
            p[find(a)] = find(b);
            p[find(a + Base)] = find(b + Base);
        } else {
            if (find(a) == find(b)) {
                res = i - 1;
                break;
            }
            p[find(a + Base)] = find(b);
            p[find(a)] = find(b + Base);
        }
    }
    cout << res << endl;
    return 0;
}
```

![image-20231124142610203](image/并查集.image/image-20231124142610203.png)



# 搭配购买

## 题目描述

明天就是母亲节了，电脑组的小朋友们在忙碌的课业之余挖空心思想着该送什么礼物来表达自己的心意呢？听说在某个网站上有卖云朵的，小朋友们决定一同前往去看看这种神奇的商品，这个店里有 $n$ 朵云，云朵已经被老板编号为 $1,2,3,...,n$，并且每朵云都有一个价值，但是商店的老板是个很奇怪的人，他会告诉你一些云朵要搭配起来买才卖，也就是说买一朵云则与这朵云有搭配的云都要买，电脑组的你觉得这礼物实在是太新奇了，但是你的钱是有限的，所以你肯定是想用现有的钱买到尽量多价值的云。

## 输入格式

第一行输入三个整数，$n,m,w$，表示有 $n$ 朵云，$m$ 个搭配和你现有的钱的数目。

第二行至 $n+1$ 行，每行有两个整数， $c_i,d_i$，表示第 $i$ 朵云的价钱和价值。

第 $n+2$ 至 $n+1+m$ 行 ，每行有两个整数 $u_i,v_i$。表示买第 $u_i$ 朵云就必须买第 $v_i$ 朵云,同理，如果买第 $v_i$ 朵就必须买第 $u_i$ 朵。

## 输出格式

一行，表示可以获得的最大价值。

## 样例 #1

### 样例输入 #1

```
5 3 10
3 10
3 10
3 10
5 100
10 1
1 3
3 2
4 2
```

### 样例输出 #1

```
1
```

## 提示

- 对于 $30\%$ 的数据，满足 $1 \le n \le 100$；
- 对于 $50\%$ 的数据，满足 $1 \le n, w \le 10^3$，$1 \le m \le 100$；
- 对于 $100\%$ 的数据，满足 $1 \le n, w \le 10^4$，$0 \le m \le 5 \times 10^3$。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 10010;
int n, m, vol, p[N], f[N], v[N], w[N];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m >> vol;
    for (int i = 0; i <= n; ++i) p[i] = i;
    for (int i = 1; i <= n; ++i) cin >> v[i] >> w[i];
    while (m--) {
        int a, b;
        cin >> a >> b;
        int pa = find(a), pb = find(b);
        if (pa != pb) {
            v[pb] += v[pa];
            w[pb] += w[pa];
            p[pa] = pb;
        }
    }

    for (int i = 1; i <= n; ++i) {
        if (p[i] == i) {
            for (int j = vol; j >= v[i]; --j) {
                f[j] = max(f[j], f[j - v[i]] + w[i]);
            }
        }
    }
    cout << f[vol] << endl;
    return 0;
}
```

我的第一印象：**01背包**。

商店老板告诉我们买一朵云则与这朵云有搭配的云都要买。由此，我们可以想到另一个算法：**并查集**。



# [NOI2015] 程序自动分析

## 题目描述

在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设 $x_1,x_2,x_3,\cdots$ 代表程序中出现的变量，给定 $n$ 个形如 $x_i=x_j$ 或 $x_i\neq x_j$ 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：$x_1=x_2,x_2=x_3,x_3=x_4,x_4\neq x_1$，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

## 输入格式

输入的第一行包含一个正整数 $t$，表示需要判定的问题个数。注意这些问题之间是相互独立的。

对于每个问题，包含若干行：

第一行包含一个正整数 $n$，表示该问题中需要被满足的约束条件个数。接下来 $n$ 行，每行包括三个整数 $i,j,e$，描述一个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 $e=1$，则该约束条件为 $x_i=x_j$。若$e=0$，则该约束条件为 $x_i\neq x_j$。

## 输出格式

输出包括 $t$ 行。

输出文件的第 $k$ 行输出一个字符串 `YES` 或者 `NO`（字母全部大写），`YES` 表示输入中的第 $k$ 个问题判定为可以被满足，`NO` 表示不可被满足。

## 样例 #1

### 样例输入 #1

```
2
2
1 2 1
1 2 0
2
1 2 1
2 1 1
```

### 样例输出 #1

```
NO
YES
```

## 样例 #2

### 样例输入 #2

```
2
3
1 2 1
2 3 1
3 1 1
4
1 2 1
2 3 1
3 4 1
1 4 0
```

### 样例输出 #2

```
YES
NO
```

## 提示

【样例解释1】

在第一个问题中，约束条件为：$x_1=x_2,x_1\neq x_2$。这两个约束条件互相矛盾，因此不可被同时满足。

在第二个问题中，约束条件为：$x_1=x_2,x_1 = x_2$。这两个约束条件是等价的，可以被同时满足。

【样例说明2】

在第一个问题中，约束条件有三个：$x_1=x_2,x_2= x_3,x_3=x_1$。只需赋值使得 $x_1=x_2=x_3$，即可同时满足所有的约束条件。

在第二个问题中，约束条件有四个：$x_1=x_2,x_2= x_3,x_3=x_4,x_4\neq x_1$。由前三个约束条件可以推出 $x_1=x_2=x_3=x_4$，然而最后一个约束条件却要求 $x_1\neq x_4$，因此不可被满足。

【数据范围】

![](image/并查集.image/1503.png)

注：实际上 $n\le 10^6$ 。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 200010;
int n, m;
int p[N];
unordered_map<int, int> S;

struct Query {
    int x, y, e;
} query[N];

int get(int x) {
    if (S.count(x) == 0) S[x] = ++n;
    return S[x];
}

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        n = 0;
        S.clear();
        scanf("%d", &m);
        for (int i = 0; i < m; i++) {
            int x, y, e;
            scanf("%d%d%d", &x, &y, &e);
            query[i] = {get(x), get(y), e};// 离散化
        }

        for (int i = 1; i <= n; i++) p[i] = i;

        // 合并所有相等约束条件
        for (int i = 0; i < m; i++)
            if (query[i].e == 1) {
                int pa = find(query[i].x), pb = find(query[i].y);
                p[pa] = pb;
            }

        // 检查所有不等条件
        bool has_conflict = false;
        for (int i = 0; i < m; i++)
            if (query[i].e == 0) {
                int pa = find(query[i].x), pb = find(query[i].y);
                if (pa == pb) {
                    has_conflict = true;
                    break;
                }
            }

        if (has_conflict) puts("NO");
        else puts("YES");
    }

    return 0;
}
```

是离散化 + 并查集

先排序，把所有e=1的操作放在前面，然后再进行e=0的操作，在进行e=1的操作的时候，我们只要把它约束的两个变量放在同一个集合里面即可。在e=0，即存在一条不相等的约束条件，对于它约束的两个变量，如果在一个集合里面，那就不可能满足！如不相等的约束条件都满足，那就YES。

因为数据范围过大，所以需要离散化

先合并所有相等约束条件，再检查所有不等条件

- unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。
- key值应该是唯一的，key和value的数据类型可以不相同。
- unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。
- unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低。
- 可以使用[]操作符来访问key值对应的value值。



unordered_map的简单使用

```c++
std::unordered_map<std::string, std::int> umap; //定义

umap.insert(Map::value_type("test", 1));//增加

//根据key删除,如果没找到n=0
auto n = umap.erase("test")   //删除

auto it = umap.find(key) //改
if(it != umap.end()) 
    it->second = new_value; 


//map中查找x是否存在
umap.find(x) != map.end()//查
//或者
umap.count(x) != 0
```



# [蓝桥杯 2020 省 AB1] 网络分析

## 题目描述

小明正在做一个网络实验。

他设置了 $n$ 台电脑，称为节点，用于收发和存储数据。

初始时，所有节点都是独立的，不存在任何连接。

小明可以通过网线将两个节点连接起来，连接后两个节点就可以互相通信了。两个节点如果存在网线连接，称为相邻。

小明有时会测试当时的网络，他会在某个节点发送一条信息，信息会发送到每个相邻的节点，之后这些节点又会转发到自己相邻的节点，直到所有直接或间接相邻的节点都收到了信息。所有发送和接收的节点都会将信息存储下来。一条信息只存储一次。

给出小明连接和测试的过程，请计算出每个节点存储信息的大小。

## 输入格式

输入的第一行包含两个整数 $n$，$m$，分别表示节点数量和操作数量。节点从 $1$ 至 $n$ 编号。
 
接下来 $m$ 行，每行三个整数，表示一个操作。

如果操作为 `1 a b`，表示将节点 $a$ 和节点 $b$ 通过网线连接起来。当 $a=b$ 时，表示连接了一个自环，对网络没有实质影响。

如果操作为 `2 p t`，表示在节点 $p$ 上发送一条大小为 $t$ 的信息。

## 输出格式

输出一行，包含 $n$ 个整数，相邻整数之间用一个空格分割，依次表示进行完上述操作后节点 $1$ 至节点 $n$ 上存储信息的大小。

## 样例 #1

### 样例输入 #1

```
4 8
1 1 2
2 1 10
2 3 5
1 4 1
2 2 2
1 1 2
1 2 4
2 2 1
```

### 样例输出 #1

```
13 13 5 3
```

## 提示

对于 $30\%$ 的评测用例，$1 ≤ n ≤ 20$，$1 ≤ m ≤ 100$。

对于 $50\%$ 的评测用例，$1 ≤ n ≤ 100$，$1 ≤ m ≤ 1000$。

对于 $70\%$ 的评测用例，$1 ≤ n ≤ 1000$，$1 ≤ m ≤ 10000$。

对于所有评测用例，$1 ≤ n ≤ 10000$，$1 ≤ m ≤ 10^5$ ，$1 ≤ t ≤ 100$。

蓝桥杯 2020 第一轮省赛 A 组 J 题（B 组 J 题）。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010;

int n, m;
int p[N], d[N];

int find(int x) {
    if (p[x] == x || p[p[x]] == p[x]) return p[x];
    int r = find(p[x]);
    d[x] += d[p[x]];
    p[x] = r;
    return r;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) p[i] = i;
    while (m--) {
        int t, a, b;
        scanf("%d%d%d", &t, &a, &b);
        if (t == 1) {
            a = find(a), b = find(b);
            if (a != b) {
                d[a] -= d[b];
                p[a] = b;
            }
        } else {
            a = find(a);
            d[a] += b;
        }
    }
    for (int i = 1; i <= n; i++)
        if (i == find(i)) printf("%d ", d[i]);
        else printf("%d ", d[i] + d[find(i)]);
    return 0;
}
```

**这道题非常妙 ！！！**

注意这里：

```c++
for (int i = 1; i <= n; i++)
    if (i == find(i)) printf("%d ", d[i]);
    else printf("%d ", d[i] + d[find(i)]);
```

在执行完`find(i)`之后，其实每个路径上只有两个点了，所以输出`d[i] + d[find(i)]`



# 炸铁路

## 题目描述

A 国派出将军 uim，对 B 国进行战略性措施，以解救涂炭的生灵。

B 国有 $n$ 个城市，这些城市以铁路相连。任意两个城市都可以通过铁路直接或者间接到达。

uim 发现有些铁路被毁坏之后，某两个城市无法互相通过铁路到达。这样的铁路就被称为 key road。

uim 为了尽快使该国的物流系统瘫痪，希望炸毁铁路，以达到存在某两个城市无法互相通过铁路到达的效果。

然而，只有一发炮弹（A 国国会不给钱了）。所以，他能轰炸哪一条铁路呢？

## 输入格式

第一行 $n,m\ (1 \leq n\leq 150$，$1 \leq m \leq 5000)$，分别表示有 $n$ 个城市，总共 $m$ 条铁路。

以下 $m$ 行，每行两个整数 $a, b$，表示城市 $a$ 和城市 $b$ 之间有铁路直接连接。

## 输出格式

输出有若干行。

每行包含两个数字 $a,b$，其中 $a<b$，表示 $\lang a,b\rang$ 是 key road。

请注意：输出时，所有的数对 $\lang a,b\rang$ 必须按照 $a$ 从小到大排序输出；如果$a$ 相同，则根据 $b$ 从小到大排序。

## 样例 #1

### 样例输入 #1

```
6 6
1 2
2 3
2 4
3 5
4 5
5 6
```

### 样例输出 #1

```
1 2
5 6
```

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 5050;
int n, m, p[N];

struct node {
    int l, r;

    bool operator<(const node &w) const {
        if (l == w.l) return r < w.r;
        else return l < w.l;
    }
} s[N];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void ii() {
    for (int i = 1; i <= n; ++i) p[i] = i;
}

int check() {
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        if (p[i] == i) ans++;
    }
    return ans;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> s[i].l >> s[i].r;

    }
    sort(s, s + m);
    ii();
    for (int i = 0; i < m; ++i) {
        p[find(s[i].l)] = find(s[i].r);
    }
    int t = check();
    for (int i = 0; i < m; ++i) {
        ii();
        for (int j = 0; j < m; ++j) {
            if (j != i) {
                p[find(s[j].l)] = find(s[j].r);
            }
        }
        if (check() > t) {
            cout << min(s[i].l, s[i].r) << " " << max(s[i].l, s[i].r) << endl;
        }
    }
    return 0;
} 
```

此题可用并查集求解

因为并查集可用来快速判断图中的任意两点之间是否连通

思路：枚举每条边，删去这条边后将其余边的所有节点加入并查集，判断此时图是否连通，如果不连通，则此边满足题意

过程中注意初始化



# [JSOI2008] 星球大战

## 题目描述

很久以前，在一个遥远的星系，一个黑暗的帝国靠着它的超级武器统治着整个星系。

某一天，凭着一个偶然的机遇，一支反抗军摧毁了帝国的超级武器，并攻下了星系中几乎所有的星球。这些星球通过特殊的以太隧道互相直接或间接地连接。

但好景不长，很快帝国又重新造出了他的超级武器。凭借这超级武器的力量，帝国开始有计划地摧毁反抗军占领的星球。由于星球的不断被摧毁，两个星球之间的通讯通道也开始不可靠起来。

现在，反抗军首领交给你一个任务：给出原来两个星球之间的以太隧道连通情况以及帝国打击的星球顺序，以尽量快的速度求出每一次打击之后反抗军占据的星球的连通块的个数。（如果两个星球可以通过现存的以太通道直接或间接地连通，则这两个星球在同一个连通块中）。

## 输入格式

输入文件第一行包含两个整数，$n,m$，分别表示星球的数目和以太隧道的数目。星球用 $0 \sim n-1$ 的整数编号。

接下来的 $m$ 行，每行包括两个整数 $x,y$，表示星球 $x$ 和星球 $y$ 之间有 “以太” 隧道，可以直接通讯。

接下来的一行为一个整数 $k$ ，表示将遭受攻击的星球的数目。

接下来的 $k$ 行，每行有一个整数，按照顺序列出了帝国军的攻击目标。这 $k$ 个数互不相同，且都在 $0$ 到 $n-1$ 的范围内。

## 输出格式

第一行是开始时星球的连通块个数。接下来的 $k$ 行，每行一个整数，表示经过该次打击后现存星球的连通块个数。

## 样例 #1

### 样例输入 #1

```
8 13
0 1
1 6
6 5
5 0
0 6
1 2
2 3
3 4
4 5
7 1
7 2
7 6
3 6
5
1
6
3
5
7
```

### 样例输出 #1

```
1
1
1
2
3
3
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 2\times 10^5$，$1\le n \le 2m$，$x \neq y$。

[JSOI2008]

**自己思考的一个答案，但是只得20分，其余时间超限**

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 4e5 + 10;
int n, m, k, p[N];
typedef pair<int, int> PII;
set<PII> d;// 表示存在的连接
set<int> num;// 被轰炸的点
stack<int> q;// 依次取出被轰炸的点
stack<int> ans;

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) p[i] = i;
    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        a++;
        b++;
        d.insert({a, b});
    }
    cin >> k;
    for (int i = 0; i < k; ++i) {
        int a;
        cin >> a;
        a++;
        q.push(a);
        num.insert(a);
    }

    while (q.size()) {
        set<PII> temp = d;
        for (auto t: temp) {
            if (num.find(t.first) == num.end() && num.find(t.second) == num.end()) {
                p[find(t.first)] = find(t.second);
                d.erase(t);
            }
        }
        int res = 0;
        for (int i = 1; i <= n; ++i) if (num.find(i) == num.end() && p[i] == i) res++;
        ans.push(res);

        num.erase(q.top());
        q.pop();
    }

    set<PII> temp = d;
    for (auto t: temp) {
        p[find(t.first)] = find(t.second);
    }
    int res = 0;
    for (int i = 1; i <= n; ++i) if (p[i] == i) res++;
    ans.push(res);

    while (!ans.empty()) {
        cout << ans.top() << endl;
        ans.pop();
    }

    return 0;
}
```

结果改良之后，优化掉了利用`for`循环查找联通块的操作，直接用一个变量`tot`维护联通块，但是依旧TLE。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 4e5 + 10;
int n, m, k, p[N];
typedef pair<int, int> PII;
set<PII> d;// 表示存在的连接
set<int> num;// 被轰炸的点
stack<int> q;// 依次取出被轰炸的点
stack<int> ans;

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) p[i] = i;
    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        a++;
        b++;
        d.insert({a, b});
    }
    cin >> k;
    for (int i = 0; i < k; ++i) {
        int a;
        cin >> a;
        a++;
        q.push(a);
        num.insert(a);
    }
    int tot = n - k;
    while (!q.empty()) {
        set<PII> temp = d;
        for (auto t: temp) {
            if (num.find(t.first) == num.end() && num.find(t.second) == num.end()) {
                if (find(t.first) != find(t.second)) {
                    tot--;
                }
                p[find(t.first)] = find(t.second);
                d.erase(t);
            }
        }
        ans.push(tot);

        num.erase(q.top());
        q.pop();
        tot++;
    }

    set<PII> temp = d;
    for (auto t: temp) {
    	if (find(t.first) != find(t.second)) {
            tot--;
        }
        p[find(t.first)] = find(t.second);
    }
    ans.push(tot);
    while (!ans.empty()) {
        cout << ans.top() << endl;
        ans.pop();
    }
    return 0;
}
```

查看别人的题解之后受到了不小的启发。

可以建立一个图来存储点和点之间的连通关系（这也加深了我对图的应用的理解）

**AC代码**

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 4e5 + 10;
int n, m, k, p[N], idx, h[N], ne[N], e[N];
int d[N];
bool st[N];
stack<int> s;

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) p[i] = i;
    memset(h, -1, sizeof h);
    for (int i = 0; i < m; ++i) {
        int a, b;
        cin >> a >> b;
        a++;
        b++;
        add(a, b);
        add(b, a);
    }
    cin >> k;
    for (int i = 0; i < k; ++i) {
        cin >> d[i];
        d[i]++;
        st[d[i]] = true;
    }
    int tot = n - k;
    for (int i = 1; i <= n; ++i) {
        if (!st[i]) {
            for (int t = h[i]; ~t; t = ne[t]) {
                int j = e[t];
                if (!st[j]) {
                    if (find(j) != find(i)) {
                        tot--;
                        p[find(j)] = find(i);
                    }
                }
            }
        }
    }
    s.push(tot);
    for (int i = k - 1; i >= 0; --i) {
        st[d[i]] = false;
        tot++;
        int last = d[i];
        for (int j = h[d[i]]; ~j; j = ne[j]) {
            int t = e[j];
            if (!st[t]) {
                if (find(t) != find(last)) {
                    tot--;
                    p[find(t)] = find(last);
                }
                last = t;
            }
        }
        s.push(tot);
    }
    while (!s.empty()) {
        cout << s.top() << endl;
        s.pop();
    }
    return 0;
}
```

注意维护`tot`，`st`，`for循环中的循环遍变量`



1. set、multiset、map、multimap
特点：底层实现是红黑树，键值有序，set 和 map 键不可重复，而 multiset 和 multimap 可重复；
复杂度：插入、删除、查找都为O(logN)；

2. unordered_set，unordered_map，unordered_multiset，unordered_multimap
特点：底层实现是哈希表，键值无序，unordered_set 和 unordered_map 键不可重复，而另外两个可以重复；
复杂度：插入、删除、查找平均为O(1)，最坏为O(N)，空间换时间；

3. vector
特点：底层实现是数组，动态成倍扩容；
复杂度：
插入：push_back()，O(1)；insert()，O(N)
删除：pop_back()，O(1)；erase()，O(N)
查找：O(1)

4. list
特点：底层实现双向链表；
复杂度：
插入：push_front()，O(1)；push_back()，O(1)；insert()，O(1)
删除：pop_front()，O(1)；pop_back()，O(1)；erase()，O(1)
查找：O(N)

5. deque 双端队列
特点：底层是分段连续的线性空间，它是一种具有队列和栈的性质的数据结构，其插入和删除操作限定在两端进行；
复杂度：
插入：push_front()，O(1)；push_back()，O(1)；insert()，O(N)
删除：pop_front()，O(1)；pop_back()，O(1)；erase()，O(N)
查找：O(1)

6. stack 栈
特点：底层实现一般用 list 或 deque，封闭头部即可，数据先进后出，不支持随机访问；
复杂度：
插入：push()，O(1)
删除：pop()，O(1)
查找（栈顶）：top()，O(1)

7. queue 队列
特点：底层实现一般用 list 或 deque，数据先进先出，不支持随机访问；
复杂度：
插入：push()，O(1)
删除：pop()，O(1)
查找（队列头）：front()，O(1)

8. priority_queue 优先队列
特点：底层用堆实现，队列中各个元素被赋予优先级；
复杂度：
插入：push()，O(logN)
删除：pop()，O(logN)
查找（取堆顶）：top()，O(1)



# [POI2005] SKA-Piggy Banks

## 题目描述

Byteazar the Dragon 拥有 $N$ 个小猪存钱罐。每一个存钱罐能够用相应的钥匙打开或者被砸开。Byteazar 已经将钥匙放入到一些存钱罐中。现在已知每个钥匙所在的存钱罐，Byteazar 想要买一辆小汽车，而且需要打开所有的存钱罐。然而，他想要破坏尽量少的存钱罐，帮助 Byteazar 去决策最少要破坏多少存钱罐。

## 输入格式

第一行包括一个整数 $N$ ($1\le N\le 1000000$)，表示 Byteazar the Dragon 拥有的存钱罐的数量。

存钱罐（包括它们对应的钥匙）从 $1$ 到 $N$ 编号。

接下来有 $N$ 行：第 $i+1$ 行包括一个整数 $x$，表示第 $i$ 个存钱罐对应的钥匙放置在了第 $x$ 个存钱罐中。

## 输出格式

仅一行：包括一个整数，表示能打开所有存钱罐的情况下，需要破坏的存钱罐的最少数量。

## 样例 #1

### 样例输入 #1

```
4
2
1
2
4
```

### 样例输出 #1

```
2
```

**并查集+建立关系**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6 + 10;
int n, p[N], ans, a[N];
bool st[N];// 打开或者被砸开

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void dfs(int x) {
    st[x] = true;
    int ne = a[x];
	
    // 成环 
    if (st[ne] && find(x) == find(ne)) {
        return;
    }

    // 抢占 
    if (st[ne] && find(x) != find(ne)) {
        p[find(ne)] = find(x);
        return;
    }

    // 连接到一条链的头部 
    p[find(ne)] = find(x);
    if (!st[ne]) dfs(ne);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) p[i] = i;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i)
        if (p[i] == i) {
            dfs(i);
        }
    for (int i = 1; i <= n; ++i) {
        if (p[i] == i) ans++;
    }
    cout << ans << endl;
    return 0;
}
```



# pSort

## 题面翻译

#### 题目描述

给定一个长度为 $n$ 的数列 $\{a_n\}$，初始时 $\{a_n\} = \{1, 2, \dots, n\}$。位置 $i$ 上的数可以和位置 $i \pm d_i$ 上的数交换。给定一个 $1 \sim n$ 的全排列，问初始的数列可否交换成给定的形式。

#### 输入格式

第一行一个整数 $n$。

第二行 $n$ 个互不相同的整数表示目标数列。

第三行 $n$ 个整数表示 $d_1, d_2, \dots, d_n$。

#### 输出格式

如果能交换到给定样式，输出 `YES`，否则输出 `NO`。

#### 数据范围

$1 \le n \le 100$

## 题目描述

One day $ n $ cells of some array decided to play the following game. Initially each cell contains a number which is equal to it's ordinal number (starting from $ 1 $ ). Also each cell determined it's favourite number. On it's move $ i $ -th cell can exchange it's value with the value of some other $ j $ -th cell, if $ |i-j|=d_{i} $ , where $ d_{i} $ is a favourite number of $ i $ -th cell. Cells make moves in any order, the number of moves is unlimited.

The favourite number of each cell will be given to you. You will also be given a permutation of numbers from $ 1 $ to $ n $ . You are to determine whether the game could move to this state.

## 输入格式

The first line contains positive integer $ n $ ( $ 1<=n<=100 $ ) — the number of cells in the array. The second line contains $ n $ distinct integers from $ 1 $ to $ n $ — permutation. The last line contains $ n $ integers from $ 1 $ to $ n $ — favourite numbers of the cells.

## 输出格式

If the given state is reachable in the described game, output YES, otherwise NO.

## 样例 #1

### 样例输入 #1

```
5
5 4 3 2 1
1 1 1 1 1
```

### 样例输出 #1

```
YES
```

## 样例 #2

### 样例输入 #2

```
7
4 3 5 1 2 7 6
4 6 6 1 6 6 1
```

### 样例输出 #2

```
NO
```

## 样例 #3

### 样例输入 #3

```
7
4 2 5 1 3 7 6
4 6 6 1 6 6 1
```

### 样例输出 #3

```
YES
```

**并查集维护关系**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int n, p[N], a[N];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        p[i] = i;
    }
    for (int i = 1; i <= n; ++i) {
        int d;
        cin >> d;
        if (i - d >= 1) p[find(i)] = find(i - d);
        if (i + d <= n) p[find(i)] = find(i + d);
    }
    for (int i = 1; i <= n; ++i) {
        if (find(i) != find(a[i])) {
            cout << "No";
            return 0;
        }
    }
    cout << "Yes";
    return 0;
}
```

我们先证明一个东西：如果有一串数字，每相邻两个数字都可以交换，必然可以得到这组数字的所有全排列。

那么我们总结出一条规律：$1-n$依次调整，每调整完一个数就检查前面的数，这样下来总归可以成功。

那我们不妨把所有能交换的格子排成一列，这样交换过程就变成了与相邻的格子交换，那如果`f[i]`这个数在这一列中，说明总归可以交换成功。

这样一说，并查集就暴露了吧。

把所有能交换的格子放在一个并查集里，最后检查`i`和`f[i]`是否在一个并查集里，这道题就A了！



# [USACO19DEC] Milk Visits S

## 题目描述

Farmer John 计划建造 $N$ 个农场，用 $N-1$ 条道路连接，构成一棵树（也就是说，所有农场之间都互相可以到达，并且没有环）。每个农场有一头奶牛，品种为更赛牛或荷斯坦牛之一。

Farmer John 的 $M$ 个朋友经常前来拜访他。在朋友 $i$ 拜访之时，Farmer John 会与他的朋友沿着从农场 $A_i$ 到农场 $B_i$ 之间的唯一路径行走（可能有 $A_i = B_i$）。除此之外，他们还可以品尝他们经过的路径上任意一头奶牛的牛奶。由于 Farmer John 的朋友们大多数也是农场主，他们对牛奶有着极强的偏好。他的有些朋友只喝更赛牛的牛奶，其余的只喝荷斯坦牛的牛奶。任何 Farmer John 的朋友只有在他们访问时能喝到他们偏好的牛奶才会高兴。

请求出每个朋友在拜访过后是否会高兴。

## 输入格式

输入的第一行包含两个整数 $N$ 和 $M$。

第二行包含一个长为 $N$ 的字符串。如果第 $i$ 个农场中的奶牛是更赛牛，则字符串中第 $i$ 个字符为 `G`，如果第 $i$ 个农场中的奶牛是荷斯坦牛则为 `H`。

以下 $N-1$ 行，每行包含两个不同的整数 $X$ 和 $Y$（$1 \leq X, Y \leq N$），表示农场 $X$ 与 $Y$ 之间有一条道路。

以下 $M$ 行，每行包含整数 $A_i$，$B_i$，以及一个字符 $C_i$。$A_i$ 和 $B_i$ 表示朋友 $i$ 拜访时行走的路径的端点，$C_i$ 是 `G` 或 `H` 之一，表示第 $i$ 个朋友喜欢更赛牛的牛奶或是荷斯坦牛的牛奶。

## 输出格式

输出一个长为 $M$ 的二进制字符串。如果第 $i$ 个朋友会感到高兴，则字符串的第 $i$ 个字符为 `1`，否则为 `0`。

## 样例 #1

### 样例输入 #1

```
5 5
HHGHG
1 2
2 3
2 4
1 5
1 4 H
1 4 G
1 3 G
1 3 H
5 5 H
```

### 样例输出 #1

```
10110
```

## 提示

在这里，从农场 1 到农场 4 的路径包括农场 1、2 和 4。所有这些农场里都是荷斯坦牛，所以第一个朋友会感到满意，而第二个朋友不会。

关于部分分：

测试点 $1$ 样例。

测试点 $2\sim 5$ 满足 $N\le 10^3$，$M\le 2\cdot 10^3$。

对于 $100\%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq M \leq 10^5$。

供题：Spencer Compton

**树+并查集**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, m, idx, h[N], ne[N * 2], e[N * 2];
int p[N];
string s;

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void add(int a, int b) {
    ne[idx] = h[a];
    e[idx] = b;
    h[a] = idx++;
}

void dfs(int u, int fa) {
    for (int i = h[u]; ~i; i = ne[i]) {
        if (fa != -1) {
            if (s[fa] == s[u]) {
                p[find(u)] = find(fa);
            }
        }
        if (e[i] != fa) dfs(e[i], u);
    }
}

int main() {
    cin >> n >> m;
    cin >> s;
    s = "1" + s;
    for (int i = 1; i <= n; ++i) p[i] = i;
    memset(h, -1, sizeof h);
    int a, b;
    for (int i = 0; i < n - 1; ++i) {
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    dfs(1, -1);
    char c;
    for (int i = 0; i < m; ++i) {
        cin >> a >> b >> c;
        if (find(a) == find(b) && s[a] != c) {
            cout << 0;
            continue;
        }
        cout << 1;
    }
    return 0;
}
```

这一棵树只有两种颜色，故我们只要记录树上一个个颜色相同的连通块，只有当所查询两点是同一连通块且连通块颜色与目标颜色不同时输出0。



**LCA做法**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;

int n, m;
vector<int> e[N];
int dep[N], fa[N][20];
struct node {
    int h, g;
} s[N];
string ss;

void dfs(int u, int father) {
    dep[u] = dep[father] + 1;
    if (ss[u] == 'G') {
        s[u].g = 1 + s[father].g;
        s[u].h = s[father].h;
    } else {
        s[u].g = s[father].g;
        s[u].h = 1 + s[father].h;
    }
    fa[u][0] = father;
    for (int i = 1; i <= 19; ++i) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int v: e[u]) {
        if (v != father) dfs(v, u);
    }
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 19; i >= 0; i--) {
        if (dep[fa[u][i]] >= dep[v])
            u = fa[u][i];
    }
    if (u == v) return v;
    for (int i = 19; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

int main() {
    cin >> n >> m >> ss;
    ss = "1" + ss;
    int a, b;
    for (int i = 0; i < n - 1; ++i) {
        cin >> a >> b;
        e[a].push_back(b);
        e[b].push_back(a);
    }
    dfs(1, 0);
    char c;
    for (int i = 0; i < m; ++i) {
        cin >> a >> b >> c;
        int t = lca(a, b);
        if (c == 'G') {
            int gg = s[a].g - s[t].g + s[b].g - s[t].g;
            if (ss[t] == 'G') gg++;
            if (gg) cout << 1;
            else cout << 0;
        } else {
            int hh = s[a].h - s[t].h + s[b].h - s[t].h;
            if (ss[t] == 'H') hh++;
            if (hh) cout << 1;
            else cout << 0;
        }
    }
    return 0;
}
```

给定一棵树，树上的点只有两种状态——H或G。

Q次询问，每次询问两点间路径有没有H或者G。

我们可以只维护一个节点到根节点路径上H和G的数量就行。

由于一个节点的信息和其父亲的信息只差1，所以这很好修改。



# [NOIP2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$

## 输入格式

每个输入文件包含多组数据。

第一行，包含一个正整数 $T$，代表该输入文件中所含的数据组数。

接下来是 $T$ 组数据，每组数据的格式如下： 第一行包含三个正整数 $n,h,r$，两个数之间以一个空格分开，分别代表奶酪中空洞的数量，奶酪的高度和空洞的半径。

接下来的 $n$ 行，每行包含三个整数 $x,y,z$，两个数之间以一个空格分开，表示空洞球心坐标为 $(x,y,z)$。

## 输出格式

$T$ 行，分别对应 $T$ 组数据的答案，如果在第 $i$ 组数据中，Jerry 能从下表面跑到上表面，则输出 `Yes`，如果不能，则输出 `No`。

## 样例 #1

### 样例输入 #1

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4
```

### 样例输出 #1

```
Yes
No
Yes
```

## 提示

【输入输出样例 $1$ 说明】

 ![](image/并查集.image/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。


第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。


第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

```c++
#include<bits/stdc++.h>

using namespace std;
using LL = long long int;
const int N = 1e3 + 10;
LL T, n, h, r, p[N];

struct node {
    LL x, y, z;

    bool operator<(const node &d) const {
        return z < d.z;
    }
} s[N];

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void solve() {
    cin >> n >> h >> r;
    for (int i = 1; i <= n + 8; ++i) p[i] = i;
    for (int i = 0; i < n; ++i) {
        cin >> s[i].x >> s[i].y >> s[i].z;
    }
    sort(s, s + n);
    for (int i = 0; i < n; ++i) {
        if (s[i].z <= r) p[find(i + 1)] = find(n + 3);
        if (s[i].z >= h - r) p[find(i + 1)] = find(n + 4);
        for (int j = i + 1; j < n; ++j) {
            if (4 * r * r >= (s[i].x - s[j].x) * (s[i].x - s[j].x) + (s[i].y - s[j].y) * (s[i].y - s[j].y) + (s[i].z - s[j].z) * (s[i].z - s[j].z)) {
                p[find(i + 1)] = find(j + 1);
            }
        }
    }
    if (find(n + 3) == find(n + 4)) cout << "Yes" << endl;
    else cout << "No" << endl;
}

int main() {
    cin >> T;
    while (T--) solve();
    return 0;
}
```

注意计算距离的时候会爆int，所以要开long long int
