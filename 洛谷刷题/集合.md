https://www.luogu.com.cn/training/115#problems



# 【模板】字符串哈希

## 题目描述

如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。

**友情提醒：如果真的想好好练习哈希的话，请自觉。**

## 输入格式

第一行包含一个整数 $N$，为字符串的个数。

接下来 $N$ 行每行包含一个字符串，为所提供的字符串。

## 输出格式

输出包含一行，包含一个整数，为不同的字符串个数。

## 样例 #1

### 样例输入 #1

```
5
abc
aaaa
abc
abcc
12345
```

### 样例输出 #1

```
4
```

## 提示

对于 $30\%$ 的数据：$N\leq 10$，$M_i≈6$，$Mmax\leq 15$。

对于 $70\%$ 的数据：$N\leq 1000$，$M_i≈100$，$Mmax\leq 150$。

对于 $100\%$ 的数据：$N\leq 10000$，$M_i≈1000$，$Mmax\leq 1500$。


样例说明：

样例中第一个字符串(abc)和第三个字符串(abc)是一样的，所以所提供字符串的集合为{aaaa,abc,abcc,12345}，故共计4个不同的字符串。


Tip：
感兴趣的话，你们可以先看一看以下三题：

BZOJ3097：http://www.lydsy.com/JudgeOnline/problem.php?id=3097

BZOJ3098：http://www.lydsy.com/JudgeOnline/problem.php?id=3098

BZOJ3099：http://www.lydsy.com/JudgeOnline/problem.php?id=3099

如果你仔细研究过了（或者至少仔细看过AC人数的话），我想你一定会明白字符串哈希的正确姿势的

```c++
#include<bits/stdc++.h>

using namespace std;
typedef unsigned long long LL;
const int N = 1510;

const LL P = 131;
LL p[N];
map<LL, int> m;
int n;

int main() {
    cin >> n;
    p[0] = 1;
    for (int i = 1; i < N; ++i) p[i] = p[i - 1] * P;
    string a;
    while (n--) {
        cin >> a;
        LL res = 0;
        for (int i = 0; i < a.size(); ++i) res += a[i] * p[i];
        m[res] += 1;
    }
    cout << m.size();
    return 0;
}
```

哈希的过程，其实可以看作**对一个串的单向加密过程**，并且需要保证所加的密**不能高概率重复**（就像不能让隔壁老王轻易地用它家的钥匙打开你家门一样），通过这种方式来替代一些很费时间的操作

比如，最常见的，当然就是通过哈希数组来判断几个串是否相同（洛谷P3370）。此处的操作呢，很简单，就是对于每个串，**我们通过一个固定的转换方式，将相同的串使其的“密”一定相同，不同的串 *尽量* 不同。**

此处有人指出：那难道不能先比对字符串长度，然后比对ASCLL码之和吗？事实上显然是不行的（比如 ab 和 ba ，并不是同一个串，但是如是做却会让其认为是）。这种情况就叫做 **hash 冲突**，并且在如此的单向加密哈希中，hash 冲突的情况在所难免

而我们此处介绍的，即是最常见的一种哈希：**进制哈希**。进制哈希的核心便是**给出一个固定进制，将一个串的每一个元素看做一个进制位上的数字，所以这个串就可以看做一个进制的数，那么这个数就是这个串的哈希值；则我们通过比对每个串的的哈希值，即可判断两个串是否相同**



再好的哈希也会有冲突，此时有两种做法可以解决或者降低哈希冲突的可能性

1. 无错哈希

	其实原理很简单，就是我们要记录每一个已经诞生的哈希值，然后对于每一个新的哈希值，我们都可以来判断是否和已有的哈希值冲突，如果冲突，那么可以将这个新的哈希值不断加上一个大质数，直到不再冲突

2. 多重哈希

	这其实就是你用不同的两种或多种方式哈希，然后分别比对每一种哈希值是否相同——显然是增加了空间和时间，但也确实增加了其正确性



# [USACO16DEC]Cities and States S

## 题目描述

To keep his cows intellectually stimulated, Farmer John has placed a large map of the USA on the wall of his barn. Since the cows spend many hours in the barn staring at this map, they start to notice several curious patterns. For example, the cities of Flint, MI and Miami, FL share a very special relationship: the first two letters of "Flint" give the state code ("FL") for Miami, and the first two letters of "Miami" give the state code ("MI") for Flint.

Let us say that two cities are a "special pair" if they satisfy this property and come from different states. The cows are wondering how many special pairs of cities exist. Please help them solve this amusing geographical puzzle!

为了训练奶牛们的智力，Farmer John 在谷仓的墙上放了一张美国地图。由于奶牛在谷仓里花了很多时间看这张地图，他们开始注意到一些奇怪的关系。例如，Flint 的前两个字母就是 Miami 所在的 `FL` 州，Miami 的前两个字母则是 Flint 所在的 `MI` 州。  
确切地说，对于两个城市，它们的前两个字母互为对方所在州的名称。

我们称两个城市是一个一对“特殊的”城市，如果他们具有上面的特性，并且来自不同的省。奶牛想知道有多少对“特殊的”城市存在。请帮助他们解决这个有趣的地理难题！

## 输入格式

The first line of input contains $N$ ($1 \leq N \leq 200,000$), the number ofcities on the map.


The next $N$ lines each contain two strings: the name of a city (a string of at least 2 and at most 10 uppercase letters), and its two-letter state code (a string of 2 uppercase letters).  Note that the state code may be something like ZQ, which is not an actual USA state.  Multiple cities with the same name can exist, but they will be in different states.

第一行一个正整数 $N$，表示地图上的城市的个数。  
接下来 $N$ 行，每行两个字符串，分别表示一个城市的名称（$2 \sim 10$个大写字母）和所在州的代码（$2$ 个大写字母）。可能出现类似 `ZQ` 的州代码，即并不真的是美国的一个州的代码。同一个州内不会有两个同名的城市。

## 输出格式

Please output the number of special pairs of cities.

输出特殊的城市对数。

## 样例 #1

### 样例输入 #1

```
6
MIAMI FL
DALLAS TX
FLINT MI
CLEMSON SC
BOSTON MA
ORLANDO FL
```

### 样例输出 #1

```
1
```



```c++
#include<bits/stdc++.h>

using namespace std;

map<string, int> t;

int main() {
    int n;
    cin >> n;

    int ans = 0;
    for (int i = 0; i < n; ++i) {
        string name, zhou;
        cin >> name >> zhou;
        name = name.substr(0, 2);

        if (t.find(zhou + name) != t.end()) {
            if (zhou != name)
                ans += t[zhou + name];
        }
        t[name + zhou] += 1;
    }
    cout << ans;
    return 0;
}
```

**非常巧妙的利用了STL**

注意州和城市的前两位相同时要加上特判，**这个题坑的地方就是要特判 c2=s2，如果 c2=s2 就要把它减回去**

题目中已经要求了**来自不同的省**，所以对于**c2=s2**的情况要删除



# 【深基17.例5】木材仓库

## 题目描述

博艾市有一个木材仓库，里面可以存储各种长度的木材，但是保证没有两个木材的长度是相同的。作为仓库负责人，你有时候会进货，有时候会出货，因此需要维护这个库存。有不超过 100000 条的操作：

- 进货，格式`1 Length`：在仓库中放入一根长度为 Length(不超过 $10^9$) 的木材。如果已经有相同长度的木材那么输出`Already Exist`。
- 出货，格式`2 Length`：从仓库中取出长度为 Length 的木材。如果没有刚好长度的木材，取出仓库中存在的和要求长度最接近的木材。如果有多根木材符合要求，取出比较短的一根。输出取出的木材长度。如果仓库是空的，输出`Empty`。

## 输入格式

## 输出格式

## 样例 #1

### 样例输入 #1

```
7
1 1
1 5
1 3
2 3
2 3
2 3
2 3
```

### 样例输出 #1

```
3
1
5
Empty
```



```c++
#include<bits/stdc++.h>

using namespace std;

map<int, int> t;

int main() {
    int n;
    cin >> n;

    while (n--) {
        string op;
        int length;
        cin >> op >> length;

        if (op == "1") {
            if (t.count(length)) puts("Already Exist");
            else t[length] = 1;
        } else {
            if (t.count(length)) printf("%d\n", length);
            else if (!t.size()) cout << "Empty" << endl;
            else {
                t[length] = 1;
                auto s = t.find(length);
                auto a = s;
                s++;
                if (a == t.begin()) {
                    printf("%d\n", s->first);
                    t.erase(s->first);
                } else if (s == t.end()) {
                    printf("%d\n", (--a)->first);
                    t.erase(a->first);
                } else {
                    --a;
                    if (length - a->first > s->first - length) {
                        cout << s->first << endl;
                        t.erase(s->first);
                    } else {
                        cout << a->first << endl;
                        t.erase(a->first);
                    }
                }
            }
            t.erase(length);
        }
    }
    return 0;
}
```

**非常巧妙地把不存在的木头假装存进去，然后进行查找操作，最后删除**

对于不存在又要取出长度相近的，本人的方法是利用map的指针操作，先“假装”存一下该不存在的木头，然后指针定位该木头的位置，于是`it++`就得到了比它长的下一根木头的位置，`it--`就得到了比它短的下一根木头的位置，两者比较一下，然后取出长度相近的即可，最后记得`erase`之前“假装”存的那根不存在的木头



# 【深基17.例6】学籍管理

## 题目描述

您要设计一个学籍管理系统，最开始学籍数据是空的，然后该系统能够支持下面的操作（不超过 $10^5$ 条）：

- 插入与修改，格式`1 NAME SCORE`：在系统中插入姓名为 NAME(由字母和数字组成不超过 20 个字符的字符串，区分大小写) ，分数为 $\texttt{SCORE}$（$0<\texttt{SCORE}<2^{31}$） 的学生。如果已经有同名的学生则更新这名学生的成绩为 SCORE。如果成功插入或者修改则输出`OK`。
- 查询，格式`2 NAME`：在系统中查询姓名为 NAME 的学生的成绩。如果没能找到这名学生则输出`Not found`，否则输出该生成绩。
- 删除，格式`3 NAME`：在系统中删除姓名为 NAME 的学生信息。如果没能找到这名学生则输出`Not found`，否则输出`Deleted successfully`。
- 汇总，格式`4`：输出系统中学生数量。

## 输入格式

## 输出格式

## 样例 #1

### 样例输入 #1

```
5
1 lxl 10
2 lxl
3 lxl
2 lxl
4
```

### 样例输出 #1

```
OK
10
Deleted successfully
Not found
0
```



```c++
#include<bits/stdc++.h>

using namespace std;

map<string, int> t;

int main() {
    int n;
    cin >> n;

    while (n--) {
        string op, name;
        cin >> op;
        if (op == "1") {
            int score;
            cin >> name >> score;
            t[name] = score;
            puts("OK");
        } else if (op == "2") {
            cin >> name;
            if (t.find(name) == t.end()) {
                puts("Not found");
            } else {
                cout << t[name] << endl;
            }
        } else if (op == "3") {
            cin >> name;
            int success = t.erase(name);
            if (success == 1) puts("Deleted successfully");
            else puts("Not found");
        } else if (op == "4") {
            cout << t.size() << endl;
        }
    }
    return 0;
}
```

**Map **也是有缺点的，单次操作它的时间复杂度是O（log n）

除了刚才介绍的定义和赋值，像`string`一样，`map`也有好多**好用的成员函数**，这里先教大家几个简单的、实用的、这个题能用到的：

|    方法    |                         作用                         |
| :--------: | :--------------------------------------------------: |
| a.count(x) | 判断x为下标的元素是不是在a中，是就返回1，不是就返回0 |
| a.erase(x) |                 删除a中x为下标的元素                 |
|  a.size()  |                  返回a中元素的个数                   |
| a.clear()  |                        清空a                         |



# A-B 数对

## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！

## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。

## 输入格式

输入共两行。

第一行，两个正整数 $N,C$。

第二行，$N$ 个正整数，作为要求处理的那串数。

## 输出格式

一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。

## 样例 #1

### 样例输入 #1

```
4 1
1 1 2 3
```

### 样例输出 #1

```
3
```

## 提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$,$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组

```c++
#include<bits/stdc++.h>

typedef long long int LL;
using namespace std;
const int N = 2e5 + 10;
map<int, int> m;
int s[N];

int main() {
    int n, c;
    cin >> n >> c;

    for (int i = 0; i < n; ++i) {
        int a;
        scanf("%d", &a);

        m[a] += 1;
    }

    int k = 0;
    for (auto t: m) {
        s[k++] = t.first;
    }

    sort(s, s + k);

    long long int res = 0;
    for (int i = 0, j = 0; j < k;) {
        if (s[j] - s[i] < c) j++;
        else if (s[j] - s[i] == c) {
            res += (LL) m[s[j]] * m[s[i]];
            j++;
            i++;
        } else i++;
    }
    cout << res;
    return 0;
}
```

用一个`map`记录每个数字出现的次数，利用乘法原理处理



# 保龄球

## 题目描述

DL 算缘分算得很烦闷，所以常常到体育馆去打保龄球解闷。因为他保龄球已经打了几十年了，所以技术上不成问题，于是他就想玩点新花招。

DL 的视力真的很不错，竟然能够数清楚在他前方十米左右每个位置的瓶子的数量。他突然发现这是一个炫耀自己好视力的借口——他看清远方瓶子的个数后从某个位置发球，这样就能打倒一定数量的瓶子。

1    OOO

2    OOOO

3    O

4    OO

如上图，每个“O”代表一个瓶子。如果 DL 想要打倒 3 个瓶子就在 1 位置发球，想要打倒 4 个瓶子就在 2 位置发球。

现在他想要打倒 m 个瓶子。他告诉你每个位置的瓶子数，请你给他一个发球位置。

## 输入格式

第一行包含一个正整数 n，表示位置数。

第二行包含 n 个正整数，第 i 个数。表示第 i 个位置的瓶子数，保证各个位置的瓶子数不同。

第三行包含一个正整数 Q，表示 DL 发球的次数。

第四行至文件末尾，每行包含一个正整数 m，表示 DL 需要打倒 m 个瓶子。

## 输出格式

共 Q 行。每行包含一个整数，第 i 行的整数表示 DL 第 i 次的发球位置。若无解，则输出 0。

## 样例 #1

### 样例输入 #1

```
5
1 2 4 3 5
2
4
7
```

### 样例输出 #1

```
3
0
```

## 提示

【数据范围】

对于 50%的数据，1 ≤ n,Q ≤ 1000，1 ≤ai,M ≤ 10^5^

对于 100%的数据，1 ≤ n,Q ≤ 100000，1 ≤ai,M ≤ 10^9^



```c++
#include<bits/stdc++.h>

using namespace std;

int n;
map<int, int> m;

int main() {
    cin >> n;

    for (int i = 1; i <= n; ++i) {
        int a;
        scanf("%d", &a);
        m[a] = i;
    }

    int t;
    cin >> t;
    while (t--) {
        int a;
        scanf("%d", &a);
        printf("%d\n", m[a]);
    }
    return 0;
}
```

**积极利用STL，这道题非常的水**



# 集合

## 题目描述

Caima 给你了所有 $[a,b]$ 范围内的整数。一开始每个整数都属于各自的集合。每次你需要选择两个属于不同集合的整数，如果这两个整数拥有大于等于 $p$ 的公共质因数，那么把它们所在的集合合并。

重复如上操作，直到没有可以合并的集合为止。

现在 Caima 想知道，最后有多少个集合。

## 输入格式

一行，共三个整数 $a,b,p$，用空格隔开。

## 输出格式

一个数，表示最终集合的个数。

## 样例 #1

### 样例输入 #1

```
10 20 3
```

### 样例输出 #1

```
7
```

## 提示

#### 样例 1 解释

对于样例给定的数据，最后有 $\{10,20,12,15,18\},\{13\},\{14\},\{16\},\{17\},\{19\},\{11\}$ 共 $7$ 个集合，所以输出应该为 $7$。

#### 数据规模与约定
- 对于 $80\%$ 的数据，$1 \leq a \leq b \leq 10^3$。
- 对于 $100%$ 的数据，$1 \leq a \leq b \leq 10^5,2 \leq p \leq b$。



```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e5 + 10;

int p[N];
int a, b, minp;
bool st[N];
int primes[N];
int cnt;

int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

void get(int n) {
    for (int i = 2; i <= n; ++i) {
        if (!st[i]) {
            primes[cnt++] = i;
            for (int j = i; j <= n; j += i) st[j] = true;
        }
    }
}

int main() {
    cin >> a >> b >> minp;
    get(b / 2);
    for (int i = a; i <= b; ++i) p[i] = i;
    int pp = 0;
    while (primes[pp] < minp && pp < cnt) ++pp;
    while (pp < cnt) {
        int first = a;
        while (first < b && first % primes[pp] != 0) first++;
        for (int second = first + primes[pp]; second <= b; second += primes[pp]) {
            p[find(second)] = find(first);
        }
        pp++;
    }
    memset(st, false, sizeof st);
    for (int i = a; i <= b; ++i) st[find(i)] = true;
    int res = 0;
    for (int i = a; i <= b; ++i) if (st[i]) res++;
    cout << res;
    return 0;
} 
```



# [NOIP2010 提高组] 关押罪犯

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1-N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了$N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？

## 输入格式

每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1<a_j\leq b_j\leq N, 0 < c_j\leq 10^9$，且每对罪犯组合只出现一次。

## 输出格式

共 $1$ 行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 `0`。

## 样例 #1

### 样例输入 #1

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884
```

### 样例输出 #1

```
3512
```

## 提示

【输入输出样例说明】罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

 ![](%E5%BA%93/298.png) 

【数据范围】  

对于 $30\%$的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。



```c++
#include <cstdio>
#include <cstring>

using namespace std;

const int N = 20010, M = 200010;

int n, m;
int h[N], e[M], w[M], ne[M], idx;
int color[N];

void add(int a, int b, int c) {
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

bool dfs(int u, int c, int limit) {
    color[u] = c;
    for (int i = h[u]; ~i; i = ne[i]) {
        if (w[i] <= limit) continue;
        int j = e[i];
        if (color[j]) {
            if (color[j] == c) return false;
        } else if (!dfs(j, 3 - c, limit)) return false;
    }
    return true;
}

bool check(int limit) {
    memset(color, 0, sizeof color);
    for (int i = 1; i <= n; i++)
        if (color[i] == 0)
            if (!dfs(i, 1, limit))
                return false;
    return true;
}

int main() {
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while (m--) {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
        add(b, a, c);
    }
    int l = 0, r = 1e9;
    while (l < r) {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    printf("%d\n", l);
    return 0;
}
```



将罪犯当做点，罪犯之间的仇恨关系当做点与点之间的无向边，边的权重是罪犯之间的仇恨值，那么原问题变成：将所有点分成两组，使得各组内边的权重的最大值尽可能小。

我们在 [0，10^9^] 之间枚举最大边权 limit，当 limit 固定之后，剩下的问题就是：判断能否将所有点分成两组，使得所有权值大于 limit 的边都在组间，而不在组内。也就是判断由所有点以及所有权值大于 limit 的边构成的新图是否是二分图



> 可以参考AcWing 860. 染色法判定二分图
>
> https://www.acwing.com/problem/content/862/



![image-20230112154438145](%E5%BA%93/image-20230112154438145.png)



**提问：这里二分的结果是怎么保证一定是所给的那些边里面的？**

<u>二分的结果如果不是某条边的权值，那就必然不是最小值，因为可以将这个结果减小到某条边的权值</u>

<u>这里二分的是监狱内部最大边的权值，如果边小于等于 limit，那么这俩点可以在一个监狱里，只有大于 limit 时才不能在监狱里。所以可以把小于等于 limit 的点跳过</u>



# C++中set用法详解

## 关于 set

C++ STL 之所以得到广泛的赞誉，也被很多人使用，不只是提供了像vector, string, list等方便的容器，更重要的是STL封装了许多复杂的数据结构算法和大量常用数据结构操作。vector封装数组，list封装了链表，map和set封装了二叉树等，在封装这些数据结构的时候，STL按照程序员的使用习惯，以成员函数方式提供的常用操作，如：插入、排序、删除、查找等。让用户在STL使用过程中，并不会感到陌生。

关于set，必须说明的是set关联式容器。set作为一个容器也是用来存储同一数据类型的数据类型，并且能从一个数据集合中取出数据，在set中每个元素的值都唯一，而且系统能根据元素的值自动进行排序。**应该注意的是set中数元素的值不能直接被改变。**C++ STL中标准关联容器set, multiset, map, multimap内部采用的就是一种非常高效的平衡检索二叉树：红黑树，也成为RB树(Red-Black Tree)。RB树的统计性能要好于一般平衡二叉树，所以被STL选择作为了关联容器的内部结构。

## 关于set有下面几个问题：

### 为何map和set的插入删除效率比用其他序列容器高？

大部分人说，很简单，因为**对于关联容器来说，不需要做内存拷贝和内存移动**。说对了，确实如此。set容器内所有元素都是以节点的方式来存储，其节点结构和链表差不多，指向父节点和子节点。结构图可能如下：

 

　       A
　  /         \
　 B           C
   /   \       /    \
  D    E    F      G

因此插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。

### 为何每次insert之后，以前保存的iterator不会失效？

**iterator这里就相当于指向节点的指针，内存没有变，指向内存的指针怎么会失效呢**(当然被删除的那个元素本身已经失效了)。相对于vector来说，每一次删除和插入，指针都有可能失效，调用push_back在尾部插入也是如此。因为为了保证内部数据的连续存放，iterator指向的那块内存在删除和插入过程中可能已经被其他内存覆盖或者内存已经被释放了。即使时push_back的时候，容器内部空间可能不够，需要一块新的更大的内存，只有把以前的内存释放，申请新的更大的内存，复制已有的数据元素到新的内存，最后把需要插入的元素放到最后，那么以前的内存指针自然就不可用了。特别时在和find等算法在一起使用的时候，牢记这个原则：不要使用过期的iterator。

### 当数据元素增多时，set的插入和搜索速度变化如何？

如果你知道log2的关系你应该就彻底了解这个答案。在set中查找是使用二分查找，也就是说，如果有16个元素，最多需要比较4次就能找到结果，有32个元素，最多比较5次。那么有10000个呢？最多比较的次数为log10000，最多为14次，如果是20000个元素呢？最多不过15次。看见了吧，当数据量增大一倍的时候，搜索次数只不过多了1次，多了1/14的搜索时间而已。你明白这个道理后，就可以安心往里面放入元素了。



## set中常用的方法

- **begin()   　　 返回set容器的第一个元素**
- **end() 　　　　 返回set容器的最后一个元素**
- **clear()  　　   删除set容器中的所有的元素**
- **empty() 　　　判断set容器是否为空**
- **max_size() 　 返回set容器可能包含的元素最大个数**
- **size() 　　　　 返回当前set容器中的元素个数**
- **rbegin　　　　 返回的值和end()相同**
- **rend()　　　　 返回的值和rbegin()相同**
- **count()            用来查找set中某个某个键值出现的次数，这个函数在set并不是很实用，因为一个键值在set只可能出现0或1次，这样就变成了判断某一键值是否在set出现过了。**
- **erase(iterator)                 删除定位器iterator指向的值**
- **erase(first,second)          删除定位器first和second之间的值**
- **erase(key_value)             删除键值key_value的值**
- **find()                  返回给定值值得定位器，如果没找到则返回end()**
- **lower_bound(key_value)             返回第一个大于等于key_value的定位器**
- **upper_bound(key_value)             返回最后一个大于等于key_value的定位器**

## C++直接修改std::set元素的方法

元素在std::set中构造后，如果需要查找，则调用find成员函数，但是该方式有一个致命的缺陷，就是返回的是一个常指针，无法通过指针更改元素的值。这样做也是有意义的，因为如果是int之类的元素，本身相当于键值，更改键值就破坏了原来红黑树的结构了。但是，有些情况下，我们自定义了一些数据结构，但是需要更改结构的非键值部分，此时不想拿出再插入。更特别的情况是元素的不可构造和不可移动的，此时就需要一个更一般的方案。

一个通用的解决方案是，把结构中可能需要更改的元素使用智能指针进行保存，利用find函数找到结构的索引，再通过索引获取指针进行操作。

> C++直接修改std::set元素的方法：
>
> https://blog.csdn.net/qq_35976351/article/details/85331368



# [JLOI2011]不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 输入格式

**本题有多组数据。**

第一行一个整数 $T$，表示数据组数。

对于每组数据：

第一行一个整数 $n$。

第二行 $n$ 个数，表示给定的数。

## 输出格式

对于每组数据，输出一行，为去重后剩下的数，两个数之间用一个空格隔开。

## 样例 #1

### 样例输入 #1

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 样例输出 #1

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

## 提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

**STL**

```c++
#include <bits/stdc++.h>

using namespace std;
unordered_set<int> s;
int n, t;

void solve() {
    cin >> n;
    s.clear();
    int x;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &x);
        if (s.find(x) == s.end()) {
            printf("%d ", x);
            s.insert(x);
        }
    }
    puts("");
}

int main() {
    cin >> t;
    while (t--) {
        solve();
    }
    return 0;
} 
```

今天早上看见 xht37 说加强了数据。然后 `map/set` 就被卡掉了。

但是 C++11 的 `unordered_map` 是哈希，能过！

`unordered_map` 的定义与用法都与 `map` 差不多，只不过是用Hash来存储的，判断是O(1)的。

而`map`判断是O(logn)的。



# C++ STL简介

## vector

变长数组、倍增的思想

- ​    size()  返回元素个数
- ​    empty()  返回是否为空
- ​    clear()  清空
- ​    front()/back()
- ​    push_back()/pop_back()
- ​    begin()/end()
- ​    []
- ​    支持比较运算，按字典序

## pair<int, int>

- ​    first, 第一个元素
- ​    second, 第二个元素
- ​    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

## string

字符串

- ​    size()/length()  返回字符串长度
- ​    empty()
- ​    clear()
- ​    substr(起始下标，(子串长度))  返回子串
- ​    c_str()  返回字符串所在字符数组的起始地址

## queue

队列

- ​    size()
- ​    empty()
- ​    push()  向队尾插入一个元素
- ​    front()  返回队头元素
- ​    back()  返回队尾元素
- ​    pop()  弹出队头元素

## priority_queue

优先队列、默认是大根堆

- ​    size()

- ​    empty()

- ​    push()  插入一个元素

- ​    top()  返回堆顶元素

- ​    pop()  弹出堆顶元素

- ​    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

  ​    或者也可以直接插入一个数的负值，负数由大到小排序，相当于正数由小到大排序

## stack

栈

- ​    size()
- ​    empty()
- ​    push()  向栈顶插入一个元素
- ​    top()  返回栈顶元素
- ​    pop()  弹出栈顶元素

## deque

双端队列

- ​    size()
- ​    empty()
- ​    clear()
- ​    front()/back()
- ​    push_back()/pop_back()
- ​    push_front()/pop_front()
- ​    begin()/end()
- ​    []

## set  map  multiset  multimap

基于平衡二叉树（红黑树），动态维护有序序列

- ​    size()
- ​    empty()
- ​    clear()
- ​    begin()/end()
- ​    ++, -- 返回前驱和后继，时间复杂度 O(logn)

### set/multiset

所有操作的时间复杂度都是  logn

- ​    insert()  插入一个数
- ​    find()  查找一个数     如果不存在的话返回 end() 迭代器
- ​    count()  返回某一个数的个数
- ​    erase()
  1. 输入是一个数x，删除所有x     时间复杂度：O(k + logn)   k 是 x 的个数
  2. 输入一个迭代器，删除这个迭代器
- ​    lower_bound()/upper_bound()
  - lower_bound(x)  返回大于等于x的最小的数的迭代器
  - upper_bound(x)  返回大于x的最小的数的迭代器

### map/multimap

map 存储的是一个映射关系，所以存储结构是一个 pair

- ​    insert()  插入的数是一个pair
- ​    erase()  输入的参数是pair或者迭代器
- ​    find()
- ​    []  注意仅仅是 map 支持这个操作，multimap 不支持此操作。 时间复杂度是：O(logn)
- ​    lower_bound()/upper_bound()

## unordered_set  unordered_map  unordered_multiset  unordered_multimap

哈希表和上面类似，增删改查的时间复杂度是 O(1)

因为是无序的，所以不支持 lower_bound()/upper_bound()，也不支持迭代器的++，--



# [TJOI2010] 阅读理解

## 题目描述

英语老师留了 $N$ 篇阅读理解作业，但是每篇英文短文都有很多生词需要查字典，为了节约时间，现在要做个统计，算一算某些生词都在哪几篇短文中出现过。

## 输入格式

第一行为整数 $N$ ，表示短文篇数，其中每篇短文只含空格和小写字母。

按下来的 $N$ 行，每行描述一篇短文。每行的开头是一个整数 $L$ ，表示这篇短文由 $L$ 个单词组成。接下来是 $L$ 个单词，单词之间用一个空格分隔。

然后为一个整数 $M$ ，表示要做几次询问。后面有 $M$ 行，每行表示一个要统计的生词。

## 输出格式

对于每个生词输出一行，统计其在哪几篇短文中出现过，并按从小到大输出短文的序号，序号不应有重复，序号之间用一个空格隔开（注意第一个序号的前面和最后一个序号的后面不应有空格）。如果该单词一直没出现过，则输出一个空行。

## 样例 #1

### 样例输入 #1

```
3
9 you are a good boy ha ha o yeah
13 o my god you like bleach naruto one piece and so do i
11 but i do not think you will get all the points
5
you
i
o
all
naruto
```

### 样例输出 #1

```
1 2 3
2 3
1 2
3
2
```

## 提示

对于 $30\%$ 的数据， $1\le M\le 10^3$ 。

对于 $100\%$ 的数据，$1\le M\le 10^4$，$1\le N\le 10^3$ 。

每篇短文长度（含相邻单词之间的空格）$\le 5\times 10^3$ 字符，每个单词长度 $\le 20$ 字符。

每个测试点时限 $2$ 秒。

感谢@钟梓俊添加的一组数据。

```c++
#include <bits/stdc++.h>

using namespace std;
map<string, vector<int> > s;

void read(int num) {
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        string a;
        cin >> a;
        s[a].push_back(num);
        if (s[a].size() > 1 && s[a][s[a].size() - 1] == s[a][s[a].size() - 2]) s[a].erase(s[a].end() - 1);
    }
}

void solve() {
    string a;
    cin >> a;
    if (s.find(a) != s.end()) for (auto t: s[a]) printf("%d ", t);
    puts("");
}

int main() {
    int t;
    cin >> t;
    for (int i = 1; i <= t; ++i) read(i);
    cin >> t;
    while (t--) solve();
    return 0;
}
```

直接用`map<string,vecotr<int> >` 代替这题里的`trie`树，注意开`map`的时候后面两个`> >`之间要有一个空格。

用`vector`记录每个单词出现的句子位置，每遇到一个就把该单词所出现的句子的编号压入对应的`vector`里。

一套操作下来必定是默认升序排列文章序号，所以只用和前一个序号比较是不是相等就行了。

**应该要有利用`STL`的意识，但不能完全依靠`STL`，毕竟有很多东西也是`STL`现在所提供不了的。**



# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 输入格式

第一行一个正整数 $N$。

第二行 $N$ 个正整数 $A_{1\dots N}$。

## 输出格式

共 $\lfloor \frac{N + 1}2\rfloor$ 行，第 $i$ 行为 $A_{1\dots 2i - 1}$ 的中位数。

## 样例 #1

### 样例输入 #1

```
7
1 3 5 7 9 11 6
```

### 样例输出 #1

```
1
3
5
6
```

## 样例 #2

### 样例输入 #2

```
7
3 1 5 9 8 7 6
```

### 样例输出 #2

```
3
3
5
6
```

## 提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n;
int a[N];
int mid;
priority_queue<int, vector<int>, less<> > q1;//大根堆
priority_queue<int, vector<int>, greater<> > q2;//小根堆

int main() {
    cin >> n;
    scanf("%d", &a[1]);
    mid = a[1];
    cout << mid << endl;//mid初值是a[1]
    for (int i = 2; i <= n; i++) {
        scanf("%d", &a[i]);
        if (a[i] > mid) q2.push(a[i]);
        else q1.push(a[i]);
        if (i % 2 == 1) {//第奇数次加入
            while (q1.size() != q2.size()) {
                if (q1.size() > q2.size()) {
                    q2.push(mid);
                    mid = q1.top();
                    q1.pop();
                } else {
                    q1.push(mid);
                    mid = q2.top();
                    q2.pop();
                }
            }
            cout << mid << endl;
        }
    }
    return 0;
}
```

使用两个堆，大根堆维护较小的值，小根堆维护较大的值。

即小根堆的堆顶是较大的数中最小的，大根堆的堆顶是较小的数中最大的。

将大于大根堆堆顶的数（比所有大根堆中的元素都大）的数放入小根堆，小于等于大根堆堆顶的数（比所有小根堆中的元素都小）的数放入大根堆。

那么就保证了所有大根堆中的元素都小于小根堆中的元素。

于是我们发现对于大根堆的堆顶元素，有【小根堆的元素个数】个元素比该元素大，【大根堆的元素个数-1】个元素比该元素小。

同理，对于小跟堆的堆顶元素，有【大根堆的元素个数】个元素比该元素小，【小根堆的元素个数-1】个元素比该元素大。

那么维护【大根堆的元素个数】和【小根堆的元素个数】差值不大于1之后，元素个数较多的堆的堆顶元素即为当前中位数；（如果元素个数相同，那么就是两个堆堆顶元素的平均数，本题不会出现这种情况）。

根据这两个堆的定义，维护方式也很简单，把元素个数多的堆的堆顶元素取出，放入元素个数少的堆即可。



# [SHOI2009] 会场预约

## 题目背景

## 形式化描述

你需要维护一个在数轴上的线段的集合 $S$，支持两种操作：

`A l r` 表示将 $S$ 中所有与线段 $[l,r]$ 相交的线段删去，并将 $[l,r]$ 加入 $S$ 中。

`B` 查询 $S$ 中的元素数量。

对于 `A` 操作，每次还需输出删掉的元素个数。

## 题目描述

PP 大厦有一间空的礼堂，可以为企业或者单位提供会议场地。

这些会议中的大多数都需要连续几天的时间（个别的可能只需要一天），不过场地只有一个，所以不同的会议的时间申请不能够冲突。也就是说，前一个会议的结束日期必须在后一个会议的开始日期之前。所以，如果要接受一个新的场地预约申请，就必须拒绝掉与这个申请相冲突的预约。

一般来说，如果 PP 大厦方面事先已经接受了一个会场预约（例如从 $10$ 日到 $15$ 日），就不会再接受与之相冲突的预约（例如从 $12$ 日到 $17$ 日）。

不过，有时出于经济利益，PP 大厦方面有时会为了接受一个新的会场预约，而拒绝掉一个甚至几个之前预订的预约。 于是，礼堂管理员 QQ 的笔记本上经常记录着这样的信息：（本题中为方便起见，所有的日期都用一个整数表示）例如，如果一个为期 $10$ 天的会议从 $90$ 日开始到 $99$ 日，那么下一个会议最早只能在 $100$ 日开始。（此处前后矛盾，若无法理解请参考形式化描述。）

最近，这个业务的工作量与日俱增，礼堂的管理员 QQ 希望参加 SHTSC 的你替他设计一套计算机系统，方便他的工作。这个系统应当能执行下面两个操作：

`A` 操作：有一个新的预约是从 $start$ 日到 $end$ 日，并且拒绝掉所有与它相冲突的预约。执行这个操作的时候，你的系统应当返回为了这个新预约而拒绝掉的预约个数，以方便 QQ 与自己的记录相校对。

`B` 操作：请你的系统返回当前的仍然有效的预约的总数。

## 输入格式

第一行一个正整数 $n$，表示操作个数。  
接下来 $n$ 行，每行表示一个操作，都是上面两种中的一个。

## 输出格式

输出 $n$ 行，每行一个整数，表示对应操作的答案。

## 样例 #1

### 样例输入 #1

```
6
A 10 15
A 17 19
A 12 17
A 90 99
A 11 12
B
```

### 样例输出 #1

```
0
0
2
0
1
2
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 2\times 10^5$，$1\le l \le r \le 10^5$。

**一个非常简单的STL做法（非常好想，代码很短）**

```c++
#include<bits/stdc++.h>

using namespace std;
int n;

struct node {
    int l, r;

    bool operator<(const node &w) const {
        return r < w.l;
    }
};

set<node> s;

int main() {
    cin >> n;
    char c;
    int a, b;
    for (int i = 0; i < n; ++i) {
        cin >> c;
        if (c == 'A') {
            cin >> a >> b;
            struct node temp = (node) {a, b};
            int tot = 0;
            auto t = s.find(temp);
            while (t != s.end()) {
                tot++;
                s.erase(t);
                t = s.find(temp);
            }
            cout << tot << endl;
            s.insert(temp);
        } else {
            cout << s.size() << endl;
        }
    }
    return 0;
}
```

题意已经暗示的很明确要你使用平衡树了，~~但我不会平衡树~~

首先考虑A操作，由于STL的`set`有相同元素只保留一个的特性，因此我们不难想到令有冲突的预约相等，这样我们就可以很方便的用`.find()`这个函数来完成A操作了。

怎么令它们相等呢？

其实也很简单，由于使用自定义数据类型的`set`要重载运算符，因此我们可以这样：

```c++
struct node {
    int l, r;

    bool operator<(const node &w) const {
        return r < w.l;
    }
};
```

这样对于两个`node`类型的结构体a，b来说，`a<b`就代表a完全在b的左边，`a>b`就代表a完全在b的右边，`a==b`就代表a与b有冲突(有重叠部分)。



> 等于的定义是`a < b == false && b < a == false`，太妙了



对于B操作，直接输出set里元素的个数就好了。



**本题另外一种用树状数组的做法**

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, tr[N], endd[N], ans, del;

int lowbit(int x) {
    return x & -x;
}

void add(int x, int c) {
    for (int i = x; i <= N; i += lowbit(i)) {
        tr[i] += c;
    }
}

int ask(int x) {
    int res = 0;
    for (int i = x; i >= 1; i -= lowbit(i)) {
        res += tr[i];
    }
    return res;
}

int main() {
    cin >> n;
    char c;
    int st, ed;
    for (int i = 0; i < n; ++i) {
        cin >> c;
        if (c == 'A') {
            del = 0;
            cin >> st >> ed;
            for (int p; (p = ask(ed));) {
                int l = 0, r = ed;
                while (l < r) {
                    int mid = l + r + 1 >> 1;
                    if (ask(mid) < p) l = mid;
                    else r = mid - 1;
                }
                ++l;
                if (endd[l] >= st) {
                    ans--;
                    del++;
                    add(l, -1);
                } else {
                    break;
                }
            }
            add(st, 1);
            ans++;
            endd[st] = ed;
            cout << del << endl;
        } else {
            cout << ans << endl;
        }
    }
    return 0;
} 
```

注意这个二分写法

```c++
int l = 0, r = ed;
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (ask(mid) < p) l = mid;
    else r = mid - 1;
}
++l;
```

`if`中间只能是`<`进行判断，不可以用`<=`，不然会出错，想想为什么？（提示：树状数组的性质）

二分完成之后要将`l`增加1，想想为什么？（提示：树状数组的性质）
