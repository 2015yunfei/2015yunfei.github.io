https://www.luogu.com.cn/training/112

# [USACO1.5]八皇后 Checker Challenge

## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

 ![](./库/60.png) 

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。

## 输入格式

一行一个正整数 $n$，表示棋盘是 $n \times n$ 大小的。

## 输出格式

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

## 样例 #1

### 样例输入 #1

```
6
```

### 样例输出 #1

```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 15;
int n, cnt, a[N], sum;
bool col[N], dg[N * 2], udg[N * 2];

void dfs(int u) {
    if (u == n + 1) {
        if (cnt < 3) {
            for (int i = 1; i <= n; ++i) printf("%d ", a[i]);
            cout << endl;
            cnt++;
        }
        sum++;
        return;
    }
    for (int i = 1; i <= n; ++i) {
        if (!col[i] && !dg[u + i] && !udg[n - u + i]) {
            col[i] = true;
            dg[u + i] = true;
            udg[n - u + i] = true;
            a[u] = i;
            dfs(u + 1);
            col[i] = false;
            dg[u + i] = false;
            udg[n - u + i] = false;
        }
    }
}

int main() {
    cin >> n;
    dfs(1);
    cout << sum;
    return 0;
} 
```

**注意对角线数组要开至少两倍大小**

左下到右上`dg[u + i]`

左上到右下`udg[n - u + i]`

其中`u`是枚举的行数，`i`是列号

![3019_d7a30075cc-微信图片_20220505182615](./库/3019_d7a30075cc-微信图片_20220505182615.jpg)



# kkksc03考前临时抱佛脚

## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。

## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。

## 输入格式

本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。

第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。

第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。

第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。

第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。

## 输出格式

输出一行,为复习完毕最短时间。

## 样例 #1

### 样例输入 #1

```
1 2 1 3		
5
4 3
6
2 4 3
```

### 样例输出 #1

```
20
```

## 提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 25;
int t1[N], t2[N], t3[N], t4[N], s1, s2, s3, s4;
int m1 = 1e9, m2 = 1e9, m3 = 1e9, m4 = 1e9;
int tt1, tt2;

void dfs1(int u) {
    if (u == s1) {
        m1 = min(m1, max(tt1, tt2));
        return;
    }
    tt1 += t1[u];
    dfs1(u + 1);
    tt1 -= t1[u];
    tt2 += t1[u];
    dfs1(u + 1);
    tt2 -= t1[u];
}

void dfs2(int u) {
    if (u == s2) {
        m2 = min(m2, max(tt1, tt2));
        return;
    }
    tt1 += t2[u];
    dfs2(u + 1);
    tt1 -= t2[u];
    tt2 += t2[u];
    dfs2(u + 1);
    tt2 -= t2[u];
}

void dfs3(int u) {
    if (u == s3) {
        m3 = min(m3, max(tt1, tt2));
        return;
    }
    tt1 += t3[u];
    dfs3(u + 1);
    tt1 -= t3[u];
    tt2 += t3[u];
    dfs3(u + 1);
    tt2 -= t3[u];
}

void dfs4(int u) {
    if (u == s4) {
        m4 = min(m4, max(tt1, tt2));
        return;
    }
    tt1 += t4[u];
    dfs4(u + 1);
    tt1 -= t4[u];
    tt2 += t4[u];
    dfs4(u + 1);
    tt2 -= t4[u];
}

int main() {
    cin >> s1 >> s2 >> s3 >> s4;
    for (int i = 0; i < s1; ++i) cin >> t1[i];
    for (int i = 0; i < s2; ++i) cin >> t2[i];
    for (int i = 0; i < s3; ++i) cin >> t3[i];
    for (int i = 0; i < s4; ++i) cin >> t4[i];
    dfs1(0);
    dfs2(0);
    dfs3(0);
    dfs4(0);
    cout << m1 + m2 + m3 + m4;
    return 0;
}
```

**对于每个习题集都单独进行DFS搜索**



# 马的遍历

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

## 输入格式

输入只有一行四个整数，分别为 $n, m, x, y$。

## 输出格式

一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。

## 样例 #1

### 样例输入 #1

```
3 3 1 1
```

### 样例输出 #1

```
0    3    2    
3    -1   1    
2    1    4
```

## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 410;
int n, m, g[N][N], x, y;
int dx[8] = {-2, -2, -1, -1, 1, 1, 2, 2};
int dy[8] = {1, -1, 2, -2, 2, -2, 1, -1};
bool st[N][N];

void bfs(int x, int y) {
    st[x][y] = true;
    queue<PII> q;
    q.push({x, y});
    while (q.size()) {
        auto t = q.front();
        q.pop();
        for (int i = 0; i < 8; ++i) {
            int xx = t.first + dx[i], yy = t.second + dy[i];
            if (xx >= 1 && yy >= 1 && xx <= n && yy <= m && !st[xx][yy]) {
                st[xx][yy] = true;
                g[xx][yy] = g[t.first][t.second] + 1;
                q.push({xx, yy});
            }
        }
    }
}

int main() {
    cin >> n >> m >> x >> y;
    bfs(x, y);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (st[i][j]) printf("%d ", g[i][j]);
            else printf("-1 ");
        }
        cout << endl;
    }
    return 0;
}
```

**宽度优先搜索**



# 奇怪的电梯

## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？

## 输入格式

共二行。  

第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \le N \le 200$，$1 \le A, B \le N$）。

第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。

## 输出格式

一行，即最少按键次数，若无法到达，则输出 `-1`。

## 样例 #1

### 样例输入 #1

```
5 1 5
3 3 1 2 5
```

### 样例输出 #1

```
3
```

## 提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 210;
int n, a, b, t[N], dist[N];
bool st[N];

void bfs(int u) {
    queue<int> q;
    q.push(u);
    st[u] = true;
    while (q.size()) {
        int tt = q.front();
        q.pop();
        int tar = tt + t[tt];
        if (tar <= n && !st[tar]) {
            q.push(tar);
            st[tar] = true;
            dist[tar] = dist[tt] + 1;
        }
        tar = tt - t[tt];
        if (tar >= 1 && !st[tar]) {
            q.push(tar);
            st[tar] = true;
            dist[tar] = dist[tt] + 1;
        }
    }
    if (st[b]) cout << dist[b];
    else cout << "-1";
}

int main() {
    cin >> n >> a >> b;
    for (int i = 1; i <= n; ++i) cin >> t[i];
    if (a == b) cout << "0";
    else bfs(a);
    return 0;
}
```

**宽度优先搜索**



# [USACO08FEB]Meteor Shower S

## 题面翻译

## 题目描述
贝茜听说一场特别的流星雨即将到来：这些流星会撞向地球，并摧毁它们所撞击的任何东西。她为自己的安全感到焦虑，发誓要找到一个安全的地方（一个永远不会被流星摧毁的地方）。

如果将牧场放入一个直角坐标系中，贝茜现在的位置是原点，并且，贝茜不能踏上一块被流星砸过的土地。

根据预报，一共有 $M$ 颗流星 $(1\leq M\leq 50,000)$ 会坠落在农场上，其中第 $i$ 颗流星会在时刻 $T_i$ 砸在坐标为 $(X_i,Y_i)(0\leq X_i\leq 300$，$0\leq Y_i\leq 300)$ 的格子里。流星的力量会将它所在的格子，以及周围 $4$ 个相邻的格子都化为焦土，当然贝茜也无法再在这些格子上行走。

贝茜在时刻 $0$ 开始行动，它只能在第一象限中，平行于坐标轴行动，每 $1$ 个时刻中，她能移动到相邻的（一般是 $4$ 个）格子中的任意一个，当然目标格子要没有被烧焦才行。如果一个格子在时刻 $t$ 被流星撞击或烧焦，那么贝茜只能在 $t$ 之前的时刻在这个格子里出现。 贝西一开始在 $(0,0)$。

请你计算一下，贝茜最少需要多少时间才能到达一个安全的格子。如果不可能到达输出 $−1$。
## 输入格式
共 $M+1$ 行，第 $1$ 行输入一个整数 $M$，接下来的 $M$ 行每行输入三个整数分别为 $X_i, Y_i, T_i$。
## 输出格式
贝西到达安全地点所需的最短时间，如果不可能，则为 $-1$。

## 题目描述

Bessie hears that an extraordinary meteor shower is coming; reports say that these meteors will crash into earth and destroy anything they hit. Anxious for her safety, she vows to find her way to a safe location (one that is never destroyed by a meteor) . She is currently grazing at the origin in the coordinate plane and wants to move to a new, safer location while avoiding being destroyed by meteors along her way.

The reports say that M meteors (1 ≤ M ≤ 50,000) will strike, with meteor i will striking point (Xi, Yi) (0 ≤ Xi ≤ 300; 0 ≤ Yi ≤ 300) at time Ti (0 ≤ Ti  ≤ 1,000). Each meteor destroys the point that it strikes and also the four rectilinearly adjacent lattice points.

Bessie leaves the origin at time 0 and can travel in the first quadrant and parallel to the axes at the rate of one distance unit per second to any of the (often 4) adjacent rectilinear points that are not yet destroyed by a meteor. She cannot be located on a point at any time greater than or equal to the time it is destroyed).

Determine the minimum time it takes Bessie to get to a safe place.

## 输入格式

\* Line 1: A single integer: M

\* Lines 2..M+1: Line i+1 contains three space-separated integers: Xi, Yi, and Ti

## 输出格式

\* Line 1: The minimum time it takes Bessie to get to a safe place or -1 if it is impossible.

## 样例 #1

### 样例输入 #1

```
4
0 0 2
2 1 2
1 1 2
0 3 5
```

### 样例输出 #1

```
5
```

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 310, M = 5e4 + 10;
int m, dist[N][N];// dist 其实表示时间
bool st[N][N], never[N][N];// st 表示某个时刻被砸的位置  never 表示永远安全的位置
int dx[4] = {1, 0, 0, -1};
int dy[4] = {0, 1, -1, 0};

struct H {
    int x, y, t;
    bool operator<(const H &W) const {
        return t < W.t;
    }
} h[M];

void bfs() {
    int index = 0;
    while (h[index].t <= 0) {
        st[h[index].x][h[index].y] = false;
        for (int j = 0; j < 4; ++j) {
            int x = h[index].x + dx[j];
            int y = h[index].y + dy[j];
            if (x >= 0 && y >= 0) st[x][y] = false;
        }
        index++;
    }
    queue<PII> q;
    q.push({0, 0});
    while (q.size()) {
        auto v = q.front();
        q.pop();

        if (never[v.first][v.second]) {
            cout << dist[v.first][v.second];
            return;
        }

        while (index < m && h[index].t <= dist[v.first][v.second]) {
            st[h[index].x][h[index].y] = false;
            for (int j = 0; j < 4; ++j) {
                int x = h[index].x + dx[j];
                int y = h[index].y + dy[j];
                if (x >= 0 && y >= 0) st[x][y] = false;
            }
            index++;
        }

        if (st[v.first][v.second]) st[v.first][v.second] = false;
        else continue;

        for (int i = 0; i < 4; ++i) {
            int x = v.first + dx[i], y = v.second + dy[i];
            if (x >= 0 && y >= 0 && st[x][y]) {
                q.push({x, y});
                dist[x][y] = dist[v.first][v.second] + 1;
            }
        }
    }
    cout << "-1";
}

int main() {
    cin >> m;
    memset(never, true, sizeof never);
    memset(st, true, sizeof st);
    for (int i = 0; i < m; ++i) {
        scanf("%d%d%d", &h[i].x, &h[i].y, &h[i].t);
        never[h[i].x][h[i].y] = false;
        for (int j = 0; j < 4; ++j) {
            int x = h[i].x + dx[j], y = h[i].y + dy[j];
            if (x >= 0 && y >= 0) never[x][y] = false;
        }
    }
    sort(h, h + m);
    bfs();
    return 0;
}
```

**宽度优先搜索**

这个算法看着复杂，但是实际运行非常快！因为时间复杂度很低！是线性复杂度！



# [NOIP2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 输入格式

第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k<n$）。

第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。

## 输出格式

输出一个整数，表示种类数。

## 样例 #1

### 样例输入 #1

```
4 3
3 7 12 19
```

### 样例输出 #1

```
1
```

## 提示

**【题目来源】**

NOIP 2002 普及组第二题



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 25;
int n, k, num, cnt, sum, a[N];
bool st[N];

bool check(int num) {
    if (num < 2) return false;
    for (int i = 2; i <= num / i; ++i) {
        if (num % i == 0) return false;
    }
    return true;
}

void dfs(int x) {
    if (cnt == k) {
        if (check(num)) sum++;
        return;
    }
    if (x > n) return;
    cnt++;
    num += a[x - 1];
    dfs(x + 1);
    cnt--;
    num -= a[x - 1];
    dfs(x + 1);
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];
    dfs(1);
    cout << sum;
    return 0;
}
```



# [COCI2008-2009#2] PERKET

## 题目描述

Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。

众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。

另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。

## 输入格式

第一行一个整数 $n$，表示可供选用的食材种类数。

接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。

## 输出格式

一行一个整数，表示可能的总酸度和总苦度的最小绝对差。

## 样例 #1

### 样例输入 #1

```
1
3 10
```

### 样例输出 #1

```
7
```

## 样例 #2

### 样例输入 #2

```
2
3 8
5 8
```

### 样例输出 #2

```
1
```

## 样例 #3

### 样例输入 #3

```
4
1 7
2 6
3 8
4 9
```

### 样例输出 #3

```
1
```

## 提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。
#### 说明
- 本题满分 $70$ 分。
- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。



```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 13;
int n;
int cnt;
int suan[N], ku[N];
int suandu=1, kudu, minn=2e9;

void dfs(int x) {
    if (x > n) {
        if (cnt == 0) return;
        minn = min(minn, abs(suandu - kudu));
        return;
    }

    cnt++;
    suandu *= suan[x];
    kudu += ku[x];
    dfs(x + 1);
    cnt--;
    suandu /= suan[x];
    kudu -= ku[x];
    dfs(x + 1);
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> suan[i] >> ku[i];
    dfs(1);
    cout << minn;
    return 0;
}
```



# 迷宫

## 题目描述

给定一个 $N \times M$ 方格的迷宫，迷宫里有 $T$ 处障碍，障碍处不可通过。

在迷宫中移动有上下左右四种方式，每次只能移动一个方格。数据保证起点上没有障碍。

给定起点坐标和终点坐标，每个方格最多经过一次，问有多少种从起点坐标到终点坐标的方案。

## 输入格式

第一行为三个正整数 $N,M,T$，分别表示迷宫的长宽和障碍总数。

第二行为四个正整数 $SX,SY,FX,FY$，$SX,SY$ 代表起点坐标，$FX,FY$ 代表终点坐标。

接下来 $T$ 行，每行两个正整数，表示障碍点的坐标。

## 输出格式

输出从起点坐标到终点坐标的方案总数。

## 样例 #1

### 样例输入 #1

```
2 2 1
1 1 2 2
1 2
```

### 样例输出 #1

```
1
```

## 提示

对于 $100\%$ 的数据，$1 \le N,M \le 5$，$1 \le T \le 10$，$1 \le SX,FX \le n$，$1 \le SY,FY \le m$。





```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 10;
int n, m, t, cnt, sx, sy, fx, fy;
bool st[N][N];
bool f[N][N];
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};

void dfs(int x, int y) {
    if (x == fx && y == fy) {
        cnt++;
        return;
    }

    for (int i = 0; i < 4; ++i) {
        int xx = x + dx[i], yy = y + dy[i];
        if (xx > 0 && xx <= n && yy > 0 && yy <= m && !f[xx][yy] && !st[xx][yy]) {
            st[xx][yy] = true;
            dfs(xx, yy);
            st[xx][yy] = false;
        }
    }
}

int main() {
    cin >> n >> m >> t;
    cin >> sx >> sy >> fx >> fy;
    st[sx][sy] = true;
    while (t--) {
        int x, y;
        cin >> x >> y;
        f[x][y] = true;
    }
    dfs(sx, sy);
    cout << cnt;
    return 0;
}
```



# [NOIP2000 提高组] 单词接龙

## 题目背景

注意：本题为上古 NOIP 原题，不保证存在靠谱的做法能通过该数据范围下的所有数据。

## 题目描述

单词接龙是一个与我们经常玩的成语接龙相类似的游戏，现在我们已知一组单词，且给定一个开头的字母，要求出以这个字母开头的最长的“龙”（每个单词都最多在“龙”中出现两次），在两个单词相连时，其重合部分合为一部分，例如 `beast` 和 `astonish`，如果接成一条龙则变为 `beastonish`，另外相邻的两部分不能存在包含关系，例如 `at` 和 `atide` 间不能相连。

## 输入格式

输入的第一行为一个单独的整数 $n$ 表示单词数，以下 $n$ 行每行有一个单词，输入的最后一行为一个单个字符，表示“龙”开头的字母。你可以假定以此字母开头的“龙”一定存在。

## 输出格式

只需输出以此字母开头的最长的“龙”的长度。

## 样例 #1

### 样例输入 #1

```
5
at
touch
cheat
choose
tact
a
```

### 样例输出 #1

```
23
```

## 提示

样例解释：连成的“龙”为 `atoucheatactactouchoose`。

$n \le 20$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 35;
int n, len;
string s[N];
char head;
int sum[N];

string con(string a, string b) {
    if (a.find(b, (int) (a.length() - b.length() + 1)) != -1) return "00";
    for (int i = a.length() - 1; i >= max(1, (int) (a.length() - b.length() + 1)); --i) {
        int j = i;
        int k = 0;
        while (j < a.length()) {
            if (a[j] == b[k]) k++, j++;
            else break;
        }
        if (j == a.length()) {
            string ans;
            for (int w = 0; w < i; ++w) ans += a[w];
            ans += b;
            return ans;
        }
    }
    return "00";
}

void dfs(string temp) {
    len = max(len, (int) temp.length());
    for (int i = 0; i < n; ++i) {
        if (sum[i] > 0) {
            string ss = con(temp, s[i]);
            if (ss != "00") {
                sum[i]--;
                dfs(ss);
                sum[i]++;
            }
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> s[i];
    cin >> head;
    for (int i = 0; i < n; ++i) {
        if (head == s[i][0]) {
            for (int i = 0; i < n; ++i) sum[i] = 2;
            sum[i]--;
            dfs(s[i]);
            sum[i]++;
        }
    }
    cout << len;
    return 0;
}
```

- 两个单词合并时，合并部分取的是**最小重叠部分**，所以要倒序开始循环，先比较最后一位
- **相邻的两部分不能存在包含关系**就是说如果存在包含关系，就不能标记为使用过。
- 每个单词最多出现两次
- 单词可以不全用完
- 不可以包含：一旦包含了和不用岂不是一样
- 按照贪心原则，重叠部分应该越少越好



# 单词方阵

## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉,因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。例如：

```cpp
输入：
    8                     输出：
    qyizhong              *yizhong
    gydthkjy              gy******
    nwidghji              n*i*****
    orbzsfgz              o**z****
    hhgrhwth              h***h***
    zzzzzozo              z****o**
    iwdfrgng              i*****n*
    yyyygggg              y******g
```

## 输入格式

第一行输入一个数 $n$。($7 \le n \le 100$)。

第二行开始输入 $n \times n$ 的字母矩阵。

## 输出格式

突出显示单词的 $n \times n$ 矩阵。

## 样例 #1

### 样例输入 #1

```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
```

### 样例输出 #1

```
*******
*******
*******
*******
*******
*******
*******
```

## 样例 #2

### 样例输入 #2

```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg
```

### 样例输出 #2

```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g
```

**一个题解的做法**

将`yizhong`利用数组连成一个串，看上去很花哨，但是没啥用，本质是还是DFS

把最标准的DFS写好即可

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 110;

char chess[N][N];
char ne[200];
bool st[N][N];
int dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};
int dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};
int n;

bool dfs(int x, int y, char l, int k) {
    if (chess[x][y] != l) return false;
    if (l == 'g') {
        st[x][y] = true;
        return true;
    }

    int xx = x + dx[k];
    int yy = y + dy[k];
    if (xx >= 1 && yy >= 1 && xx <= n && yy <= n) {
        if (dfs(xx, yy, ne[l], k)) {
            st[x][y] = true;
            return true;
        }
    }
    return false;
}

int main() {
    cin >> n;
    ne['y'] = 'i';
    ne['i'] = 'z';
    ne['z'] = 'h';
    ne['h'] = 'o';
    ne['o'] = 'n';
    ne['n'] = 'g';

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            cin >> chess[i][j];
        }
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (chess[i][j] == 'y') {
                for (int k = 0; k < 8; ++k) {
                    int xx = i + dx[k];
                    int yy = j + dy[k];
                    if (xx >= 1 && yy >= 1 && xx <= n && yy <= n)
                        if (dfs(xx, yy, ne['y'], k)) {
                            st[i][j] = true;
                        }
                }
            }
        }
    }

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (st[i][j]) printf("%c", chess[i][j]);
            else printf("*");
        }
        cout << endl;
    }
    return 0;
}
```

**自己写得**

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 110;

char chess[N][N];
char ne[10] = {'y', 'i', 'z', 'h', 'o', 'n', 'g'};
bool st[N][N];
int dx[8] = {1, 1, 1, 0, 0, -1, -1, -1};
int dy[8] = {1, 0, -1, 1, -1, 1, 0, -1};
int n;

bool dfs(int x, int y, int l, int k) {
    if (chess[x][y] != ne[l]) return false;
    if (ne[l] == 'g') {
        st[x][y] = true;
        return true;
    }
    int xx = x + dx[k], yy = y + dy[k];
    if (xx >= 1 && yy >= 1 && xx <= n && yy <= n && dfs(xx, yy, l + 1, k)) {
        st[x][y] = true;
        return true;
    }
    return false;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) cin >> chess[i][j];
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (chess[i][j] == 'y') {
                for (int k = 0; k < 8; ++k) {
                    int xx = i + dx[k], yy = j + dy[k];
                    if (xx >= 1 && yy >= 1 && xx <= n && yy <= n)
                        if (dfs(xx, yy, 1, k)) {
                            st[i][j] = true;
                        }
                }
            }
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            if (st[i][j]) printf("%c", chess[i][j]);
            else printf("*");
        }
        cout << endl;
    }
    return 0;
}
```

本质还是DFS，**不过值得学习的就是`DFS`函数的第四个参数，用来确定DFS的方向**



# 自然数的拆分问题

## 题目描述

任何一个大于 $1$ 的自然数 $n$，总可以拆分成若干个小于 $n$ 的自然数之和。现在给你一个自然数 $n$，要求你求出 $n$ 的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。

## 输入格式

输入：待拆分的自然数 $n$。

## 输出格式

输出：若干数的加法式子。

## 样例 #1

### 样例输入 #1

```
7
```

### 样例输出 #1

```
1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+1+3
1+1+1+2+2
1+1+1+4
1+1+2+3
1+1+5
1+2+2+2
1+2+4
1+3+3
1+6
2+2+3
2+5
3+4
```

## 提示

数据保证，$1\le n\le 8$。



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 10;

int n;
int a[N];
int sum;

void print() {
    printf("%d", a[1]);
    int i = 2;
    while (a[i]) {
        printf("+%d", a[i]);
        ++i;
    }
    cout << endl;
}

void dfs(int x) {
    for (int i = a[x - 1]; i < n; ++i) {
        if (sum + i > n) return;
        if (sum + i == n) {
            a[x] = i;
            print();
            a[x] = 0;
            return;
        }
        sum += i;
        a[x] = i;
        dfs(x + 1);
        sum -= i;
        a[x] = 0;
    }
}

int main() {
    cin >> n;
    a[0] = 1;// 只是方便DFS，实际打印时不输出第一个元素
    dfs(1);
    return 0;
}
```



# [USACO10OCT]Lake Counting S

## 题面翻译

由于近期的降雨，雨水汇集在农民约翰的田地不同的地方。我们用一个 $N\times M(1\leq N\leq 100, 1\leq M\leq 100)$ 的网格图表示。每个网格中有水（`W`） 或是旱地（`.`）。一个网格与其周围的八个网格相连，而一组相连的网格视为一个水坑。约翰想弄清楚他的田地已经形成了多少水坑。给出约翰田地的示意图，确定当中有多少水坑。

输入第 $1$ 行：两个空格隔开的整数：$N$ 和 $M$。

第 $2$ 行到第 $N+1$ 行：每行 $M$ 个字符，每个字符是 `W` 或 `.`，它们表示网格图中的一排。字符之间没有空格。

输出一行，表示水坑的数量。

## 题目描述

Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.

## 输入格式

Line 1: Two space-separated integers: N and M \* Lines 2..N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.

## 输出格式

Line 1: The number of ponds in Farmer John's field.

## 样例 #1

### 样例输入 #1

```
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.
```

### 样例输出 #1

```
3
```

## 提示

OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left, and one along the right side.

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 110;
int n, m, tot;
char g[N][N];
bool st[N][N];
int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};
int dy[8] = {-1, 0, 1, 1, -1, 1, 0, -1};

void dfs(int x, int y) {
    st[x][y] = true;
    for (int i = 0; i < 8; ++i) {
        int xx = x + dx[i], yy = y + dy[i];
        if (xx >= 0 && yy >= 0 && xx < n && yy < m) {
            if (g[xx][yy] == 'W' && !st[xx][yy]) {
                dfs(xx, yy);
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) scanf("%s", g[i]);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (g[i][j] == 'W' && !st[i][j]) {
                dfs(i, j);
                tot++;
            }
        }
    }
    cout << tot;
    return 0;
}
```



# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状闭合圈，闭合圈由数字 $1$ 构成，围圈时只走上下左右 $4$ 个方向。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

```plain
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

## 输入格式

每组测试数据第一行一个整数 $n(1 \le n \le 30)$。

接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \times n$ 的方阵。

方阵内只有一个闭合圈，圈内至少有一个 $0$。

//感谢黄小U饮品指出本题数据和数据格式不一样. 已修改(输入格式)

## 输出格式

已经填好数字 $2$ 的完整方阵。

## 样例 #1

### 样例输入 #1

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 样例输出 #1

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

## 提示

对于 $100\%$ 的数据，$1 \le n \le 30$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 35;
int n, a[N][N];
bool st[N][N];
int dx[4] = {1, 0, 0, -1};
int dy[4] = {0, 1, -1, 0};

void dfs(int x, int y) {
    st[x][y] = true;
    for (int i = 0; i < 4; ++i) {
        int xx = x + dx[i], yy = y + dy[i];
        if (xx >= 0 && yy >= 0 && xx < n && yy < n && a[xx][yy] == 0 && !st[xx][yy]) 
            dfs(xx, yy);
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < n; ++j) cin >> a[i][j];

    for (int i = 0; i < n; ++i) if (a[0][i] == 0 && !st[0][i]) dfs(0, i);
    for (int i = 0; i < n; ++i) if (a[n - 1][i] == 0 && !st[n - 1][i]) dfs(n - 1, i);
    for (int i = 0; i < n; ++i) if (a[i][0] == 0 && !st[i][0]) dfs(i, 0);
    for (int i = 0; i < n; ++i) if (a[i][n - 1] == 0 && !st[i][n - 1]) dfs(i, n - 1);

    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            if (a[i][j] == 0 && !st[i][j]) cout << "2 ";
            else if (a[i][j] == 0) cout << "0 ";
            else cout << "1 ";
        }
        cout << endl;
    }
    return 0;
}
```



# [USACO11OPEN]Corn Maze S

## 题面翻译

奶牛们去一个 $N\times M$ 玉米迷宫，$2 \leq N \leq 300,2 \leq M \leq300$。

迷宫里有一些传送装置，可以将奶牛从一点到另一点进行瞬间转移。这些装置可以双向使用。

如果一头奶牛处在这个装置的起点或者终点，这头奶牛就**必须**使用这个装置。

玉米迷宫除了唯一的一个出口都被玉米包围。

迷宫中的每个元素都由以下项目中的一项组成：

1. 玉米，`#` 表示，这些格子是不可以通过的。
1. 草地，`.` 表示，可以简单的通过。
1. 传送装置，每一对大写字母 $\tt{A}$ 到 $\tt{Z}$ 表示。
1. 出口，`=` 表示。
1. 起点， `@` 表示

奶牛能在一格草地上可能存在的四个相邻的格子移动，花费 $1$ 个单位时间。从装置的一个结点到另一个结点不花时间。

## 题目描述

This past fall, Farmer John took the cows to visit a corn maze. But this wasn't just any corn maze: it featured several gravity-powered teleporter slides, which cause cows to teleport instantly from one point in the maze to another. The slides work in both directions: a cow can slide from the slide's start to the end instantly, or from the end to the start. If a cow steps on a space that hosts either end of a slide, she must use the slide.

The outside of the corn maze is entirely corn except for a single exit.

The maze can be represented by an N x M (2 <= N <= 300; 2 <= M <= 300) grid. Each grid element contains one of these items:

\* Corn (corn grid elements are impassable) 

\* Grass (easy to pass through!) 

\* A slide endpoint (which will transport a cow to the other endpoint) 

\* The exit

A cow can only move from one space to the next if they are adjacent and neither contains corn. Each grassy space has four potential neighbors to which a cow can travel. It takes 1 unit of time to move from a grassy space to an adjacent space; it takes 0 units of time to move from one slide endpoint to the other.

Corn-filled spaces are denoted with an octothorpe (#). Grassy spaces are denoted with a period (.). Pairs of slide endpoints are denoted with the same uppercase letter (A-Z), and no two different slides have endpoints denoted with the same letter. The exit is denoted with the equals sign (=).

Bessie got lost. She knows where she is on the grid, and marked her current grassy space with the 'at' symbol (@). What is the minimum time she needs to move to the exit space?

## 输入格式

第一行：两个用空格隔开的整数 $N$ 和 $M$。

第 $2\sim N+1$ 行：第 $i+1$ 行描述了迷宫中的第 $i$ 行的情况（共有$M$个字符，每个字符中间没有空格）。

## 输出格式

一个整数，表示起点到出口所需的最短时间。

## 样例 #1

### 样例输入 #1

```
5 6
###=##
#.W.##
#.####
#.@W##
######
```

### 样例输出 #1

```
3
```

## 提示

例如以下矩阵，$N=5,M=6$。

```plain
###=##
#.W.##
#.####
#.@W##
######
```

唯一的一个装置的结点用大写字母 $\tt{W}$ 表示。

最优方案为：先向右走到装置的结点，花费一个单位时间，再到装置的另一个结点上，花费 $0$ 个单位时间，然后再向右走一个，再向上走一个，到达出口处，总共花费了 $3$ 个单位时间。

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 310;
int n, m, dist[N][N], sx, sy, ex, ey;
int dx[4] = {1, 0, 0, -1};
int dy[4] = {0, 1, -1, 0};
char g[N][N];
bool st[N][N];

PII find(PII t, char gg) {
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (g[i][j] == gg && (t.first != i || t.second != j)) return {i, j};
}

void bfs(int x, int y) {
    queue<PII> q;
    q.push({x, y});
    st[x][y] = false;
    while (q.size()) {
        auto t = q.front();
        q.pop();

        if (g[t.first][t.second] >= 'A' && g[t.first][t.second] <= 'Z') {
            auto temp = find(t, g[t.first][t.second]);
            dist[temp.first][temp.second] = dist[t.first][t.second];
            t = temp;
        }

        for (int i = 0; i < 4; ++i) {
            int xx = t.first + dx[i], yy = t.second + dy[i];
            if (xx >= 0 && yy >= 0 && xx < n && yy < m && st[xx][yy]) {
                dist[xx][yy] = dist[t.first][t.second] + 1;
                if (g[xx][yy] == '=') {
                    ex = xx;
                    ey = yy;
                    return;
                }
                q.push({xx, yy});
                st[xx][yy] = false;
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j) {
            cin >> g[i][j];
            if (g[i][j] != '#') st[i][j] = true;
            if (g[i][j] == '@') sx = i, sy = j;
        }
    bfs(sx, sy);
    cout << dist[ex][ey];
    return 0;
}
```

94分答案

```c++
#include<bits/stdc++.h>

using namespace std;
typedef pair<int, int> PII;
const int N = 310;
int n, m, dist[N][N], sx, sy, ans = 2e9;
int dx[4] = {1, 0, -1, 0};
int dy[4] = {0, 1, 0, -1};
char g[N][N];
bool st[N][N];

PII find(PII t, char gg) {
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j)
            if (g[i][j] == gg && (t.first != i || t.second != j)) return {i, j};
}

void bfs(int x, int y) {
    queue<PII> q;
    q.push({x, y});
    st[x][y] = false;
    while (q.size()) {
        auto t = q.front();
        q.pop();

        if (g[t.first][t.second] >= 'A' && g[t.first][t.second] <= 'Z') {
            auto temp = find(t, g[t.first][t.second]);
            dist[temp.first][temp.second] = dist[t.first][t.second];
            t = temp;
        }

        for (int i = 0; i < 4; ++i) {
            int xx = t.first + dx[i], yy = t.second + dy[i];
            if (xx >= 0 && yy >= 0 && xx < n && yy < m && st[xx][yy]) {
                dist[xx][yy] = dist[t.first][t.second] + 1;
                if (g[xx][yy] == '=') {
                    ans = min(ans, dist[xx][yy]);
                }
                q.push({xx, yy});
                st[xx][yy] = false;
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j) {
            cin >> g[i][j];
            if (g[i][j] != '#') st[i][j] = true;
            if (g[i][j] == '@') sx = i, sy = j;
        }
    bfs(sx, sy);
    cout << ans;
    return 0;
}
```

另一个版本的94分答案



# 刻录光盘

## 题目描述

在JSOI2005夏令营快要结束的时候，很多营员提出来要把整个夏令营期间的资料刻录成一张光盘给大家，以便大家回去后继续学习。组委会觉得这个主意不错！可是组委会一时没有足够的空光盘，没法保证每个人都能拿到刻录上资料的光盘，又来不及去买了，怎么办呢？！

组委会把这个难题交给了LHC，LHC分析了一下所有营员的地域关系，发现有些营员是一个城市的，其实他们只需要一张就可以了，因为一个人拿到光盘后，其他人可以带着U盘之类的东西去拷贝啊！

可是，LHC调查后发现，由于种种原因，有些营员并不是那么的合作，他们愿意某一些人到他那儿拷贝资料，当然也可能不愿意让另外一些人到他那儿拷贝资料，这与我们JSOI宣扬的团队合作精神格格不入！！！

现在假设总共有N个营员（2<=N<=200），每个营员的编号为1~N。LHC给每个人发了一张调查表，让每个营员填上自己愿意让哪些人到他那儿拷贝资料。当然，如果A愿意把资料拷贝给B，而B又愿意把资料拷贝给C，则一旦A获得了资料，则B，C都会获得资料。

现在，请你编写一个程序，根据回收上来的调查表，帮助LHC计算出组委会至少要刻录多少张光盘，才能保证所有营员回去后都能得到夏令营资料？

## 输入格式

先是一个数N，接下来的N行，分别表示各个营员愿意把自己获得的资料拷贝给其他哪些营员。即输入数据的第i+1行表示第i个营员愿意把资料拷贝给那些营员的编号，以一个0结束。如果一个营员不愿意拷贝资料给任何人，则相应的行只有1个0，一行中的若干数之间用一个空格隔开。

## 输出格式

一个正整数，表示最少要刻录的光盘数。

## 样例 #1

### 样例输入 #1

```
5
2 3 4 0
4 5 0
0
0
1 0
```

### 样例输出 #1

```
1
```

```c++
#include<iostream>

using namespace std;
const int N = 210;
int a[N][N];
int b[N];
int n, x, tot;

void dfs(int j, int fuze) {
    if (b[j] == fuze) return;
    if (b[j] == j) {
        b[j] = fuze;
    } else {
        b[j] = fuze;
        for (int k = 1; k <= a[j][0]; k++)
            dfs(a[j][k], fuze);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        while (cin >> x) {
            if (x == 0) break;
            a[i][++a[i][0]] = x;
        }
    }
    for (int i = 1; i <= n; i++)
        if (b[i] == 0)
            dfs(i, i);
    for (int i = 1; i <= n; i++)
        if (b[i] == i)
            tot++;
    cout << tot;
    return 0;
}
```

![image-20231128131710667](image/搜索.image/image-20231128131710667.png)

注意这种情况，搜索的时候，即便遇到了`b[i]==j`的情况也要继续搜索下去，反正数据量不大
