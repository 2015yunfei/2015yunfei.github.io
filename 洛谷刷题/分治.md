# 快速排序【模板】

## 题目描述

利用快速排序算法将读入的 $N$ 个数从小到大排序后输出。

快速排序是信息学竞赛的必备算法之一。对于快速排序不是很了解的同学可以自行上网查询相关资料，掌握后独立完成。（C++ 选手请不要试图使用 `STL`，虽然你可以使用 `sort` 一遍过，但是你并没有掌握快速排序算法的精髓。）

## 输入格式

第 $1$ 行为一个正整数 $N$，第 $2$ 行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数，数据保证了 $a_i$ 不超过 $10^9$。

## 输出格式

将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。

## 样例 #1

### 样例输入 #1

```
5
4 2 4 5 1
```

### 样例输出 #1

```
1 2 4 4 5
```

## 提示

对于 $20\%$ 的数据，有 $N\leq 10^3$；

对于 $100\%$ 的数据，有 $N\leq 10^5$。



```c++
#include<bits/stdc++.h>

using namespace std;
int a[100010];

void quick_sort(int a[], int l, int r) {
    if (l >= r)return;
    int i = l - 1, j = r + 1, x = a[l + r >> 1];
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j)swap(a[i], a[j]);
    }
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    quick_sort(a, 0, n - 1);
    for (int i = 0; i < n; ++i) {
        printf("%d ", a[i]);
    }
    return 0;
}
```



# 逆序对

## 题目描述

猫猫 TOM 和小老鼠 JERRY 最近又较量上了，但是毕竟都是成年人，他们已经不喜欢再玩那种你追我赶的游戏，现在他们喜欢玩统计。

最近，TOM 老猫查阅到一个人类称之为“逆序对”的东西，这东西是这样定义的：对于给定的一段正整数序列，逆序对就是序列中 $a_i>a_j$ 且 $i<j$ 的有序对。知道这概念后，他们就比赛谁先算出给定的一段正整数序列中逆序对的数目。注意序列中可能有重复数字。

**Update:数据已加强。**

## 输入格式

第一行，一个数 $n$，表示序列中有 $n$个数。

第二行 $n$ 个数，表示给定的序列。序列中每个数字不超过 $10^9$。

## 输出格式

输出序列中逆序对的数目。

## 样例 #1

### 样例输入 #1

```
6
5 4 2 6 3 1
```

### 样例输出 #1

```
11
```

## 提示

对于 $25\%$ 的数据，$n \leq 2500$

对于 $50\%$ 的数据，$n \leq 4 \times 10^4$。

对于所有数据，$n \leq 5 \times 10^5$

请使用较快的输入输出

应该不会 $O(n^2)$ 过 50 万吧 by chen_zhe



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 500010;
int a[N];
int tmp[N];

unsigned long long int merge_sort(int l, int r) {
    if (l >= r)return 0;
    int mid = r + l >> 1;
    unsigned long long int res = merge_sort(l, mid) + merge_sort(mid + 1, r);
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (a[i] <= a[j])tmp[k++] = a[i++];
        else {
            tmp[k++] = a[j++];//妙极了 
            res += mid - i + 1;
        }
    }
    while (i <= mid)tmp[k++] = a[i++];
    while (j <= r)tmp[k++] = a[j++];
    for (int i = l, j = 0; i <= r; i++, ++j) a[i] = tmp[j];
    return res;
}

int main() {
    int n;
    unsigned long long int sum = 0;
    cin >> n;
    for (int i = 0; i < n; ++i)scanf("%d", &a[i]);
    cout << merge_sort(0, n - 1);
    return 0;
}
```



# [NOIP2013 提高组] 火柴排队

## 题目描述

涵涵有两盒火柴，每盒装有 $n$ 根火柴，每根火柴都有一个高度。 现在将每盒中的火柴各自排成一列， 同一列火柴的高度互不相同， 两列火柴之间的距离定义为：$ \sum (a_i-b_i)^2$

其中 $a_i$ 表示第一列火柴中第 $i$ 个火柴的高度，$b_i$ 表示第二列火柴中第  $i$ 个火柴的高度。

每列火柴中相邻两根火柴的位置都可以交换，请你通过交换使得两列火柴之间的距离最小。请问得到这个最小的距离，最少需要交换多少次？如果这个数字太大，请输出这个最小交换次数对 $10^8-3$ 取模的结果。

## 输入格式

共三行，第一行包含一个整数 $n$，表示每盒中火柴的数目。

第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，表示第一列火柴的高度。

第三行有 $n$ 个整数，每两个整数之间用一个空格隔开，表示第二列火柴的高度。

## 输出格式

一个整数，表示最少交换次数对 $10^8-3$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
4
2 3 1 4
3 2 1 4
```

### 样例输出 #1

```
1
```

## 样例 #2

### 样例输入 #2

```
4
1 3 4 2
1 7 2 4
```

### 样例输出 #2

```
2
```

## 提示

【输入输出样例说明一】

最小距离是$ 0$，最少需要交换 $1$ 次，比如：交换第 $1 $列的前$ 2$ 根火柴或者交换第 $2$ 列的前 $2 $根火柴。

【输入输出样例说明二】

最小距离是 $10$，最少需要交换 $2$ 次，比如：交换第 $1$ 列的中间 $2$ 根火柴的位置，再交换第 $2$ 列中后 $2$ 根火柴的位置。

【数据范围】

对于 $10\%$ 的数据， $1 \leq n \leq 10$；

对于 $30\%$ 的数据，$1 \leq n \leq 100$；

对于 $60\%$ 的数据，$1 \leq n \leq 10^3$；

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq$ 火柴高度 $< 2^{31}$。

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 5e5 + 10, mod = 1e8 - 3;
int n, a[N], b[N], c[N], d[N], q[N], num[N];

int lowbit(int x) {
    return x & -x;
}

void add(int x) {
    for (int i = x; i <= N - 1; i += lowbit(i)) num[i]++;
}

LL query(int x) {
    LL res = 0;
    for (int i = x; i; i -= lowbit(i)) res += num[i];
    return res;
}

bool cmp1(int i, int j) {
    return a[i] < a[j];
}

bool cmp2(int i, int j) {
    return b[i] < b[j];
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        c[i] = i;
    }
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &b[i]);
        d[i] = i;
    }
    sort(c + 1, c + n + 1, cmp1);
    sort(d + 1, d + n + 1, cmp2);
    for (int i = 1; i <= n; ++i) q[c[i]] = d[i];
    LL ans = 0;
    for (int i = 1; i <= n; ++i) {
        int id = q[i];
        ans = (ans + i - 1 - query(id)) % mod;
        add(id);
    }
    cout << ans;
    return 0;
} 
```



# 【模板】快速幂||取余运算

## 题目描述

给你三个整数 $a,b,p$，求 $a^b \bmod p$。

## 输入格式

输入只有一行三个整数，分别代表 $a,b,p$。

## 输出格式

输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。

## 样例 #1

### 样例输入 #1

```
2 10 9
```

### 样例输出 #1

```
2^10 mod 9=7
```

## 提示

**样例解释**

$2^{10} = 1024$，$1024 \bmod 9 = 7$。

**数据规模与约定**

对于 $100\%$ 的数据，保证 $0\le a,b < 2^{31}$，$a+b>0$，$2 \leq p \lt 2^{31}$。

一种实现方式：

```c++
int quickPower(int a, int b)//是求a的b次方
{
    int ans = 1, base = a;//ans为答案，base为a^(2^n)
    while (b > 0)//b是一个变化的二进制数，如果还没有用完
    {
        if (b & 1)//&是位运算，b&1表示b在二进制下最后一位是不是1，如果是：
            ans *= base;//把ans乘上对应的a^(2^n)

        base *= base;//base自乘，由a^(2^n)变成a^(2^(n+1))
        b >>= 1;
    }
    return ans;
}
```

完整代码：

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;
int a, b, mod;

int main() {
    cin >> a >> b >> mod;
    if (a == 0) {
        printf("%lld^%lld mod %lld=%lld", a, b, mod, 0);
        return 0;
    }
    LL ans = 1, base = a;
    int bb = b;
    while (b) {
        if (b & 1) ans = (ans * base) % mod;
        base = (base * base) % mod;
        b >>= 1;
    }
    printf("%lld^%lld mod %lld=%lld", a, bb, mod, ans);
    return 0;
}
```



# 最大子段和

## 题目描述

给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。

## 输入格式

第一行是一个整数，表示序列的长度 $n$。

第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。

## 输出格式

输出一行一个整数表示答案。

## 样例 #1

### 样例输入 #1

```
7
2 -4 3 -1 2 -4 3
```

### 样例输出 #1

```
4
```

## 提示

#### 样例 1 解释

选取 $[3, 5]$ 子段 $\{3, -1, 2\}$，其和为 $4$。

#### 数据规模与约定

- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。



```c++
#include<bits/stdc++.h>

using namespace std;
int n, temp;
int sum, maxsum = INT_MIN;

int main() {
    cin >> n;

    while (n--) {
        scanf("%d", &temp);
        sum += temp;
        maxsum = maxsum > sum ? maxsum : sum;
        if (sum < 0)sum = 0;
    }

    cout << maxsum;
    return 0;
}
```

**注意这里并没有利用分治思想完成算法，记得浙大数据结构课程有一节课是将利用分治思想解决最大子段和问题，但是我忘了。。。**



# 集合求和

## 题目描述

给定一个集合 $s$（集合元素数量 $\le 30$），求出此集合所有子集元素之和。

## 输入格式

集合中的元素（元素 $\le 1000$）

## 输出格式

$s$ 所有子集元素之和。

## 样例 #1

### 样例输入 #1

```
2 3
```

### 样例输出 #1

```
10
```

## 提示

**【样例解释】**

子集为：$\varnothing, \{ 2 \}, \{ 3 \}, \{ 2, 3 \}$，和为 $2 + 3 + 2 + 3 = 10$。

----

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le \lvert s \rvert \le 30$，$1 \le s_i \le 1000$，$s$ 所有子集元素之和 $\le {10}^{18}$。

![image-20230108193936014](%E5%BA%93/image-20230108193936014.png)

```c++
#include<bits/stdc++.h>

using namespace std;

//发现规律 输入元素和*2^(n-1)
int main() {
    long long int sum = 0;
    int s, i = 0;
    while (cin >> s) {
        i++;
        sum += s;
    }
    //cout<<i<<endl;
    printf("%lld", sum <<= (i - 1));
} 
```



# [HNOI2008]越狱

## 题目描述

监狱有 $n$ 个房间，每个房间关押一个犯人，有 $m$ 种宗教，每个犯人会信仰其中一种。如果相邻房间的犯人的宗教相同，就可能发生越狱，求有多少种状态可能发生越狱。

答案对 $100,003$ 取模。

## 输入格式

输入只有一行两个整数，分别代表宗教数 $m$ 和房间数 $n$。

## 输出格式

输出一行一个整数代表答案。

## 样例 #1

### 样例输入 #1

```
2 3
```

### 样例输出 #1

```
6
```

## 提示

#### 样例输入输出 1 解释

| 状态编号 | 1 号房间 | 2 号房间 | 3 号房间 |
| :------: | :------: | :------: | :------: |
|    1     |  信仰 1  |  信仰 1  |  信仰 1  |
|    2     |  信仰 1  |  信仰 1  |  信仰 2  |
|    3     |  信仰 1  |  信仰 2  |  信仰 2  |
|    4     |  信仰 2  |  信仰 1  |  信仰 1  |
|    5     |  信仰 2  |  信仰 2  |  信仰 2  |
|    6     |  信仰 2  |  信仰 2  |  信仰 1  |

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le m \le 10^8$，$1 \le n \le 10^{12}$。

```c++
#include<cstdio>

typedef long long int LL;
const LL mod = 100003;
LL m, n;

LL quick(LL a, LL p) {
    if (p == 0) return a;
    LL ans = 1, base = a;
    while (p) {
        if (p & 1) ans = ans * base % mod;
        base = base * base % mod;
        p >>= 1;
    }
    return ans;
}

int main() {
    LL m, n;
    scanf("%lld %lld", &m, &n);
    LL ans = quick(m, n) - m * quick(m - 1, n - 1) % mod;
    ans += mod;
    printf("%lld", ans % mod);
    return 0;
}
```

我们可以倒过来想，我们只需要算出不越狱的情况，再用总情况减掉就行了！

第一个人有`m`种选择，第二个人为了不与第一个人不重复，只有`m-1`个选择，第三个人为了不与第二个人重复，也只有`m-1`个选择，最后总情况有m^n^个，因此 $ans=m^{n}-m*(m-1)^{n-1}$



# 平面上的最接近点对

## 题目描述

给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的。

## 输入格式

第一行一个整数 $n$，表示点的个数。

接下来 $n$ 行，每行两个整数 $x,y$ ，表示一个点的行坐标和列坐标。

## 输出格式

仅一行，一个实数，表示最短距离，四舍五入保留 $4$ 位小数。

## 样例 #1

### 样例输入 #1

```
3
1 1
1 2
2 2
```

### 样例输出 #1

```
1.0000
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4$，$0 \leq x, y \leq 10^9$，小数点后的数字个数不超过 $6$。

```c++
#include<cstdio>
#include<cmath>

using namespace std;
int n, x[10009], y[10009];
double ans = 23333333;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d%d", &x[i], &y[i]);
    for (int i = 1; i <= n; i++) {
        for (int j = i + 1; j <= n; j++) {
            if (sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j])) < ans) {
                ans = sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));
            }
        }
    }
    printf("%.4lf", ans);
    return 0;
}
```

这个题目一般是 O(n^2^) 的时间复杂度，如果要优化到 O(nlogn) 级别，需要看1985年两个教授的优化方案，非常的麻烦。对于普及难度的题目不用深究到如此地步

> 关于优化过程的讨论：
>
> https://www.luogu.com.cn/blog/DestinHistoire/ji-suan-ji-he-ping-mian-shang-zui-jin-dian-dui

O(nlogn) 复杂度的代码

```c++
#include<bits/stdc++.h>

using namespace std;
struct point {
    double x, y;
} p[200010];
int n, temp[200010];

bool cmp(const point &A, const point &B) {
    if (A.x == B.x) return A.y < B.y;
    else return A.x < B.x;
}

bool cmps(const int &a, const int &b) {
    return p[a].y < p[b].y;
}

double distance(int i, int j) {
    return sqrt((p[i].x - p[j].x) * (p[i].x - p[j].x) + (p[i].y - p[j].y) * (p[i].y - p[j].y));
}

double merge(int left, int right) {
    double dis = 2 << 20;
    if (left == right) return dis;
    if (left + 1 == right) return distance(left, right);
    
    int mid = (left + right) >> 1;
    double d1 = merge(left, mid);
    double d2 = merge(mid + 1, right);
    dis = min(d1, d2);
    
    int k = 0;
    for (int i = left; i <= right; i++)
        if (fabs(p[i].x - p[mid].x) <= dis) temp[k++] = i;
    
    sort(temp, temp + k, cmps);
    for (int i = 0; i < k; i++)
        for (int j = i + 1; j < k && p[temp[j]].y - p[temp[i]].y < dis; j++)
            dis = min(dis, distance(temp[i], temp[j]));
    return dis;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%lf %lf", &p[i].x, &p[i].y);
    sort(p, p + n, cmp);
    printf("%.4lf\n", merge(0, n - 1));
    return 0;
}
```



# 平面最近点对（加强版）

## 题目背景

[P7883](/problem/P7883) 平面最近点对（加强加强版）

## 题目描述

给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的

## 输入格式

第一行：$n$ ，保证 $2\le n\le 200000$ 。

接下来 $n$ 行：每行两个实数：$x\ y$ ，表示一个点的行坐标和列坐标，中间用一个空格隔开。

## 输出格式

仅一行，一个实数，表示最短距离，精确到小数点后面 $4$ 位。

## 样例 #1

### 样例输入 #1

```
3
1 1
1 2
2 2
```

### 样例输出 #1

```
1.0000
```

## 提示

数据保证 $0\le x,y\le 10^9$



> 【577 平面最近点对 分治算法【计算几何】】 https://www.bilibili.com/video/BV1ko4y1s7Ed/?share_source=copy_web&vd_source=8fa0ddfc571cb8e214b881be981477a4



```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2e5 + 10;
int n;
struct point {
    double x, y;
} a[N], b[N];

bool cmp(point &a, point &b) {
    if (a.x == b.x) {
        return a.y < b.y;
    }
    return a.x < b.x;
}

bool cmpy(point &a, point &b) {
    return a.y < b.y;
}

double dis(point a, point b) {
    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));
}

double solve(int l, int r) {
    if (l == r) return 2e9;
    if (l + 1 == r) return dis(a[l], a[r]);
    int m = l + r >> 1;
    double d = min(solve(l, m), solve(m + 1, r));

    int k = 0;
    for (int i = l; i <= r; ++i) {
        if (fabs(a[i].x - a[m].x) < d) b[++k] = a[i];
    }
    sort(b + 1, b + 1 + k, cmpy);
    for (int i = 1; i < k; ++i) {
        for (int j = i + 1; j <= k && b[j].y - b[i].y < d; ++j) {
            d = min(d, dis(b[i], b[j]));
        }
    }
    return d;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i].x >> a[i].y;
    sort(a + 1, a + 1 + n, cmp);
    printf("%.4lf", solve(1, n));
    return 0;
}
```



# 平面最近点对（加强加强版）

## 题目背景

[P1429 平面最近点对（加强版）](https://www.luogu.com.cn/problem/P1429)里最高赞题解写道：

> 我们充分发扬人类智慧：  
> 将所有点全部绕原点旋转同一个角度，然后按 $x$ 坐标排序  
> 根据数学直觉，在随机旋转后，答案中的两个点在数组中肯定不会离得太远  
> 所以我们只取每个点向后的 $5$ 个点来计算答案  
> 这样速度快得飞起，在 $n=1000000$ 时都可以在 1 s 内卡过

当然，这是错的。

## 题目描述

给定 $n$ 个二维欧几里得平面上的点 $p_1, p_2, \dots, p_n$，请输出距离最近的两个点的距离。

## 输入格式

输入第一行为一个正整数 $n$，表示点数。

接下来 $n$ 行，第 $i$ 行为用空格隔开的整数 $x_i, y_i$，表示 $p_i = (x_i, y_i)$。

输入保证：没有两个坐标完全相同的点。

## 输出格式

输出一行，包含一个整数 $D^2$，表示距离最近的两个点的距离的**平方**。

由于输入的点为整点，因此这个值一定是整数。

## 样例 #1

### 样例输入 #1

```
2
-10000000 -10000000
10000000 10000000
```

### 样例输出 #1

```
800000000000000
```

## 样例 #2

### 样例输入 #2

```
5
1 1
1 9
9 1
9 9
0 10
```

### 样例输出 #2

```
2
```

## 提示

对于第二组样例，$(1, 9)$、$(0, 10)$ 两个点最近，距离为 $\sqrt 2$，因此你需要输出 $2$。



### 数据范围

对于 $100 \%$ 的数据，$2 \leq n \leq 4 \times 10^5$，$-10^7 \leq x_i, y_i \leq 10^7$。


本题目标复杂度是 $O(n \log ^2 n)$。设置 350ms 时限的原因是：
1. $O(n \log ^2 n)$ 参考代码使用 `cin` 不会 TLE。最快的 std 能 $<$ 100ms。
2. @wlzhouzhuan 的程序能恰好在 350ms 内跑 $1000n$ 次检查。
3. 150 组测试数据，为了防止卡评测。



> 【577 平面最近点对 分治算法【计算几何】】 https://www.bilibili.com/video/BV1ko4y1s7Ed/?share_source=copy_web&vd_source=8fa0ddfc571cb8e214b881be981477a4



```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 400005;
int n;
struct Point {
    long long x, y;
} p[N], q[N];

bool cmp(const Point &a, const Point &b) {
    return a.x < b.x;
}

long long dis(const Point &a, const Point &b) {
    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);
}

long long divide(int l, int r) {
    if (l == r) return 1ll << 62;
    int mid = (l + r) / 2;
    long long midx = p[mid].x;
    long long d = min(divide(l, mid), divide(mid + 1, r));
    int p1 = l, p2 = mid + 1, tot = 0;
    while (p1 <= mid || p2 <= r) {
        if (p1 <= mid && (p2 > r || p[p1].y < p[p2].y)) {
            q[++tot] = p[p1++];
        } else {
            q[++tot] = p[p2++];
        }
    }
    for (int i = 1; i <= tot; i++) {
        p[l + i - 1] = q[i];
    }
    tot = 0;
    long long dd = d;
    d = sqrt(dd);// 看题目要求，dd是距离平方
    for (int i = l; i <= r; i++) {
        if (abs(p[i].x - midx) <= d) q[++tot] = p[i];
    }
    for (int i = 1; i <= tot; i++) {
        for (int j = i - 1; j >= 1 && q[i].y - q[j].y <= d; j--) {
            dd = min(dd, dis(q[i], q[j]));
            d = sqrt(dd);
        }
    }
    return dd;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        scanf("%lld%lld", &p[i].x, &p[i].y);
    }
    sort(p + 1, p + n + 1, cmp);
    cout << divide(1, n) << endl;
    return 0;
}
```

