# 【模板】单源最短路径（弱化版）

https://www.luogu.com.cn/problem/P3371

## 题目背景

本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 [P4779](https://www.luogu.org/problemnew/show/P4779)。

## 题目描述

如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。

## 输入格式

第一行包含三个整数 $n,m,s$，分别表示点的个数、有向边的个数、出发点的编号。

接下来 $m$ 行每行包含三个整数 $u,v,w$，表示一条 $u \to v$ 的，长度为 $w$ 的边。

## 输出格式

输出一行 $n$ 个整数，第 $i$ 个表示 $s$ 到第 $i$ 个点的最短路径，若不能到达则输出 $2^{31}-1$。

## 样例 #1

### 样例输入 #1

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
```

### 样例输出 #1

```
0 2 4 3
```

## 提示

【数据范围】    
对于 $20\%$ 的数据：$1\le n \le 5$，$1\le m \le 15$；  
对于 $40\%$ 的数据：$1\le n \le 100$，$1\le m \le 10^4$；   
对于 $70\%$ 的数据：$1\le n \le 1000$，$1\le m \le 10^5$；   
对于 $100\%$ 的数据：$1 \le n \le 10^4$，$1\le m \le 5\times 10^5$，$1\le u,v\le n$，$w\ge 0$，$\sum w< 2^{31}$，保证数据随机。

**Update 2022/07/29：两个点之间可能有多条边，敬请注意。**

对于真正 $100\%$ 的数据，请移步 [P4779](https://www.luogu.org/problemnew/show/P4779)。请注意，该题与本题数据范围略有不同。


样例说明：

![](%E5%BA%93/7641.png)

图片1到3和1到4的文字位置调换

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N = 1e4+10,M = 5e5+10;

int e[M],w[M],ne[M],h[N],idx;
int n,m,s;
int dist[N];
bool st[N];

void dijkstra(int s){
	for(int i=1;i<=n;i++) dist[i]=INT_MAX;
	dist[s]=0;
	priority_queue<PII,vector<PII>,greater<PII>> heap;
	heap.push({0,s});
	
	while(heap.size()){
		PII t=heap.top();
		heap.pop();
		
		int ver=t.second;
		if(st[ver]) continue;
		st[ver]=true;
		
		for(int i=h[ver];i!=-1;i=ne[i]){
			int j=e[i];
			if(dist[j]>dist[ver]+w[i]){
                dist[j]=dist[ver]+w[i];
                heap.push({dist[j],j});
            }
		}
	}
}

void add(int a,int b,int c){
	e[idx]=b;
	ne[idx]=h[a];
	w[idx]=c;
	h[a]=idx++;
}

int main(){
	cin>>n>>m>>s;
	memset(h,-1,sizeof h);
	for(int i=0;i<m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	
	dijkstra(s);
	
	for(int i=1;i<=n;i++) printf("%d ",dist[i]);
	
	return 0;
}
```



# 【模板】单源最短路径（标准版）

https://www.luogu.com.cn/problem/P4779

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 输入格式

第一行为三个正整数 $n, m, s$。
第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$ 有一条权值为 $w_i$ 的有向边。

## 输出格式

输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。

## 样例 #1

### 样例输入 #1

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4
```

### 样例输出 #1

```
0 2 4 3
```

## 提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

```c++
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
const int N = 1e5+10,M = 2e5+10;

int e[M],w[M],ne[M],h[N],idx;
int n,m,s;
int dist[N];
bool st[N];

void dijkstra(int s){
	for(int i=1;i<=n;i++) dist[i]=INT_MAX;
	dist[s]=0;
	priority_queue<PII,vector<PII>,greater<PII>> heap;
	heap.push({0,s});
	
	while(heap.size()){
		PII t=heap.top();
		heap.pop();
		
		int ver=t.second;
		if(st[ver]) continue;
		st[ver]=true;
		
		for(int i=h[ver];i!=-1;i=ne[i]){
			int j=e[i];
			if(dist[j]>dist[ver]+w[i]){
                dist[j]=dist[ver]+w[i];
                heap.push({dist[j],j});
            }
		}
	}
}

void add(int a,int b,int c){
	e[idx]=b;
	ne[idx]=h[a];
	w[idx]=c;
	h[a]=idx++;
}

int main(){
	cin>>n>>m>>s;
	memset(h,-1,sizeof h);
	for(int i=0;i<m;i++){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		add(a,b,c);
	}
	
	dijkstra(s);
	
	for(int i=1;i<=n;i++) printf("%d ",dist[i]);
	
	return 0;
}
```

**注意 dist 数组的初始化不可以是 0x3f，会被题目卡掉，还是初始化 INT_MAX 比较保险**
