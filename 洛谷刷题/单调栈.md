# [POI2008]PLA-Postering

## 题目描述

All the buildings in the east district of Byteburg were built    in accordance with the old arbitecture:

they stand next to each other with no spacing inbetween.

Together they form a very long chain of buildings of diverse    height, extending from east to west.

The mayor of Byteburg, Byteasar, has decided to have the north face    of the chain covered with posters.

Byteasar ponders over the minimum number of posters sufficient to    cover the whole north face.

The posters have rectangular shape with vertical and horizontal sides.

They cannot overlap, but may touch each other, i.e. have common points    on the sides.

Every poster has to entirely adjoin the walls of certain buildings    and the whole surface of the north face has to be covered.

Task      Write a programme that:

reads the description of buildings from the standard input,                      determines the minimum number of posters needed to entirely cover their north faces,                      writes out the outcome to the standard output.

Byteburg市东边的建筑都是以旧结构形式建造的:建筑互相紧挨着,之间没有空间.它们共同形成了一条长长的,从东向西延伸的建筑物链(建筑物的高度不一).Byteburg市的市长Byteasar,决定将这个建筑物链的一侧用海报覆盖住.并且想用最少的海报数量,海报是矩形的.海报与海报之间不能重叠,但是可以相互挨着(即它们具有公共边),每一个海报都必须贴近墙并且建筑物链的整个一侧必须被覆盖(意思是:海报需要将一侧全部覆盖,并且不能超出建筑物链)

## 输入格式

The first line of the standard input contains one integer $n$ ($1\le n\le 250\ 000$), denoting the number of buildings the chain      comprises of.

Each of the following $n$ lines contains two integers $d_i$ and $w_i$ ($1\le d_i,w_i\le 1\ 000\ 000\ 000$),      separated by a single space, denoting respectively the length and height      of the $i^{th}$ building in the row.

第一行为一个整数n(1≤n≤250000),表示有n个建筑,接下来n行中,第i行表示第i个建筑物的宽di与高wi(1≤di,wi≤1 000 000 000),中间由一个空格隔开

## 输出格式

The first and only line of the standard output should contain one integer,      the minimum number of rectangular posters that suffice to cover the north faces      of the buildings.

第一个为一个整数,表示最少需要几张海报.

## 样例 #1

### 样例输入 #1

```
5
1 2
1 3
2 2
2 5
1 4
```

### 样例输出 #1

```
4
```

## 提示

题目简述：N个矩形,排成一排. 现在希望用尽量少的矩形海报Cover住它们.

感谢@\_\_乱世魇华 提供翻译



**这道题是单调栈的入门经典题**

我们发现：答案与宽度是没有关系的，于是我们只需要按高度维护一个单调递增的栈。

如果发现当前高度已经在栈中，就不需要另外一张海报了。

于是用一个ans变量记录一下，最后用总海报数减去不需要另外的海报数便是答案。

代码如下：

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 2.5e5 + 10;

int n, tt;
int s[N];

int main() {
    cin >> n;
    int ans = 0;
    int sum = n;
    while (n--) {
        int a, b;
        scanf("%d%d", &a, &b);
        while (tt && s[tt] > b) tt--;
        if (s[tt] == b) ans++;
        s[++tt] = b;
    }
    cout << sum - ans << endl;
    return 0;
}
```



# 玉蟾宫

## 题目背景

有一天，小猫 rainbow 和 freda 来到了湘西张家界的天门山玉蟾宫，玉蟾宫宫主蓝兔盛情地款待了它们，并赐予它们一片土地。

## 题目描述

这片土地被分成 $N\times M$ 个格子，每个格子里写着 'R' 或者 'F'，R 代表这块土地被赐予了 rainbow，F 代表这块土地被赐予了 freda。

现在 freda 要在这里卖萌。。。它要找一块矩形土地，要求这片土地都标着 'F' 并且面积最大。

但是 rainbow 和 freda 的 OI 水平都弱爆了，找不出这块土地，而蓝兔也想看 freda 卖萌（她显然是不会编程的……），所以它们决定，如果你找到的土地面积为 $S$，它们每人给你 $S$ 两银子。

## 输入格式

第一行两个整数 $N$，$M$，表示矩形土地有 $N$ 行 $M$ 列。

接下来 $N$ 行，每行 $M$ 个用空格隔开的字符 'F' 或 'R'，描述了矩形土地。

## 输出格式

输出一个整数，表示你能得到多少银子，即 ($3\times \text{最大 'F' 矩形土地面积}$) 的值。

## 样例 #1

### 样例输入 #1

```
5 6 
R F F F F F 
F F F F F F 
R R R F F F 
F F F F F F 
F F F F F F
```

### 样例输出 #1

```
45
```

## 提示

对于 $50\%$ 的数据，$1 \leq N, M \leq 200$。  
对于 $100\%$ 的数据，$1 \leq N, M \leq 1000$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e3 + 10;
int n, m, f[N][N], maxx;
char c;
struct node {
    int len, h;
} a[N];
stack<node> S;

void ask(int x) {
    memset(a, 0, sizeof(a));
    a[1].h = f[x][1], a[1].len = 1;
    S.push(a[1]);//初始化
    for (int i = 2; i <= m; i++) {
        int width = 0;
        while (S.size() && S.top().h >= f[x][i])//需要弹栈
        {
            width += S.top().len;
            maxx = max(maxx, width * S.top().h);
            S.pop();//更新答案并弹栈
        }
        a[i].h = f[x][i], a[i].len = width + 1;//已入栈的比他高的矩形个数加1
        S.push(a[i]);
    }
    int width = 0;
    while (S.size())//用剩余矩形更新答案，这个栈中的所有矩形，其高度是严格单调增
    {
        width += S.top().len;
        maxx = max(maxx, S.top().h * width);
        S.pop();
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            cin >> c;
            if (c == 'F') f[i][j] = f[i - 1][j] + 1;
        }

    for (int i = 1; i <= n; i++) ask(i);//解决子问题
    cout << maxx * 3 << endl;//别忘了要乘3哦
    return 0;
}
```

这道题是别人推荐的一道单调栈好题。

n行m列土地，求最大矩形面积，我们把问题拆分成n个子问题来解决。

对于每一行,依次记录每行向上一直是F土地的可延伸的最大距离，记为`f(i,j)`。

我们记录这个数组有什么用呢？这就可以转化为单调栈维护的问题了。

具体思路

- 对于每一个子问题，我们维护一个单调递增的单调栈.我们定义一个结构体(其中记录的两个元素分别是当前行第j个矩形的f值，以及它在栈中的宽度，注意这个宽度可能是包含了之前被弹出的矩形的宽度)。
- 我们考虑当前加入第k个矩形的情况：
  - 当前矩形高度大于栈顶，直接加入即可，因为没有比它大的元素，那么当前矩形的宽度为1。
  - 当前矩形高度小于栈顶，则不断取出栈顶，直到栈为空或者栈顶矩形的高度比当前矩形小。在出栈过程中，我们累计被弹出的矩形的宽度之和，并且每弹出一个矩形，就用它的高度乘上累计的宽度（是累计，因为在它入栈后还有比它大的元素入栈）来更新答案。
- 在所有矩形（m个）都考虑过后，我们再用还没有弹栈的元素再来个新一波答案，直到栈空。

**通过这个题目主要是学习单调栈的应用，一般没见过类似的题目的话很难想到！**



另外，其实不太明白别人题解中为什么要建立一个a数组存放，我尝试按照自己的思路写了一个用`pair`替换数组的写法。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1010;
typedef pair<int, int> PII;
int n, m, a[N][N], f[N][N];
int maxx;
char c;

void check(int x) {
    stack<PII> q;
    q.push({f[x][1], 1});
    for (int i = 2; i <= m; ++i) {
        int width = 0;
        while (q.size() && q.top().first >= f[x][i]) {
            width += q.top().second;
            maxx = max(maxx, width * q.top().first);
            q.pop();
        }
        q.push({f[x][i], width + 1});
    }
    int width = 0;
    while (q.size()) {
        width += q.top().second;
        maxx = max(maxx, width * q.top().first);
        q.pop();
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> c;
            if (c == 'F') {
                a[i][j] = 1;
                f[i][j] = f[i - 1][j] + 1;
            }
        }
    }

    for (int i = 1; i <= n; ++i) check(i);
    cout << maxx * 3 << endl;
    return 0;
}
```



# 扫描

## 题目描述

有一个 $1 \times n$ 的矩阵，有 $n$ 个整数。

现在给你一个可以盖住连续 $k$ 个数的木板。

一开始木板盖住了矩阵的第 $1 \sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。

每次移动前输出被覆盖住的数字中最大的数是多少。

## 输入格式

第一行两个整数 $n,k$，表示共有 $n$ 个数，木板可以盖住 $k$ 个数。

第二行 $n$ 个整数，表示矩阵中的元素。

## 输出格式

共 $n - k + 1$ 行，每行一个整数。

第 $i$ 行表示第 $i \sim i + k - 1$ 个数中最大值是多少。

## 样例 #1

### 样例输入 #1

```
5 3
1 5 3 4 2
```

### 样例输出 #1

```
5
5
4
```

## 提示

对于 $20\%$ 的数据，$1 \leq k \leq n \leq 10^3$。

对于 $50\%$ 的数据，$1 \leq k \leq n \leq 10^4$。

对于 $100\%$ 的数据，$1 \leq k \leq n \leq 2 \times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 2e6 + 10;
int n, k;
int a[N];
int q[N];

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; ++i) scanf("%d", &a[i]);

    int hh = 0, tt = -1;
    for (int i = 0; i < n; ++i) {
        if (i - k + 1 > q[hh]) hh++;
        while (hh <= tt && a[q[tt]] < a[i]) tt--;
        q[++tt] = i;
        if (i >= k - 1) printf("%d\n", a[q[hh]]);
    }
    return 0;
} 
```

