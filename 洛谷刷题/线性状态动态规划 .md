https://www.luogu.com.cn/training/212#problems

# [NOIP1999 普及组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。


输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 输入格式

一行，若干个整数，中间由空格隔开。

## 输出格式

两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 样例 #1

### 样例输入 #1

```
389 207 155 300 299 170 158 65
```

### 样例输出 #1

```
6
2
```

## 提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 2e5 + 5;
int a[N], x, n, dp[N], maxn;
int g[N], cnt;

int main() {
    while (cin >> x) a[++n] = x;
    g[0] = 2e9;
    for (int i = 1; i <= n; i++) {
        if (a[i] <= g[cnt]) g[++cnt] = a[i];
        else {
            int l = 1, r = cnt;
            while (l < r) {
                int mid = l + r >> 1;
                if (g[mid] < a[i]) r = mid;
                else l = mid + 1;
            }
            g[l] = a[i];
        }
    }
    cout << cnt << endl;   // 最长不上升子序列
    cnt = 0;
    g[0] = -2e9;
    for (int i = 1; i <= n; i++) {
        if (a[i] > g[cnt]) g[++cnt] = a[i];
        else {
            int l = 1, r = cnt;
            while (l < r) {
                int mid = l + r >> 1;
                if (g[mid] >= a[i]) r = mid;
                else l = mid + 1;
            }
            g[l] = a[i];
        }
    }
    cout << cnt << endl;   // 最长上升子序列
    return 0;
}
```

第一问显然每套导弹拦截系统拦截导弹高度为不升子序列，求最长的不升子序列就好了
第二问求导弹拦截系统的个数可以转化为求最长上升子序列长度

需要注意这么一个易错点:
输入的时候`int n=0;while(cin>>h[++n]);`会出错，为什么呢？他会导致明明输入了8个数，结果n=9,h数组中最后一个数字为0。
这是为什么呢？因为赋值操作需要先找到变量的地址，然后再进行读入，也就是说最后一次跳出循环是因为`cin`返回值使得我们跳出了`while`循环，而在这之前，我们已经完成了`++n`的操作。



# 【模板】最长公共子序列

## 题目描述

给出 $1,2,\ldots,n$ 的两个排列 $P_1$ 和 $P_2$ ，求它们的最长公共子序列。

## 输入格式

第一行是一个数 $n$。

接下来两行，每行为 $n$ 个数，为自然数 $1,2,\ldots,n$ 的一个排列。

## 输出格式

一个数，即最长公共子序列的长度。

## 样例 #1

### 样例输入 #1

```
5 
3 2 1 4 5
1 2 3 4 5
```

### 样例输出 #1

```
3
```

## 提示

- 对于 $50\%$ 的数据， $n \le 10^3$；
- 对于 $100\%$ 的数据， $n \le 10^5$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, a[N], b[N], q[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        int c;
        scanf("%d", &c);
        a[c] = i;
    }
    for (int i = 0; i < n; ++i) {
        int d;
        scanf("%d", &d);
        b[i] = a[d];
    }
    int len = 0;
    q[0] = -2e9 - 123;
    for (int i = 0; i < n; ++i) {
        int l = 0, r = len;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (q[mid] < b[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = b[i];
    }
    cout << len << endl;
    return 0;
} 
```

关于为什么可以转化成LIS问题，这里提供一个解释。

A:3 2 1 4 5

B:1 2 3 4 5

我们不妨给它们重新标个号：把3标成a,把2标成b，把1标成c……于是变成：

A: a b c d e

B: c b a d e

这样标号之后，LCS长度显然不会改变。但是出现了一个性质：

两个序列的子序列，一定是A的子序列。而A本身就是单调递增的。
 因此这个子序列是单调递增的。

换句话说，只要这个子序列在B中单调递增，它就是A的子序列。

哪个最长呢？当然是B的LIS最长。

自此完成转化。



# 尼克的任务

## 题目描述

尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。

尼克的一个工作日为 $n$ 分钟，从第 $1$ 分钟开始到第 $n$ 分钟结束。当尼克到达单位后他就开始干活，公司一共有 $k$ 个任务需要完成。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第 $p$ 分钟开始，持续时间为 $t$ 分钟，则该任务将在第 $(p+t-1)$ 分钟结束。

写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。

## 输入格式

输入数据第一行含两个用空格隔开的整数 $n$ 和 $k$。

接下来共有 $k$ 行，每一行有两个用空格隔开的整数 $p$ 和 $t$，表示该任务从第 $p$ 分钟开始，持续时间为 $t$ 分钟。

## 输出格式

输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。

## 样例 #1

### 样例输入 #1

```
15 6
1 2
1 6
4 11
8 5
8 1
11 5
```

### 样例输出 #1

```
4
```

## 提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4,1 \leq k \leq 10^4,1 \leq p \leq n,1 \leq p+t-1 \leq n$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e4 + 10;
int n, k, f[N];
vector<int> s[N];

int main() {
    cin >> n >> k;
    for (int i = 0; i < k; ++i) {
        int a, b;
        scanf("%d%d", &a, &b);
        s[a].push_back(b);
    }
    for (int i = n; i > 0; --i) {
        if (s[i].size() != 0) {
            for (int j = 0; j < s[i].size(); ++j)
                f[i] = max(f[i], f[i + s[i][j]]);
        } else f[i] = f[i + 1] + 1;
    }
    cout << f[1] << endl;
    return 0;
}
```

这题显然是一个线性动规，那么肯定是第一时间想到设`f[i]:1~i的最大空闲时间`，但是，想了一下之后发现，第i时刻的最大空闲时间是和后面i+选择任务的持续时间的时刻有关系的，那么，**正着找肯定是不行的**，我们来**试一下倒着搜**，即设`f[i]表示i~n的最大空闲时间`，经尝试，发现是完全可行的，可以列出动态转移方程如下

O(n+k)做法

`f[i]`表示第ii分钟起最大闲暇时间

转移方程：

- 如果当前无任务，`f[i]=f[i+1]+1`
- 如果当前第`i`个任务持续`ti`分钟`f[i]=max(f[i+t[i]])`

递推顺序：`for(i=n;i>0;i--)`

答案：`f[1]`

实现方式：动态数组`vi`存在时刻`i`开始的任务持续时间



# 编辑距离

## 题目描述

设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：

1. 删除一个字符；
2. 插入一个字符；
3. 将一个字符改为另一个字符。

$A, B$ 均只包含小写字母。

## 输入格式

第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。

## 输出格式

只有一个正整数，为最少字符操作次数。

## 样例 #1

### 样例输入 #1

```
sfdqxbw
gfdgw
```

### 样例输出 #1

```
4
```

## 提示

对于 $100 \%$ 的数据，$1 \le |A|, |B| \le 2000$。

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 2010;

int f[N][N];
string a, b;
int n, m;

int main() {
    cin >> a >> b;
    a = "@" + a;
    b = "@" + b;
    n = a.size();
    m = b.size();
    for (int i = 0; i <= m; i++) f[0][i] = i;
    for (int i = 0; i <= n; i++) f[i][0] = i;

    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) {
            f[i][j] = min(f[i - 1][j] + 1, f[i][j - 1] + 1);
            if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i - 1][j - 1]);
            else f[i][j] = min(f[i][j], f[i - 1][j - 1] + 1);
        }
    cout << f[n][m];
    return 0;
}
```





# [NOIP2003 提高组] 加分二叉树

## 题目描述

设一个 $n$ 个节点的二叉树 $\text{tree}$ 的中序遍历为$(1,2,3,\ldots,n)$，其中数字 $1,2,3,\ldots,n$ 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\text{tree}$ 及它的每个子树都有一个加分，任一棵子树 $\text{subtree}$（也包含 $\text{tree}$ 本身）的加分计算方法如下：


$\text{subtree}$ 的左子树的加分 $\times$ $\text{subtree}$ 的右子树的加分 $+$ $\text{subtree}$ 的根的分数。

若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。

试求一棵符合中序遍历为 $(1,2,3,\ldots,n)$ 且加分最高的二叉树 $\text{tree}$。要求输出

1. $\text{tree}$ 的最高加分。

2. $\text{tree}$ 的前序遍历。

## 输入格式

第 $1$ 行 $1$ 个整数 $n$，为节点个数。

第 $2$ 行 $n$ 个用空格隔开的整数，为每个节点的分数

## 输出格式

第 $1$ 行 $1$ 个整数，为最高加分（$ Ans \le 4,000,000,000$）。

第 $2$ 行 $n$ 个用空格隔开的整数，为该树的前序遍历。

## 样例 #1

### 样例输入 #1

```
5
5 7 1 2 10
```

### 样例输出 #1

```
145
3 1 2 4 5
```

## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \times 10^9$。

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 50;
typedef long long LL;
LL n;
LL f[N][N], root[N][N];

void print(LL l, LL r) {
    if (l > r)return;
    printf("%lld ", root[l][r]);
    if (l == r)return;
    print(l, root[l][r] - 1);
    print(root[l][r] + 1, r);
}

int main() {
    scanf("%lld", &n);
    for (int i = 1; i <= n; i++)scanf("%lld", &f[i][i]), f[i][i - 1] = 1, root[i][i] = i;
    for (int len = 1; len < n; ++len) {
        for (int i = 1; i + len <= n; ++i) {
            int j = i + len;
            f[i][j] = f[i + 1][j] + f[i][i];//默认它的左子树为空，如果有的话，这肯定不是最优解
            root[i][j] = i;//默认从起点选根
            for (int k = i + 1; k < j; ++k) {
                if (f[i][j] < f[i][k - 1] * f[k + 1][j] + f[k][k]) {
                    f[i][j] = f[i][k - 1] * f[k + 1][j] + f[k][k];
                    root[i][j] = k;
                }
            }
        }
    }
    cout << f[1][n] << endl;
    print(1, n);
    return 0;
}
```

一道入门的区间dp，当然，根据写法不同你还可以把它归类为树形dp或者记忆化搜索，其实都无所谓啦。
 作为一道入门题，我们完全可以“显然”地做出来，但是在这里还是想和大家回顾下动态规划以及区间动规。

Q：dp特点是什么？
A：dp把原问题视作若干个**重叠**的子问题的逐层递进，每个子问题的求解过程都会构成一个“阶段”，在完成一个阶段后，才会执行下一个阶段。
Q：dp要满足**无后效性**，什么叫无后效性？
A：已经求解的子问题不受后续阶段的影响。

有人觉得dp很抽象，那是因为没有一步一步来想，直接听别人的结论，我们在这里以这道题为例，一步一步来推导。

首先，我们要做的就是**设计状态**，其实就是设计`dp`数组的含义，它要满足无后效性。
 关注这个`左子树*右子树+根`我只要知道左子树分数和右子树分数和根的分数（已给出），不就可以了吗？管他子树长什么样！
 所以，我们`f`数组存的就是最大分数，怎么存呢？
 我们发现：子树是一个或多个节点的集合。
 那么我们可不可以开一个`f[i][j]`来表示节点`i`到节点`j`成树的最大加分呢？可以先保留这个想法（毕竟暂时也想不到更好的了）。

如果这样话，我们就来设计状态转移方程。
 按照刚刚的设计来说的话，我们的答案就是`f[1][n]`了，那么我们可以从小的子树开始，也就是`len`，区间长度。有了区间长度我们就要枚举区间起点，i为区间起点，然后就可以算出区间终点j。
 通过加分二叉树的式子我们可以知道，二叉树的分取决于谁是根，于是我们就在区间内枚举根k。
 特别的，`f[i][i]=a[i]`其中`a[i]`为第`i`个节点的分数。
 因为是要求最大值，所以我们就可以设计出

`f[i][j]=MAX(f[i][k−1]∗f[k+1][j]+f[k][k])f[i][j]=MAX(f[i][k−1]∗f[k+1][j]+f[k][k])`

于是乎，我们就自己设计出了一个dp过程，因为是顺着来的，所以很少有不成立的。

至于输出前序遍历，我们再设计一个状态`root[i][j]`来表示节点i到节点j成树的最大加分所选的根节点。
 所以我们按照根−>左−>右的顺序递归输出即可。

**另外一种利用DFS进行记忆化搜索的代码**

```c++
#include<iostream>

using namespace std;
typedef long long int LL;
const int N = 34;
int n, a[N], root[N][N];//a来存储中序遍历，root来存储最大积分的根节点
LL dp[N][N];//dp[l][r]记录从l区域到r区域最大的加分

LL dfs(int l, int r) {  //电风扇函数
    if (l > r)return 1;
    if (l == r) {           //如果为叶节点，最大积分的根节点就是当前节点l
        root[l][r] = l;
        return a[l];
    }
    if (dp[l][r])return dp[l][r];
    for (int i = l; i <= r; i++) {
        LL t = dfs(l, i - 1) * dfs(i + 1, r) + a[i];
        if (dp[l][r] < t) { //更新最大值以及根节点位置
            dp[l][r] = t;
            root[l][r] = i;
        }
    }
    return dp[l][r];
}

void print(int l, int r) {     //输出这棵树的先序遍历
    if (l > r)return;      //如果节点为空（依然是l<r）结束
    cout << root[l][r] << " ";  //先序遍历，先输出根节点
    print(l, root[l][r] - 1);  //然后左子树
    print(root[l][r] + 1, r);  //最后右子树
}

int main() {
    cin >> n;//输入
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        dp[i][i] = a[i];//叶节点的最大积分就是当前节点的积分，最大积分的根节点也是当前节点，直接给它初始化
        root[i][i] = i;
    }
    cout << dfs(1, n) << endl;//从头到尾搜索
    print(1, n);
    return 0; //树，是递归定义的
}
```



# 大师

## 题目背景

建筑大师最近在跟着数学大师 ljt12138 学数学，今天他学了等差数列，ljt12138 决定给他留一道练习题。

## 题目描述

ljt12138 首先建了 $n$ 个特斯拉电磁塔，这些电塔排成一排，从左到右依次标号为 $1$ 到 $n$，第 $i$ 个电塔的高度为 $h[i]$。

建筑大师需要从中选出一些电塔，然后这些电塔就会缩到地下去。这时候，如果留在地上的电塔的高度，从左向右构成了一个等差数列，那么这个选择方案就会被认为是美观的。

建筑大师需要求出，一共有多少种美观的选择方案，答案模 $998244353$。

注意，如果地上只留了一个或者两个电塔，那么这种方案也是美观的。地上没有电塔的方案被认为是不美观的。

同时也要注意，等差数列的公差也可以为负数。

## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个非负整数，第 $i$ 个整数是第 $i$ 个电塔的高度 $h[i]$。

## 输出格式

输出一个整数，表示美观的方案数模 $998244353$ 的值。

## 样例 #1

### 样例输入 #1

```
8
13 14 6 20 27 34 34 41
```

### 样例输出 #1

```
50
```

## 样例 #2

### 样例输入 #2

```
100
90 1004 171 99 1835 108 81 117 141 126 135 144 81 153 193 81 962 162 1493 171 1780 864 297 180 532 1781 189 1059 198 333 1593 824 207 1877 216 270 225 1131 336 1875 362 234 81 288 1550 243 463 1755 252 406 261 270 279 288 1393 261 1263 297 135 333 872 234 881 180 198 81 225 306 180 90 315 81 81 198 252 81 297 1336 1140 1238 81 198 297 661 81 1372 469 1132 81 126 324 333 342 81 351 481 279 1770 1225 549
```

### 样例输出 #2

```
11153
```

## 提示

设 $v$ 为最高的电塔高度。

对于前 $30\%$ 的数据，$n \le 20 $。

对于前 $60\%$ 的数据，$n \le 100$，$v \le 2 \times 10^3$。

对于另外 $20\%$ 的数据，所有电塔的高度构成一个等差数列。

对于 $100\%$ 的数据，$n \le 10^3$，$v \leq2 \times 10^4$。

```c++
#include <bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 1010, mod = 998244353, M = 4e4 + 10;
int n, a[N];
LL f[N][M];

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    int p = 20000;
    LL ans = 0;
    for (int i = 1; i <= n; ++i) {
        ans++;  // 单独取第 i 个，前面的不取
        for (int j = i - 1; j; --j) {
            f[i][a[i] - a[j] + p] += f[j][a[i] - a[j] + p] + 1;
            f[i][a[i] - a[j] + p] %= mod;
            ans += f[j][a[i] - a[j] + p] + 1;
            ans %= mod;
        }
    }
    cout << ans << endl;
    return 0;
} 
```

注意题目中说单独一个算是等差数列，任意两个也算是等差数列

对于两个数字，他们组成的等差数列的公差一定是一样的

那么我们不必去枚举公差，直接枚举第 `i` 个数前面那个数，得到公差进行转移即可

-  `f[i][j]`表示以 `i` 结尾公差为 `j` 的等差数列个数
- `f[i][j]`表示第`i`个点之前（包括自己）公差为`j`的数列长度（包括公差相等的不同数列）

以`i`结尾，`上一个数是j且公差为k的等差数列的数量=以j结尾且公差为k的等差数列的数量 + 1`，一语点醒梦中人啊    

可以这样理解：在所有以第 `j` 项结尾的数列后追加一个 `i`，再加上 `j` 和 `i` 单独两项成的一个等差数列。



# [NOIP2012 普及组] 摆花

## 题目描述

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

## 输入格式

第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。

第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。

## 输出格式

一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
2 4
3 2
```

### 样例输出 #1

```
2
```

## 提示

【数据范围】

对于 $20\%$ 数据，有 $0<n \le 8,0<m \le 8,0 \le a_i \le 8$。

对于 $50\%$ 数据，有 $0<n \le 20,0<m \le 20,0 \le a_i \le 20$。

对于 $100\%$ 数据，有 $0<n \le 100,0<m \le 100,0 \le a_i \le 100$。

NOIP 2012 普及组 第三题

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110, mod = 1e6 + 7;
int n, m, f[N][N], s[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> s[i];
    f[0][0] = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= m; ++j)
            for (int k = 0; k <= min(s[i], j); ++k)
                f[i][j] = (f[i][j] + f[i - 1][j - k]) % mod;

    cout << f[n][m];
    return 0;
}
```

是背包问题的处理思路，主要是三重循环，依次枚举种类、容量、每种的个数。

注意第三层循环要加上一个`min`来确保不会越界，这在逻辑上也具有实际意义



# 木棍加工

## 题目描述

一堆木头棍子共有 $n$ 根，每根棍子的长度和宽度都是已知的。棍子可以被一台机器一个接一个地加工。机器处理一根棍子之前需要准备时间。准备时间是这样定义的：

- 第一根棍子的准备时间为 $1$ 分钟。
- 如果刚处理完长度为 $l$，宽度为 $w$ 的棍子，那么如果下一个棍子长度为 $l_i$，宽度为 $w_i$，并且满足 $l\ge l_i$、$w\ge w_i$，这个棍子就不需要准备时间，否则需要 $1$ 分钟的准备时间。

计算处理完 $n$ 根棍子所需要的最短准备时间。比如，你有 $5$ 根棍子，长度和宽度分别为 $(4,9),(5,2),(2,1),(3,5),(1,4)$，最短准备时间为 $2$（按 $(4,9),(3,5),(1,4),(5,2),(2,1)$ 的次序进行加工）。

## 输入格式

第一行是一个整数 $n$（$n\le5000$）。

第二行是 $2n$ 个整数，分别是 $l_1,w_1,l_2,w_2,\ldots,l_n,w_n$。$l$ 和 $w$ 的值均不超过 $10000$，相邻两数之间用空格分开。

## 输出格式

仅一行，一个整数，所需要的最短准备时间。

## 样例 #1

### 样例输入 #1

```
5
4 9 5 2 2 1 3 5 1 4
```

### 样例输出 #1

```
2
```

## 提示

对于 $100 \%$ 的数据，$1 \le n \le 5000$，$1 \le l_i, w_i \le {10}^4$。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 5050;

struct node {
    int l, r;

    bool operator<(const node &w) const {
        if (l == w.l) return r > w.r;
        return l > w.l;
    }
} d[N];

int n, q[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) cin >> d[i].l >> d[i].r;
    sort(d, d + n);
    int len = 0;
    for (int i = 0; i < n; ++i) {
        int l = 0, r = len;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (q[mid] < d[i].r) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = d[i].r;
    }
    cout << len << endl;
    return 0;
}
```

先根据长度从高到低排序，如果长度相同，再根据宽度从高到低排序。

如果是在同一次准备周期里面，前面的木棍一定在后面木棍之前被加工。

这样，这个问题就转化成了在n个数中，求不下降子序列最少个数。

**根据dilworth定理，不下降子序列最小个数等于最大上升子序列的长度。**

于是乎，问题又简化成求n个数的最大上升子序列



# [NOIP2004 提高组] 合唱队形

## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

## 输入格式

共二行。

第一行是一个整数 $n$（$2\le n\le100$），表示同学的总数。

第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\le t_i\le230$）是第 $i$ 位同学的身高（厘米）。

## 输出格式

一个整数，最少需要几位同学出列。

## 样例 #1

### 样例输入 #1

```
8
186 186 150 200 160 130 197 220
```

### 样例输出 #1

```
4
```

## 提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;
int n, a[N], q1[N], q2[N], ll[N], rr[N];

void solve() {
    cin >> n;
    for (int i = 0; i < n; ++i) scanf("%d", &a[i]);
    int len1 = 0;
    q1[0] = -2e9;
    for (int i = 0; i < n; ++i) {
        int l = 0, r = len1;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (q1[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len1 = max(len1, r + 1);
        q1[r + 1] = a[i];
        ll[i] = len1;
    }

    int len2 = 0;
    q2[0] = -2e9;
    for (int i = n - 1; i >= 0; --i) {
        int l = 0, r = len2;
        while (l < r) {
            int mid = l + r + 1 >> 1;
            if (q2[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len2 = max(r + 1, len2);
        q2[r + 1] = a[i];
        rr[i] = len2;
    }
    int res = 0;
    for (int i = 0; i < n - 1; ++i) {
        if (a[i] < a[i + 1]) res = max(res, ll[i] + rr[i + 1]);
    }
    cout << (res != 0 ? n - res : len1 + len2) << endl;
}

int main() {
    solve();
    return 0;
}
```