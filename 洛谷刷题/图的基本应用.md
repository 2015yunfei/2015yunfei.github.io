# 【深基18.例3】查找文献

## 题目描述

小K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。

假设洛谷博客里面一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及 $m(m\le10^6)$ 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。

这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。

![](%E5%BA%93/f4n4tlhi.png)

请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。

## 输入格式

共 $m+1$ 行，第 1 行为 2 个数，$n$ 和 $m$，分别表示一共有 $n(n\le10^5)$ 篇文章（编号为 1 到 $n$）以及$m(m\le10^6)$ 条参考文献引用关系。

接下来 $m$ 行，每行有两个整数 $X,Y$ 表示文章 X 有参考文献 Y。

## 输出格式

共 2 行。
第一行为 DFS 遍历结果，第二行为 BFS 遍历结果。

## 样例 #1

### 样例输入 #1

```
8 9
1 2
1 3
1 4
2 5
2 6
3 7
4 7
4 8
7 8
```

### 样例输出 #1

```
1 2 5 6 3 7 8 4 
1 2 3 4 5 6 7 8
```

```c++
#include<bits/stdc++.h>
using namespace std;

const int N = 1e5+10;

set<int> s[N];
int n,m;
bool st[N];

void dfs(int u){
	if(st[u]) return ;
	st[u]=true;
	printf("%d ",u);
	for(auto t:s[u]) dfs(t);
}

void bfs(){
	queue<int> q;
	q.push(1);

	while(q.size()){
		auto t=q.front();
		q.pop();
		
		if(st[t]) continue;
		st[t]=true;
		
		printf("%d ",t);
		for(auto i:s[t]) q.push(i);
	}
}

int main(){
	cin>>n>>m;
	
	for(int i=0;i<m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		s[a].insert(b);
	}
	
	dfs(1);
	puts("");
	memset(st,false,sizeof st);
	bfs();
	
	return 0;
	
} 
```

**考虑到要排序，用set代替邻接表的vector**
**为了更简洁的写法采用C++11**

# 图的遍历

https://www.luogu.com.cn/problem/P3916

## 题目描述

给出 $N$ 个点，$M$ 条边的有向图，对于每个点 $v$，求 $A(v)$ 表示从点 $v$ 出发，能到达的编号最大的点。

## 输入格式

第 $1$ 行 $2$ 个整数 $N,M$，表示点数和边数。

接下来 $M$ 行，每行 $2$ 个整数 $U_i,V_i$，表示边 $(U_i,V_i)$。点用 $1,2,\dots,N$ 编号。

## 输出格式

一行 $N$ 个整数 $A(1),A(2),\dots,A(N)$。

## 样例 #1

### 样例输入 #1

```
4 3
1 2
2 4
4 3
```

### 样例输出 #1

```
4 4 3 4
```

## 提示

- 对于 $60\%$ 的数据，$1 \leq N,M \leq 10^3$。
- 对于 $100\%$ 的数据，$1 \leq N,M \leq 10^5$。



第一时间写出的代码：

```c++
#include<bits/stdc++.h> 
using namespace std;

const int N = 1e5+10;

int h[N],e[N],ne[N],idx;
bool st[N];
int a[N];
int n,m;

void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

int check(int u){
	int ans=u;
	st[u]=true;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(!st[j]) ans=max(ans,check(j));
	}
	return ans;
}

int main(){
	memset(h,-1,sizeof h);
	
	cin>>n>>m;
	
	for(int i=0;i<m;++i){
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
	}
	
	for(int i=1;i<=n;i++){
		memset(st,false,sizeof st);
		a[i]=check(i);
	}
	
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	
	return 0;
}
```



尝试优化后仍然有一个测试点超时：

```c++
#include<bits/stdc++.h> 
using namespace std;

const int N = 1e5+10;

int h[N],e[N],ne[N],idx;
bool st[N];
int a[N];
int n,m;

void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

int check(int u){
	int ans=u;
	st[u]=true;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		if(a[j]!=0) ans=max(ans,a[j]);
		else if(!st[j]) ans=max(ans,check(j));
	}
	return ans;
}

int main(){
	memset(h,-1,sizeof h);
	
	cin>>n>>m;
	
	for(int i=0;i<m;++i){
		int a,b;
		scanf("%d%d",&a,&b);
		add(a,b);
	}
	
	for(int i=1;i<=n;i++){
		memset(st,false,sizeof st);
		a[i]=check(i);
	}
	
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	
	return 0;
}
```



看完题解后尝试反向建边：

```c++
#include<bits/stdc++.h> 
using namespace std;
const int N = 1e5+10;

int h[N],e[N],ne[N],idx;
int a[N];
int n,m;

void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

void insert(int u,int s){
	if(a[u]!=0) return ;
	a[u]=s;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		insert(j,s);
	}
}

int main(){
	memset(h,-1,sizeof h);
	
	cin>>n>>m;
	
	for(int i=0;i<m;++i){
		int a,b;
		scanf("%d%d",&a,&b);
		add(b,a);
	}
	
	for(int i=n;i>=1;--i) insert(i,i);
	
	for(int i=1;i<=n;i++) printf("%d ",a[i]);
	
	return 0;
}
```

成功AC！

由多个点到一个点可以转化成为一个点到多个点

所以可以反向建边，然后编号从大到小 dfs

复杂度O（n），每个点只遍历一次



# 杂务

https://www.luogu.com.cn/problem/P1113

## 题目描述

`John`的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务$1$。`John`有需要完成的$n$个杂务的清单，并且这份清单是有一定顺序的，杂务$k(k>1)$的准备工作只可能在杂务$1$至$k-1$中。

写一个程序从$1$到$n$读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定`John`的农场有足够多的工人来同时完成任意多项任务。

## 输入格式

第1行：一个整数$n$，必须完成的杂务的数目($3 \le n \le 10,000$)；

第$2$至$(n+1)$行： 共有$n$行，每行有一些用$1$个空格隔开的整数，分别表示：

\* 工作序号($1$至$n$,在输入文件中是有序的)；

\* 完成工作所需要的时间$len(1 \le len \le 100)$；

\* 一些必须完成的准备工作，总数不超过$100$个，由一个数字$0$结束。有些杂务没有需要准备的工作只描述一个单独的$0$，整个输入文件中不会出现多余的空格。

## 输出格式

一个整数，表示完成所有杂务所需的最短时间。

## 样例 #1

### 样例输入 #1

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

### 样例输出 #1

```
23
```

```c++
#include<bits/stdc++.h> 
using namespace std;
const int N = 1e5+10;

int h[N],e[N],ne[N],w[N],idx;
int a[N];
int n,m;

void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

void check(int u){
	int ans=0;
	for(int i=h[u];i!=-1;i=ne[i]){
		int j=e[i];
		ans=max(ans,a[j]);
	}
	a[u]=ans+w[u];
}

int main(){
	memset(h,-1,sizeof h);
	
	cin>>n;
	
	for(int i=1;i<=n;++i){
		int a,b,c;
		scanf("%d%d%d",&a,&b,&c);
		w[i]=b;
		while(c!=0){
			add(a,c);
			scanf("%d",&c);
		}
	}
	
	for(int i=1;i<=n;i++) check(i);
	
	int ans=0;
	for(int i=1;i<=n;i++) ans=max(ans,a[i]);
	cout<<ans;
	
	return 0;
}
```

反向建图，从小开始遍历存储时间的数组



# 最大食物链计数

https://www.luogu.com.cn/problem/P4017

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。

## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。

## 输入格式

第一行，两个正整数 $n、m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。

接下来 $m$ 行，每行两个正整数，表示被吃的生物A和吃A的生物B。

## 输出格式

一行一个整数，为最大食物链数量模上 $80112002$ 的结果。

## 样例 #1

### 样例输入 #1

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4
```

### 样例输出 #1

```
5
```

## 提示

各测试点满足以下约定：

 ![](%E5%BA%93/12011.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5010;
const int mod = 80112002;

int s[N],n,m;
int h[N],e[N],ne[N],idx;
int rudu[N],chudu[N];

void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

int main(){
	memset(h,-1,sizeof h);
	
	scanf("%d%d",&n,&m);
	
	for(int i=0;i<m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		rudu[b]++;
		chudu[a]++;
		add(a,b);
	}
	
	for(int i=1;i<=n;i++) if(rudu[i]==0) s[i]=1;
	
	queue<int> q;
	for(int i=1;i<=n;i++) if(rudu[i]==0) q.push(i);
	
	while(q.size()){
		int t=q.front();
		q.pop();
		
		for(int i=h[t];i!=-1;i=ne[i]){
			int j=e[i];
			s[j]=(s[j]+s[t])%mod;
			rudu[j]--;
			if(rudu[j]==0) q.push(j);
		}
	}
	
	int ans=0;
	for(int i=1;i<=n;i++) 
		if(chudu[i]==0){
			ans=(ans+s[i])%mod;
			//cout<<i<<endl;
		}  
	cout<<ans;
	
	return 0;
}
```

四个测试点AC，还有几个超时

结果检查发现数组开小了（痛！！！

```c++
#include<bits/stdc++.h>
using namespace std;
const int N = 5010;
const int M = 5e5+10;
const int mod = 80112002;

int s[N],n,m;
int h[N],e[M],ne[M],idx;
int rudu[N],chudu[N];

void add(int a,int b){
	e[idx]=b;
	ne[idx]=h[a];
	h[a]=idx++;
}

int main(){
	memset(h,-1,sizeof h);
	
	scanf("%d%d",&n,&m);
	
	for(int i=0;i<m;i++){
		int a,b;
		scanf("%d%d",&a,&b);
		rudu[b]++;
		chudu[a]++;
		add(a,b);
	}

	queue<int> q;
	for(int i=1;i<=n;i++)
		if(rudu[i]==0){
			q.push(i);
			s[i]=1;
		}
		
	int ans=0;
	while(q.size()){
		int t=q.front();
		q.pop();
		
		for(int i=h[t];i!=-1;i=ne[i]){
			int j=e[i];
			s[j]=(s[j]+s[t])%mod;
			rudu[j]--;
			if(rudu[j]==0){
				if(chudu[j]==0) ans=(ans+s[j])%mod;
				else q.push(j);
			}
		}
	}
	cout<<ans;
	return 0;
}
```



# 最长路

## 题目描述

设 $G$ 为有 $n$ 个顶点的带权有向无环图，$G$ 中各顶点的编号为 $1$ 到 $n$，请设计算法，计算图 $G$ 中 $1, n$ 间的最长路径。

## 输入格式

输入的第一行有两个整数，分别代表图的点数 $n$ 和边数 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行 $3$ 个整数 $u, v, w$（$u<v$），代表存在一条从 $u$ 到  $v$ 边权为 $w$ 的边。

## 输出格式

输出一行一个整数，代表 $1$ 到 $n$ 的最长路。

若 $1$ 无法到达 $n$，请输出 $-1$。

## 样例 #1

### 样例输入 #1

```
2 1
1 2 1
```

### 样例输出 #1

```
1
```

## 提示

**【数据规模与约定】**

- 对于 $20\%$的数据，$n \leq 100$，$m \leq 10^3$。
- 对于 $40\%$ 的数据，$n \leq 10^3$，$m \leq 10^{4}$。
- 对于 $100\%$ 的数据，$1 \leq n \leq 1500$，$0 \leq m \leq 5 \times 10^4$，$1 \leq u, v \leq n$，$-10^5 \leq w \leq 10^5$。

```c++
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

const int N = 1510;
const int M = 4e5+10;

int n, m;
int h[N], w[M], e[M], ne[M], idx;
int dist[N];
bool st[N];

void add(int a, int b, int c)
{
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx ++ ;
}

int spfa()
{
	
    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        int t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] < dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    return dist[n];
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);

    while (m -- )
    {
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        add(a, b, c);
    }

    int t = spfa();

    if (t == 0) puts("-1");
    else printf("%d\n", t);

    return 0;
}
```



INT_MIN在标准头文件 limits.h 中定义

```c++
#define INT_MAX 2147483647
#define INT_MIN (-INT_MAX - 1)
```



![image-20221227185443374](%E5%BA%93/image-20221227185443374.png)
