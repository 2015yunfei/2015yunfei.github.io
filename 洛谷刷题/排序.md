# 【深基9.例1】选举学生会

## 题目描述

学校正在选举学生会成员，有 $n(n\le 999)$ 名候选人，每名候选人编号分别从 1 到 $n$，现在收集到了 $m(m<=2000000)$ 张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。

## 输入格式

输入 $n$ 和 $m$ 以及 $m$ 个选票上的数字。

## 输出格式

求出排序后的选票编号。

## 样例 #1

### 样例输入 #1

```
5 10
2 5 2 2 5 2 2 2 1 2
```

### 样例输出 #1

```
1 2 2 2 2 2 2 2 5 5
```



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 2000010;
int person[N];

int main() {
    int n, m, num;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        scanf("%d", &num);
        person[i] = num;
    }
    sort(person, person + m);
    for (int i = 0; i < m; ++i)printf("%d ", person[i]);
    return 0;
} 
```

我们发现这还不够快，怎么办？

用桶排！

用1000 的数组记录票出现的次数，最后根据票出现的次数输出即可

```c++
#include<bits/stdc++.h>

using namespace std;
int a, n, m, b[1000];

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; i++)cin >> a, ++b[a]; //记录票出现的次数
    for (int i = 0; i < 1000; i++)while (b[i]--)cout << i << " "; //根据票出现的次数输出
    return 0;
}
```



# 【模板】快速排序

## 题目描述

利用快速排序算法将读入的 $N$ 个数从小到大排序后输出。

快速排序是信息学竞赛的必备算法之一。对于快速排序不是很了解的同学可以自行上网查询相关资料，掌握后独立完成。（C++ 选手请不要试图使用 `STL`，虽然你可以使用 `sort` 一遍过，但是你并没有掌握快速排序算法的精髓。）

## 输入格式

第 $1$ 行为一个正整数 $N$，第 $2$ 行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数，数据保证了 $a_i$ 不超过 $10^9$。

## 输出格式

将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。

## 样例 #1

### 样例输入 #1

```
5
4 2 4 5 1
```

### 样例输出 #1

```
1 2 4 4 5
```

## 提示

对于 $20\%$ 的数据，有 $N\leq 10^3$；

对于 $100\%$ 的数据，有 $N\leq 10^5$。



```c++
#include<bits/stdc++.h>

using namespace std;
int a[100010];

void quick_sort(int a[], int l, int r) {
    if (l >= r)return;
    int i = l - 1, j = r + 1, x = a[l + r >> 1];
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j)swap(a[i], a[j]);
    }
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
    }
    quick_sort(a, 0, n - 1);
    for (int i = 0; i < n; ++i) {
        printf("%d ", a[i]);
    }
    return 0;
}
```



理论上来说，桶排序所要占用的空间很大，所以我们可以用 STL 容器中的毒瘤数据结构map来做（相当于动态开筒）

```c++
#include<bits/stdc++.h>

using namespace std;

int main() {
    map<int, int> a;
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int x;
        cin >> x;
        a[x]++;
    }

    for (auto & it : a) {
        aa:;
        if (it.second == 0) continue;
        cout << it.first << ' ';
        it.second--;
        goto aa;
    }
    return 0;
}
```



这道题用传统快排（如下所示）的结果就是最后三个点 TLE

```c++
void swap(int &a, int &b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

void quickSort(int a[], int left, int right)
{
    if (left >= right)
        return;
    int i = left, j = right;
    while (i < j)
    {
        while (j > i && a[j] >= a[left])
            j--;
        while (i < j && a[i] <= a[left])
            i++;
        swap(a[i], (i == j) ? a[left] : a[j]);  //i和j相遇则与枢轴元素交换，否则a[i]与a[j]交换
    }
    quickSort(a, left, i-1);
    quickSort(a, j+1, right);
}
```

​		因为快排对于一些特殊的情况（例如序列原本就有序、有大量重复元素等等）会进行很多完全不必要的操作，耗费大量时间。为此，我们基于上述普通快速排序算法一步步进行优化。



**随机化：**

​		如果永远取第一个元素作为枢轴的话，在数组已经有序的情况下每次划分都将得到最坏的结果，时间复杂度退化为O(n^2^)。因为其中一个子序列每次都只比原序列少一个元素，该侧的递归深度将达到最大。
​		然而，我们可以通过随机选取枢轴元素来打破这种固定模式，这样每次都是最坏划分的概率就非常小了。实现起来只需要先将随机选中的元素和第一个元素交换一下位置作为枢轴元素，然后就可以接着用原来的方法进行排序了。

```c++
void quickSort(int a[], int left, int right)
{
    if (left >= right)
        return;
    **int i = left, j = right, pivot = rand() % (right - left + 1) + left;**
    **swap(a[left], a[pivot]);**
    while (i < j)
    {
        while (j > i && a[j] >= a[left])
            j--;
        while (i < j && a[i] <= a[left])
            i++;
        swap(a[i], (i == j) ? a[left] : a[j]);
    }
    quickSort(a, left, i-1);
    quickSort(a, j+1, right);
}
```



**小区间插入排序：**

​		当序列长度分割到足够小后，继续使用快速排序递归分割的效率反而没有直接插入排序高。因此我们可以增加一个判断，当区间长度小于10以后改为使用插入排序。

```c++
void insertSort(int a[], int left, int right)
{
    for (int i = left + 1; i <= right; i++)
        for (int j = i; j > 0 && a[j] < a[j-1]; j--)
            swap(a[j], a[j-1]);
}

void quickSort(int a[], int left, int right)
{
    if (left >= right)
        return;
    **if (right - left + 1 < 10)
    {
        insertSort(a, left, right);
        return;
    }**
    int i = left, j = right, pivot = rand() % (right - left + 1) + left;
    swap(a[left], a[pivot]);
    while (i < j)
    {
        while (j > i && a[j] >= a[left])
            j--;
        while (i < j && a[i] <= a[left])
            i++;
        swap(a[i], (i == j) ? a[left] : a[j]);
    }
    quickSort(a, left, i-1);
    quickSort(a, j+1, right);
}
```



# 【深基9.例4】求第 k 小的数

## 题目描述

输入 $n$（$1 \le n < 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i < {10}^9$），输出这些数字的第 $k$ 小的数。最小的数是第 $0$ 小。

请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。

## 输入格式

无

## 输出格式

无

## 样例 #1

无

### 样例输入 #1

```
5 1
4 3 2 1 5
```

### 样例输出 #1

```
2
```



```c++
#include<bits/stdc++.h>

using namespace std;
int a[5000010];

int quick_sort(int l, int r, int k) {
    if (l == r) return a[l];
    int i = l - 1, j = r + 1, x = a[i + j >> 1];
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    if (j - l + 1 >= k) return quick_sort(l, j, k);// 长度是 j-l+1 用长度和 k 比较
    else return quick_sort(j + 1, r, k - (j - l + 1));
}

int main() {
    int n, k;
    cin >> n >> k;
    ++k;
    for (int i = 0; i < n; ++i)scanf("%d", &a[i]);

    cout << quick_sort(0, n - 1, k);
    return 0;
}
```



**注意：这个题第 k 小的数是从零开始，而 AcWing 上的第 k 小的数是从 1 开始**



![image-20230108212201186](%E5%BA%93/image-20230108212201186.png)



# [NOIP2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

## 输入格式

输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。

第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。

## 输出格式

输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。

第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

## 样例 #1

### 样例输入 #1

```
10
20 40 32 67 40 20 89 300 400 15
```

### 样例输出 #1

```
8
15 20 32 40 67 89 300 400
```

## 提示

NOIP 2006 普及组 第一题



```c++
#include<bits/stdc++.h>

using namespace std;

int main() {
    int N;
    cin >> N;
    int *arr = (int *) malloc(N * sizeof(int));
    for (int i = 0; i < N; ++i) {
        scanf("%d", &arr[i]);
    }
    sort(arr, arr + N);
    int sum = 0;
    for (int i = 0; i < N - 1; ++i) {
        if (arr[i] == arr[1 + i]) {
            arr[i] = 0;
            sum++;
            continue;
        }
    }
    printf("%d\n", N - sum);
    for (int i = 0; i < N; ++i) {
        if (arr[i] != 0) {
            printf("%d ", arr[i]);
        }
    }
} 
```



我们可以使用桶排序的思想，因为数据范围很小且都是正整数

```c++
#include<iostream>

using namespace std;

int main() {
    int n, x;
    cin >> n;
    int sum(0), bus[1002] = {0};
    for (int i = 1; i <= n; i++) {
        cin >> x;
        if (bus[x])  //如果这个数已经出现过了，那么跳过
            continue;
        bus[x]++;  //如果没有出现，把数据放在桶里，并让总数居++
        sum++;
    }
    cout << sum << endl;
    for (int i = 1; i <= 1000; i++)
        if (bus[i])
            cout << i << ' ';
    cout << endl;
    return 0;
}
```



其实这题用 STL 中的 set（集合）做是再简单不过了

set，顾名思义，就是数学上的集合——每个元素最多只出现一次，并且 set 中的元素已经从小到大排好序

**常用操作 ：**

- begin() 　　 返回 set 容器的第一个元素的地址
- end() 　　    返回 set 容器的最后一个元素后面的地址，实际上该位置无有效值 
- clear() 　　   删除 set 容器中的所有的元素
- empty() 　    判断 set 容器是否为空
- max_size() 　返回 set 容器可能包含的元素最大个数
- size() 　　　 返回当前 set 容器中的元素个数
- erase(it)         删除迭代器指针 it 处元素
- insert(a)         插入某个元素
- count()           用来查找set中某个元素出现的次数。这个函数在 set 并不是很实用，因为一个键值在 set 只可能出现 0 或 1 次，这样就变成了判断某一键值是否在 set 出现过了
- find()              用来查找 set 中某个元素出现的位置。如果找到，就返回这个元素的迭代器，如果这个元素不存在，则返回 s.end() 。 (最后一个元素的下一个位置，s 为 set 的变量名)

```c++
#include<bits/stdc++.h>

using namespace std;
set<int> s;
int a[105];

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> a[i];
        s.insert(a[i]);
    }
    cout << s.size() << endl;
    for (auto t: s) {
        cout << t << " ";
    }
    return 0;
}
```



# [NOIP2007 普及组] 奖学金

## 题目描述

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 $5$ 名学生发奖学金。期末，每个学生都有 $3$ 门课的成绩:语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学 排在前面，这样，每个学生的排序是唯一确定的。

任务：先根据输入的 $3$ 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。注意，在前 $5$ 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据(每行输出两个数:学号、总分) 是:

$7$  $279$  
$5$  $279$  

这两行数据的含义是:总分最高的两个同学的学号依次是 $7$ 号、$5$ 号。这两名同学的总分都是 $279$ (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 $7$ 的学生语文成绩更高一些。如果你的前两名的输出数据是:

$5$  $279$  
$7$  $279$  

则按输出错误处理，不能得分。

## 输入格式

共 $n+1$行。

第 $1$ 行为一个正整数$n ( \le 300)$，表示该校参加评选的学生人数。

第 $2$ 到 $n+1$ 行，每行有 $3$ 个用空格隔开的数字，每个数字都在 $0$ 到 $100$ 之间。第 $j$ 行的 $3$ 个数字依次表示学号为 $j-1$ 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 $1\sim n$（恰好是输入数据的行号减 $1$）。

所给的数据都是正确的，不必检验。


//感谢 黄小U饮品 修正输入格式

## 输出格式

共 $5$ 行，每行是两个用空格隔开的正整数，依次表示前 $5$ 名学生的学号和总分。

## 样例 #1

### 样例输入 #1

```
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
```

### 样例输出 #1

```
6 265
4 264
3 258
2 244
1 237
```

## 样例 #2

### 样例输入 #2

```
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
```

### 样例输出 #2

```
8 265
2 264
6 264
1 258
5 258
```



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 300;
struct p {
    int num, yuwen, shuxue, english;
} person[N];//下标从 0 开始 
int n;

bool cmp(p a, p b) {
    if (a.yuwen + a.shuxue + a.english != b.yuwen + b.shuxue + b.english)
        return a.yuwen + a.shuxue + a.english > b.yuwen + b.shuxue + b.english;
    else return a.yuwen == b.yuwen ? a.num < b.num : a.yuwen > b.yuwen;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        scanf("%d%d%d", &person[i].yuwen, &person[i].shuxue, &person[i].english);
        person[i].num = 1 + i;
    }
    sort(person, person + n, cmp);
    for (int i = 0; i < 5; ++i)printf("%d %d\n", person[i].num, person[i].yuwen + person[i].shuxue + person[i].english);
    return 0;
} 
```

**一道很好的结构体训练题**

一般使用 sort ，但是 sort 对结构体的排序就比较麻烦了，需要自己编写一个函数 cmp 作为 sort 的第三个参数



# 宇宙总统

## 题目描述

地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。

## 输入格式

第一行为一个整数 $n$，代表竞选总统的人数。

接下来有 $n$ 行，分别为第一个候选人到第 $n$ 个候选人的票数。

## 输出格式

共两行，第一行是一个整数 $m$，为当上总统的人的号数。

第二行是当上总统的人的选票。

## 样例 #1

### 样例输入 #1

```
5
98765
12365
87954
1022356
985678
```

### 样例输出 #1

```
4
1022356
```

## 提示

票数可能会很大，可能会到 $100$ 位数字。

$1 \leq n \leq 20$



```c++
#include<bits/stdc++.h>

using namespace std;
string now, ans;

bool check() {
    int i = 0;
    while (i < now.length()) {
        if (now[i] > ans[i])return true;
        else if (now[i] < ans[i])return false;
        ++i;
    }
    return false;
}

int main() {
    int n, who;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> now;
        if (now.length() > ans.length()) {
            who = i + 1;
            ans = now;
        } else if (now.length() == ans.length() && check()) {
            who = i + 1;
            ans = now;
        }
    }
    cout << who << endl << ans;
    return 0;
} 
```



其实对于只要比较大小的题，写高精度没必要

直接用 string 记录一个 max 每次比较很简单啊

**原理：string 的比较 保存数字的字符串 == 高精度版比较大小**

和字典序什么的有关系



同一思想的另一个实现方法：

```c++
#include <iostream>
#include<cstring>

using namespace std;

int main() {
    int n, num;
    char a[201], max[201] = "";
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a;
        if ((strlen(max) < strlen(a)) || (strlen(a) == strlen(max) && strcmp(max, a) < 0)) {//若a的长度==max的长度，再用strcmp比较  
            strcpy(max, a);
            num = i;
        }
    }
    cout << num << endl;
    puts(max);
    return 0;
}
```



# [USACO07DEC]Bookshelf B

## 题目描述

Farmer John最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 

所有 $N(1 \le N \le 20,000)$ 头奶牛都有一个确定的身高 $H_i(1 \le H_i \le 10,000)$。设所有奶牛身高的和为S。书架的高度为B，并且保证 $1 \le B \le S < 2,000,000,007$。 

为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。

显然，塔中的奶牛数目越多，整座塔就越不稳定，于是奶牛们希望在能够到书架顶的前提下，让塔中奶牛的数目尽量少。 现在，奶牛们找到了你，希望你帮她们计算这个最小的数目。

## 输入格式

* 第 $1$ 行: 2 个用空格隔开的整数：$N$ 和 $B$；
* 第 $2\dots N+1$ 行: 第 $i+1$ 行是 $1$ 个整数：$H_i$。

## 输出格式

* 第 $1$ 行: 输出 $1$ 个整数，即最少要多少头奶牛叠成塔，才能够到书架顶部

## 样例 #1

### 样例输入 #1

```
6 40
6
18
11
13
19
11
```

### 样例输出 #1

```
3
```

## 提示

输入说明:

一共有 $6$ 头奶牛，书架的高度为 $40$，奶牛们的身高在 $6\dots19$之间。


输出说明:

一种只用 $3$ 头奶牛就达到高度 $40$ 的方法：$18+11+13$。当然还有其他方法，在此不一一列出了。



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 20010;
int a[N];

bool cmp(int a, int b) {
    return a > b;
}

int main() {
    int n, b;
    cin >> n >> b;
    for (int i = 0; i < n; ++i) scanf("%d", &a[i]);
    
    sort(a, a + n, cmp);
    
    int height = 0, i = 0;
    while (height < b) {
        height += a[i++];
    }
    cout << i;
    return 0;
} 
```



# 车厢重组

## 题目描述

在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。

## 输入格式

共两行。  

第一行是车厢总数 $N( \le 10000)$。

第二行是 $N$ 个不同的数表示初始的车厢顺序。

## 输出格式

一个整数，最少的旋转次数。

## 样例 #1

### 样例输入 #1

```
4
4 3 2 1
```

### 样例输出 #1

```
6
```



```c++
#include<bits/stdc++.h>

using namespace std;

int main() {
    int n;
    cin >> n;
    int *arr = (int *) malloc(n * sizeof(int));
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    int times = 0, temp;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n - 1 - i; ++j) {
            if (arr[j] > arr[j + 1]) {
                times++;
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
    cout << times;
    return 0;
}
```



# 欢乐的跳

## 题目描述

一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 $\{1,4,2,3\}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。

给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。

## 输入格式

每组测试数据第一行以一个整数 $n(1 \le n \le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。

## 输出格式

对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 `Jolly`，否则输出 `Not jolly`。

## 样例 #1

### 样例输入 #1

```
4 1 4 2 3
```

### 样例输出 #1

```
Jolly
```

## 样例 #2

### 样例输入 #2

```
5 1 4 2 -1 6
```

### 样例输出 #2

```
Not jolly
```

## 提示

$1 \le n \le 1000$



```c++
#include<bits/stdc++.h>

using namespace std;
int a[1000];
int b[1000];
int n;

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        scanf("%d", &a[i]);
        if (i > 0) {
            a[i - 1] = abs(a[i] - a[i - 1]);
        }
    }

    n--;

    for (int i = 0; i < n; ++i) {
        if (a[i] < 1000) {
            b[a[i]]++;
        }
    }

    //如果数组两个连续元素之间差的绝对值包括了[1,n-1]之间的所有整数，则称之符合"欢乐的跳"
    for (int i = 1; i < n; ++i)
        if (b[i] == 0) {
            printf("Not jolly");
            return 0;
        }

    printf("Jolly");
    return 0;
}
```

这题可以用桶排的思想做，也就是把差放在一个bool数组里，然后判断 [1,n-1] 是否满足



# [NOIP2009 普及组] 分数线划定

## 题目描述

世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150\%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150\%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。

现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。

## 输入格式

第一行，两个整数 $n,m(5 \leq n \leq 5000,3 \leq m \leq n)$，中间用一个空格隔开，其中 $n$ 表示报名参加笔试的选手总数，$m$ 表示计划录取的志愿者人数。输入数据保证 $m \times 150\%$ 向下取整后小于等于 $n$。

第二行到第 $n+1$ 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 $k(1000 \leq k \leq 9999)$和该选手的笔试成绩 $s(1 \leq s \leq 100)$。数据保证选手的报名号各不相同。

## 输出格式

第一行，有 $2$ 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。

从第二行开始，每行包含 $2$ 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。

## 样例 #1

### 样例输入 #1

```
6 3 
1000 90 
3239 88 
2390 95 
7231 84 
1005 95 
1001 88
```

### 样例输出 #1

```
88 5 
1005 95 
2390 95 
1000 90 
1001 88 
3239 88
```

## 提示

【样例说明】

$m \times 150\% = 3 \times150\% = 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。

NOIP 2009 普及组 第二题



```c++
#include<bits/stdc++.h>

using namespace std;
struct p {
    int num;
    int grade;
} person[5010];
int n, m;

bool cmp(p a, p b) {
    return a.grade != b.grade ? a.grade > b.grade : a.num < b.num;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i)scanf("%d%d", &person[i].num, &person[i].grade);
    
    sort(person, person + n, cmp);
    
    m = floor(m * 1.5);
    
    int fenshuxian = person[m - 1].grade;
    
    while (person[m].grade == fenshuxian) m++;
    
    cout << fenshuxian << " " << m << endl;
    
    for (int i = 0; i < m; ++i) {
        printf("%d %d\n", person[i].num, person[i].grade);
    }
    return 0;
}
```



# 攀爬者

## 题目背景

HKE 考完 GDOI 之后跟他的神犇小伙伴们一起去爬山。

## 题目描述

他在地形图上标记了 $N$ 个点，每个点 $P_i$ 都有一个坐标 $(x_i,y_i,z_i)$。所有点对中，高度值 $z$ 不会相等。HKE 准备从最低的点爬到最高的点，他的攀爬满足以下条件：

 (1) 经过他标记的每一个点；

 (2) 从第二个点开始，他经过的每一个点高度 $z$ 都比上一个点高；

 (3) HKE 会飞，他从一个点 $P_i$ 爬到 $P_j$ 的距离为两个点的欧几里得距离。即，$\sqrt{(X_i-X_j)^2+(Y_i-Y_j)^2+(Z_i-Z_j)^2}$

现在，HKE 希望你能求出他攀爬的总距离。

## 输入格式

第一行，一个整数 $N$ 表示地图上的点数。

接下来 $N$ 行，三个整数 $x_i,y_i,z_i$ 表示第 $i$ 个点的坐标。

## 输出格式

一个实数，表示 HKE 需要攀爬的总距离（保留三位小数）

## 样例 #1

### 样例输入 #1

```
5
2 2 2
1 1 1
4 4 4
3 3 3
5 5 5
```

### 样例输出 #1

```
6.928
```

## 提示

对于100%的数据，$1\leq N\leq 50000$，答案的范围在 double 范围内。



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 50010;
int n, x[N], y[N], z[N];

void quick_sort(int l, int r) {
    if (l >= r)return;
    int i = l - 1, j = r + 1, mid = z[(l + r) >> 1];
    while (i < j) {
        do i++; while (z[i] < mid);
        do j--; while (z[j] > mid);
        if (i < j) {
            swap(x[i], x[j]);
            swap(y[i], y[j]);
            swap(z[i], z[j]);
        }
    }
    quick_sort(l, j);
    quick_sort(j + 1, r);
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) scanf("%d%d%d", &x[i], &y[i], &z[i]);

    quick_sort(0, n - 1);

    double sum = 0;
    for (int i = 1; i <= n - 1; ++i)
        sum += sqrt(
                (x[i] - x[i - 1]) * (x[i] - x[i - 1]) + (y[i] - y[i - 1]) * (y[i] - y[i - 1]) +
                (z[i] - z[i - 1]) * (z[i] - z[i - 1]));

    printf("%.3lf", sum);
    return 0;
}

```



# 生日

## 题目描述

cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。

## 输入格式

输入共有 $n + 1$ 行，

第 $1$ 行为 OI 组总人数 $n$；

第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。

## 输出格式

输出共有 $n$ 行，

即 $n$ 个生日从大到小同学的姓名。（如果有两个同学生日相同，输入靠后的同学先输出）

## 样例 #1

### 样例输入 #1

```
3
Yangchu 1992 4 23
Qiujingya 1993 10 13
Luowen 1991 8 1
```

### 样例输出 #1

```
Luowen
Yangchu
Qiujingya
```

## 提示

数据保证，$1<n<100$，$1\leq |s|<20$。保证年月日实际存在，且年份 $\in [1960,2020]$。



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 110;
struct p {
    string name;
    int year, month, day, num;
} person[N];

bool cmp(p a, p b) {
    if (a.year != b.year)return a.year < b.year;
    else if (a.month != b.month)return a.month < b.month;
    else if (a.day != b.day)return a.day < b.day;
    else return a.num > b.num;
}

int main() {
    int n;
    cin >> n;
    
    for (int i = 0; i < n; ++i) {
        cin >> person[i].name >> person[i].year >> person[i].month >> person[i].day;
        person[i].num = i;
    }
    
    sort(person, person + n, cmp);
    
    for (int i = 0; i < n; ++i) cout << person[i].name << endl;
    return 0;
}
```



# [NOIP1998 提高组] 拼数

## 题目描述

设有 $n$ 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。

## 输入格式

第一行有一个整数，表示数字个数 $n$。

第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。

## 输出格式

一个正整数，表示最大的整数

## 样例 #1

### 样例输入 #1

```
3
13 312 343
```

### 样例输出 #1

```
34331213
```

## 样例 #2

### 样例输入 #2

```
4
7 13 4 246
```

### 样例输出 #2

```
7424613
```

## 提示

对于全部的测试点，保证 $1 \leq n \leq 20$，$1 \leq a_i \leq 10^9$。



```c++
#include<bits/stdc++.h>

using namespace std;

bool CHECK(string a, string b) {
    return a + b > b + a;
}

int main() {
    int n;
    cin >> n;

    string a[n];
    for (int i = 0; i < n; i++) cin >> a[i];

    sort(a, a + n, CHECK);

    for (int i = 0; i < n; i++) {
        cout << a[i];
    }
    
    return 0;
}
```

![image-20230108223658032](%E5%BA%93/image-20230108223658032.png)

