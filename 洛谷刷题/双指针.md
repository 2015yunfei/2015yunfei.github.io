# [USACO11NOV]Cow Lineup S

## 题目背景

【问题描述】


农民约翰雇一个专业摄影师给他的部分牛拍照。由于约翰的牛有好多品种，他喜欢他的照片包含每


个品种的至少一头牛。


约翰的牛都站在一条沿线的不同地方， 每一头牛由一个整数位置 X\_i以及整数品种编号 ID\_i表示。


约翰想拍一张照片，这照片由沿线的奶牛的连续范围组成。照片的成本与规模相当，这就意味着，在一


系列照片中的最大和最小 X 坐标的差距决定了照片的成本。


请帮助约翰计算最小的照片成本，这些照片中有每个不同的品种的至少一头牛，没有两头牛愿意站


在同一个地点的。


【输入格式】


第 1 行：牛的数量 N；


第 2..1+N 行：每行包含 2 个以空格分隔的正整数 X\_i 和 ID\_i；意义如题目描述；


【输出格式】


输出共一行，包含每个不同品种 ID 的照片的最低成本。


【输入样例】


6 25 7 26 1 15 1 22 3 20 1 30 1 【输出样例】


4 【输入说明】在不同的坐标点 25,26,15,22,20,30 中有六头牛


【输出说明】在约翰的牛中，从 X=22 到 X=26（整个规模为 4）包含了每个的不同品种的 ID 3，7 和 1。


【数据规模】


对于 50%的数据： 1≤N≤300；


对于 100%的数据：1≤N≤50,000；0≤X\_i≤1,000,000,000；1≤ID\_i≤1,000,000,000；


感谢uid=15936的翻译

## 题目描述

Farmer John has hired a professional photographer to take a picture of some of his cows.  Since FJ's cows represent a variety of different breeds, he would like the photo to contain at least one cow from each distinct breed present in his herd.

FJ's N cows are all standing at various positions along a line, each described by an integer position (i.e., its x coordinate) as well as an integer breed ID.  FJ plans to take a photograph of a contiguous range of cows along the line.  The cost of this photograph is equal its size -- that is, the difference between the maximum and minimum x coordinates of the cows in the range of the photograph.

Please help FJ by computing the minimum cost of a photograph in which there is at least one cow of each distinct breed appearing in FJ's herd.

依次给出N头牛的位置及种类，要求找出连续一段，使其中包含所有种类的牛，问：这连续的一段最小长度是多少？

## 输入格式

\* Line 1: The number of cows, N (1 <= N <= 50,000). 

\* Lines 2..1+N: Each line contains two space-separated positive integers specifying the x coordinate and breed ID of a single cow.  Both numbers are at most 1 billion.

## 输出格式

\* Line 1: The smallest cost of a photograph containing each distinct breed ID.

## 样例 #1

### 样例输入 #1

```
6 
25 7 
26 1 
15 1 
22 3 
20 1 
30 1
```

### 样例输出 #1

```
4
```

## 提示

There are 6 cows, at positions 25,26,15,22,20,30, with respective breed IDs 7,1,1,3,1,1.


The range from x=22 up through x=26 (of total size 4) contains each of the distinct breed IDs 1, 3, and 7 represented in FJ's herd.

感谢 wjcwinmt  提供题目简述

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 5e4 + 10;
int n;
vector<int> allid;
int sum[N];
int ans = 1e9;

struct node {
    int x, id;

    bool operator<(const node &d) const {
        return x < d.x;
    }
} tr[N];

int findid(int x) {
    int l = 0, r = allid.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (allid[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l + 1;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> tr[i].x >> tr[i].id;
        allid.push_back(tr[i].id);
    }
    sort(allid.begin(), allid.end());
    allid.erase(unique(allid.begin(), allid.end()), allid.end());

    for (int i = 0; i < n; ++i) {
        tr[i].id = findid(tr[i].id);
    }
    sort(tr, tr + n);

    int in = 0;
    for (int i = 0, j = 0; j < n; ++j) {
        if (sum[tr[j].id] == 0) in++;
        sum[tr[j].id]++;

        if (in == allid.size()) {
            while (sum[tr[i].id] > 1) {
                sum[tr[i].id]--;
                i++;
            }
            ans = min(ans, tr[j].x - tr[i].x);
            sum[tr[i].id]--;
            in--;
            i++;
        }
    }
    cout << ans << endl;
    return 0;
}
```



# [蓝桥杯 2018 省 B] 日志统计

## 题目描述

小明维护着一个程序员论坛。现在他收集了一份“点赞”日志，日志共有 $N$ 行。其中每一行的格式是 `ts id`，表示在 $ts$ 时刻编号 $id$ 的帖子收到一个“赞”。

现在小明想统计有哪些帖子曾经是“热帖”。如果一个帖子曾在任意一个长度为 $D$ 的时间段内收到不少于 $K$ 个赞，小明就认为这个帖子曾是“热帖”。

具体来说，如果存在某个时刻 $T$ 满足该帖在 $[T,T+D)$ 这段时间内（注意是左闭右开区间）收到不少于 $K$ 个赞，该帖就曾是“热帖”。

给定日志，请你帮助小明统计出所有曾是“热帖”的帖子编号。

## 输入格式

第一行包含三个整数 $N$、$D$ 和 $K$。

以下 $N$ 行每行一条日志，包含两个整数 $ts$ 和 $id$。

## 输出格式

按从小到大的顺序输出热帖 $id$。每个 $id$ 一行。

## 样例 #1

### 样例输入 #1

```
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3
```

### 样例输出 #1

```
1  
3
```

## 提示

对于 $50\%$ 的数据，$1 \le K \le N \le 1000$。

对于 $100\%$ 的数据，$1 \le K \le N \le 10^5$，$0 \le id, ts \le 10^5$。

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛

**本题更像是一个双指针的问题**

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
typedef pair<int, int> PII;

PII logs[N];
int k, n, d;
int cnt[N];
bool st[N];

int main() {
    cin >> n >> d >> k;
    for (int i = 0; i < n; i++) scanf("%d%d", &logs[i].first, &logs[i].second);
    sort(logs, logs + n);
    for (int i = 0, j = 0; i < n; ++i) {
        int id = logs[i].second;
        cnt[id]++;
        while (logs[i].first - logs[j].first >= d) {
            cnt[logs[j].second]--;
            ++j;
        }
        if (cnt[id] >= k) st[id] = true;
    }
    for (int i = 0; i < 1e5 + 8; i++) if (st[i]) printf("%d\n", i);
    return 0;
}
```

