# [USACO1.5] [IOI1994]数字三角形 Number Triangles

## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

```cpp
        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5 
```
在上面的样例中,从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大

## 输入格式

第一个行一个正整数 $r$ ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

## 输出格式

单独的一行,包含那个可能得到的最大的和。

## 样例 #1

### 样例输入 #1

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

### 样例输出 #1

```
30
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1



**这一道题是很多教材上的 DP 入门题，思想是就是裸的 DP**

```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1010;
const int INF = 1e9;

int a[N][N];
int f[N][N];
int n;

int main() {
    cin >> n;

    for (int i = 0; i <= n; ++i)
        for (int j = 0; j <= i + 1; j++)
            f[i][j] = -INF;

    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= i; ++j)
            scanf("%d", &a[i][j]);

    f[1][1] = a[1][1];
    for (int i = 2; i <= n; ++i)
        for (int j = 1; j <= i; ++j)
            f[i][j] = max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];

    int res = -INF;
    for (int i = 1; i <= n; ++i) res = max(res, f[n][i]);

    cout << res;

    return 0;
}
```



这种方法是从上往下推导，另外一种是从下往上推导。

从上往下推导到最后，要遍历最后一行所有的值，从中找到最大值，而从下往上推导最后可以直接输出`a[1] [1]`

代码如下：

```c++
#include<bits/stdc++.h>

using namespace std;
long long n, a[1005][1005];

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= i; j++) cin >> a[i][j];
    for (int i = n - 1; i >= 1; i--)
        for (int j = 1; j <= i; j++) a[i][j] += max(a[i + 1][j], a[i + 1][j + 1]);
    cout << a[1][1];
    return 0;
}
```



# [SHOI2002] 滑雪

## 题目描述

Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：
```plain
1   2   3   4   5
16  17  18  19  6
15  24  25  20  7
14  23  22  21  8
13  12  11  10  9
```
一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。

## 输入格式

输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。

## 输出格式

输出区域中最长滑坡的长度。

## 样例 #1

### 样例输入 #1

```
5 5
1 2 3 4 5
16 17 18 19 6
15 24 25 20 7
14 23 22 21 8
13 12 11 10 9
```

### 样例输出 #1

```
25
```

## 提示

对于 $100\%$ 的数据，$1\leq R,C\leq 100$。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110;

int n, m, h[N][N], f[N][N];
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};

int dp(int a, int b) {
    if (f[a][b] != -1) return f[a][b];

    int &v = f[a][b];
    v = 1;
    for (int i = 0; i < 4; ++i) {
        int x = a + dx[i], y = b + dy[i];
        if (x >= 1 && y >= 1 && x <= n && y <= m && h[a][b] > h[x][y]) {
            v = max(v, dp(x, y) + 1);
        }
    }
    return v;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) scanf("%d", &h[i][j]);

    int res = 0;
    memset(f, -1, sizeof f);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            res = max(res, dp(i, j));
        }

    cout << res;
    return 0;
}
```



# [NOIP1996 提高组] 挖地雷

## 题目描述

在一个地图上有$N$个地窖$(N \le 20)$，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。

## 输入格式

有若干行。

第$1$行只有一个数字，表示地窖的个数$N$。

第$2$行有$N$个数，分别表示每个地窖中的地雷个数。

第$3$行至第$N+1$行表示地窖之间的连接情况：

第$3$行有$n-1$个数（$0$或$1$），表示第一个地窖至第$2$个、第$3$个、…、第$n$个地窖有否路径连接。如第$3$行为$1 1 0 0 0 … 0$，则表示第$1$个地窖至第$2$个地窖有路径，至第$3$个地窖有路径，至第$4$个地窖、第$5$个、…、第$n$个地窖没有路径。  

第$4$行有$n-2$个数，表示第二个地窖至第$3$个、第$4$个、…、第$n$个地窖有否路径连接。

… …

第$n+1$行有$1$个数，表示第$n-1$个地窖至第$n$个地窖有否路径连接。（为$0$表示没有路径，为$1$表示有路径）。

## 输出格式

有两行

第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。

第二行只有一个数，表示能挖到的最多地雷数。

## 样例 #1

### 样例输入 #1

```
5
10 8 4 7 6
1 1 1 0
0 0 0
1 1
1
```

### 样例输出 #1

```
1 3 4 5
27
```

## 提示

**【题目来源】**

NOIP 1996 提高组第三题

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 25;
int n, s[N], f[N], d[N];

void dfs(int x) {
    if (d[x] == x) {
        cout << x << " ";
        return;
    }
    dfs(d[x]);
    cout << x << " ";
    return;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> s[i];
    for (int i = 1; i <= n; ++i) d[i] = i;
    memcpy(f, s, sizeof s);
    for (int i = 1; i <= n - 1; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            int a;
            cin >> a;
            if (a == 1) {
                if (f[i] + s[j] > f[j]) {
                    f[j] = f[i] + s[j];
                    d[j] = i;
                }
            }
        }
    }
    int res = 0, id = 0;
    for (int i = 1; i <= n; ++i) if (res < f[i]) res = f[i], id = i;
    dfs(id);
    cout << endl << res << endl;
    return 0;
}
```



# 最大食物链计数

## 题目背景

你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。

## 题目描述

给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是**生物学意义上的食物链**，即**最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者**。）

Delia 非常急，所以你只有 $1$ 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。

## 输入格式

第一行，两个正整数 $n、m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。

接下来 $m$ 行，每行两个正整数，表示被吃的生物A和吃A的生物B。

## 输出格式

一行一个整数，为最大食物链数量模上 $80112002$ 的结果。

## 样例 #1

### 样例输入 #1

```
5 7
1 2
1 3
2 3
3 5
2 5
4 5
3 4
```

### 样例输出 #1

```
5
```

## 提示

各测试点满足以下约定：

 ![](%E5%BA%93/12011-1673269539943-1.png) 

【补充说明】

数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）



注意，本题目要求的是**最大食物链的数量！！！**

也就是说，要求出来每一个顶级消费者所构成的所有食物链之和

**本题可以利用拓扑排序求解**

**本题涉及到的技巧有：**

1. 反转存储整个有向图，让被吃生物指向吃它的生物
2. 利用 rudu 和 chudu 数组来判断是否该将这个点加入到队列中



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 5010;
const int M = 5e5 + 10;
const int mod = 80112002;

int s[N], n, m;// s 数组用来存储每个点所构成的食物链的条数
int h[N], e[M], ne[M], idx;
int rudu[N], chudu[N];// 入度为 0 的点在食物链最底层  出度为 0 的点在食物链顶端

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int main() {
    memset(h, -1, sizeof h);

    scanf("%d%d", &n, &m);

    for (int i = 0; i < m; i++) {
        int a, b;
        scanf("%d%d", &a, &b);
        rudu[b]++;
        chudu[a]++;
        add(a, b);
    }

    queue<int> q;
    for (int i = 1; i <= n; i++)//入度为 0 的点是食物链的最底层，他们自身构成一个食物链
        if (rudu[i] == 0) {
            q.push(i);
            s[i] = 1;
        }

    int ans = 0;
    while (q.size()) {
        int t = q.front();
        q.pop();

        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            s[j] = (s[j] + s[t]) % mod;// 每个点构成的食物链等于他下面所有点所构成的食物链之和
            rudu[j]--;
            if (rudu[j] == 0) {
                if (chudu[j] == 0) ans = (ans + s[j]) % mod;
                else q.push(j);
            }
        }
    }
    cout << ans;
    return 0;
}
```





# [NOIP2005 普及组] 采药

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？

## 输入格式

第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
3
```

## 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题



```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int M = 110, T = 1010;

int v[M], w[M];
int m, t;
int f[T];

int main() {
    cin >> t >> m;

    for (int i = 1; i <= m; ++i) {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= m; ++i)
        for (int j = t; j >= v[i]; --j)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
    // 数据用的上一行，从后往前更新    数据用的这一行，从前往后更新
    cout << f[t];
    return 0;
}
```

非常标准的 0 1 背包问题，也是模板题

**注意一下遍历的顺序**

- 数据用的上一行，从后往前更新
- 数据用的这一行，从前往后更新



**0 1 背包问题是从后向前更新**



# 疯狂的采药

## 题目背景

此题为纪念 LiYuxiang 而生。

## 题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

$1$. 每种草药可以无限制地疯狂采摘。

$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！

## 输入格式

输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。

## 输出格式

输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
140
```

## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $m \le 10^3$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。



```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1e4 + 10;
const int M = 1e7 + 10;

int v[N], w[N];
long long int f[M], n, m;

int main() {

    cin >> m >> n;

    for (int i = 1; i <= n; ++i) cin >> v[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = v[i]; j <= m; j++)
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m];

    return 0;
}
```

**一道考察完全背包的题目**

**完全背包问题是从后向前遍历**





# 5 倍经验日

## 题目背景

现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。

## 题目描述

现在 absi2011 拿出了 $x$ 个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。

由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 $2$ 个药去打别人，别人却表明 $3$ 个药才能打过，那么相当于你输了并且这两个属性药浪费了。

现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。

要求求出最大经验 $s$，输出 $5s$。

## 输入格式

第一行两个数，$n$ 和 $x$。

后面 $n$ 行每行三个数，分别表示失败时获得的经验 $\mathit{lose}_i$，胜利时获得的经验 $\mathit{win}_i$ 和打过要至少使用的药数量 $\mathit{use}_i$。

## 输出格式

一个整数，最多获得的经验的五倍。

## 样例 #1

### 样例输入 #1

```
6 8
21 52 1
21 70 5
21 48 2
14 38 3
14 36 1
14 36 2
```

### 样例输出 #1

```
1060
```

## 提示

**【Hint】**

五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。

**【数据范围】**

- 对于 $10\%$ 的数据，保证 $x=0$。
- 对于 $30\%$ 的数据，保证 $0\le n\le 10$，$0\le x\le 20$。
- 对于 $60\%$ 的数据，保证 $0\le n,x\le 100$， $10<lose_i,win_i\le 100$，$0\le use_i\le 5$。
- 对于 $100\%$ 的数据，保证 $0\le n,x\le 10^3$，$0<lose_i\le win_i\le 10^6$，$0\le use_i\le 10^3$。

**【题目来源】**

fight.pet.qq.com

absi2011 授权题目



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e3 + 10;

int n, x;

int jingyan[N];
int lose[N], win[N], s[N];

int main() {
    cin >> n >> x;

    for (int i = 1; i <= n; i++) cin >> lose[i] >> win[i] >> s[i];

    for (int i = 1; i <= n; i++) {
        for (int j = x; j >= s[i]; --j)
            jingyan[j] = max(jingyan[j] + lose[i], jingyan[j - s[i]] + win[i]);
        for (int j = s[i] - 1; j >= 0; --j)
            jingyan[j] += lose[i];
    }


    printf("%lld", 5ll * jingyan[x]);

    return 0;
}
```

**一个变形版的 0 1 背包**，只是需要注意不用药打的人也要算在重量内

![image-20230109213937397](%E5%BA%93/image-20230109213937397.png)





# [NOIP2002 普及组] 过河卒

## 题目描述

棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。

棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。

![](%E5%BA%93/vg6k477j.png)

现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。

## 输入格式

一行四个正整数，分别表示 $B$ 点坐标和马的坐标。

## 输出格式

一个整数，表示所有的路径条数。

## 样例 #1

### 样例输入 #1

```
6 6 3 3
```

### 样例输出 #1

```
6
```

## 提示

对于 $100 \%$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。

**【题目来源】**

NOIP 2002 普及组第四题



```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 24;

bool st[N][N];
LL f[N];
int n, m;

void del(int a, int b) {
    st[a][b] = true;
    int dx[8] = {-2, -1, 1, 2, -2, -1, 1, 2};
    int dy[8] = {1, 2, 2, 1, -1, -2, -2, -1};

    for (int i = 0; i < 8; ++i) {
        int x = a + dx[i], y = b + dy[i];
        if (x < 0 || y < 0 || x > n || y > m) continue;
        st[x][y] = true;
    }
}

int main() {
    cin >> n >> m;

    int x, y;
    cin >> x >> y;
    del(x, y);


    f[0] = 1;
    for (int i = 0; i <= n; ++i) {
        for (int j = 0; j <= m; ++j) {
            if (i == 0 && j == 0) {
                //cout<<f[j]<<" ";
                continue;
            }
            if (st[i][j]) {
                f[j] = 0;
                //cout<<f[j]<<" ";
                continue;
            }
            if (i == 0) {
                f[j] = f[j - 1];
                //cout<<f[j]<<" ";
                continue;
            }
            if (j == 0) {
                f[j] = f[j];
                //cout<<f[j]<<" ";
                continue;
            }
            f[j] = f[j] + f[j - 1];
            //cout<<f[j]<<" ";
        }
        //cout<<endl;
    }
    cout << f[m];
    return 0;
}
```

这道题初始位置是从 0 开始的，这样不是很利于我们解题，所以不如暂且把这题里涉及的坐标统统 +1  （虽然我的代码里面并没有这么写）

在此题的数据范围中，最大的答案137846521561 ，因此要用 long long 来存储