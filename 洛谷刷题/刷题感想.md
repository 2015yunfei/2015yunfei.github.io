# n个元素进栈，共有多少种出栈顺序

https://blog.csdn.net/qq_22238021/article/details/80903507

![image-20221208184639491](%E5%BA%93/image-20221208184639491.png)

其中 f(0) = 1



## 排序函数

> https://blog.csdn.net/wordwarwordwar/article/details/40976681



## 使用memset初始化int数组

memset()是一个来自于string库的函数，正规用法是初始化char类型的数组。因为char类型只占1个字节，memset**按字节赋值**后，会将char类型数组的所有元素变为你指定的值。但是4字节的int类型在被memset赋值后，会被重复四次：如使用memset赋值1到int数组后，1转为二进制的一个字节为00000001，赋值完成后为00000001000000010000000100000001，即十进制的16843009。因此**不能直接对int数组memset赋值目标值**。也因此，将数组**赋值为0可以正常使用**。

还有一个应用是，对一个int数组使用memset( , 0xff, sizeof());时,赋值完成后每个元素为11111111111111111111111111111111，即-1。

除了赋值0或-1外，有时也需要将数组初始化为极大值。下面是几个常用的赋值。

```cpp
memset(arr, 0x7f, sizeof(arr)); //set int to 2139062143
memset(arr, 0x80, sizeof(arr)); //set int to -2139062144
memset(arr, 0x7f, sizeof(arr)); //set double to 1.38242e+306
memset(arr, 0xfe, sizeof(arr)); //set double to -5.31401e+303
```

注意，由于上面的赋值接近了数据类型的上限，在**极大值相加**（如最短路算法有时会出现）**时会出现溢出**。

这里推荐一个比较合适的常量：0x3f3f3f3f，转换为十进制仍达到1061109567，为109级别，正常情况下不会小于正常常数值。而0x3f3f3f3f * 2 = 2122219134‬，仍没有超过int类型的上限232。而且，由于0x3f3f3f3f的每个字节均相同，在memset时直接使用

```c++
memset(arr, 0x3f, sizeof(arr));
```

即可完成最短路算法中常用的极大值初始化。

> https://www.cnblogs.com/xxu-mzwyt/p/11461574.html

## 负数取模

> https://blog.csdn.net/tracydragonlxy/article/details/101352289



# 【数据结构1-1】线性表

## P1160 队列安排

遇到了 vector 容器迭代器  .end() 无效的问题

错误的代码：

```c++
#include <vector>
#include <iostream>
using namespace std;
int main()
{
	vector<int> v;
	int n, k, p, i = 1;
	//队伍中的同学数目
	cin >> n;
	v.push_back(i++);
	vector<int>::iterator pos = v.begin();
	while (--n) {
		cin >> k >> p;
		while (*pos != k) {
			pos++;
		}
		if (p == 1) {
			pos++;
		}
		v.insert(pos, i++);
		pos = v.begin();
	}
	//去掉同学的数目
	cin >> n;
	while (n--) {
		cin >> k;
		for (; *pos != k && pos != v.end(); pos++);
        //在pos==v.end()之后，*pos非法
        //可以通过更改条件判断的顺序来避免这个问题
        //例如：  for (; pos != v.end() && *pos != k; pos++);
        //即便如此，码风也不好，推荐迭代器开在循环内部
        
        
		//没找到元素，或者已经删除，归零迭代器
		if (pos == v.end()) {
			pos = v.begin();
		}
		//找到则删除，并归零迭代器
		else {
			v.erase(pos);
			pos = v.begin();
		}
	}
	for (; pos != v.end() - 1; pos++) {
		printf("%d ", *pos);
	}
	printf("%d\n", *pos);
	return 0;
}
```

在洛谷上改正后的代码，虽然通过了，但是代码不规范，思路不好：

```c++
#include <vector>
#include <iostream>
using namespace std;
int main()
{
	vector<int> v;
	int n, k, p, i = 1;
	//队伍中的同学数目
	cin >> n;
	v.push_back(i++);
	vector<int>::iterator pos = v.begin();
	while (--n) {
		cin >> k >> p;
		while (*pos != k) {
			pos++;
		}
		if (p == 1) {
			pos++;
		}
		v.insert(pos, i++);
		pos = v.begin();
	}
	//去掉同学的数目
	cin >> n;
	while (n--) {
		cin >> k;
		for (; *pos != k && pos != v.end() - 1; pos++);
		//没找到元素，或者已经删除，归零迭代器
		if (*pos == k) {
			v.erase(pos);
			pos = v.begin();
		}
		//找到则删除，并归零迭代器
		else {
			pos = v.begin();
		}
	}
	for (; pos != v.end() - 1; pos++) {
		printf("%d ", *pos);
	}
	printf("%d\n", *pos);
	return 0;
}
```

正确的代码：

```c++
#include <vector>
#include <iostream>
using namespace std;
int main()
{
	vector<int> v;
	int n, k, p, i = 1;
	//队伍中的同学数目
	cin >> n;
	v.push_back(i++);
	vector<int>::iterator pos = v.begin();
	while (--n) {
		cin >> k >> p;
		while (*pos != k) {
			pos++;
		}
		if (p == 1) {
			pos++;
		}
		v.insert(pos, i++);
		pos = v.begin();
	}
	//去掉同学的数目
	cin >> n;
	while (n--) {
		cin >> k;
		for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
			if (*it == k) {
				v.erase(it);
				break;
			}
		}
	}
	for (; pos != v.end() - 1; pos++) {
		printf("%d ", *pos);
	}
	printf("%d\n", *pos);
	return 0;
}
```

经验总结：

通过该题明白了 vector 的迭代器的注意事项，也就是坑爹的地方。

测试代码：

```c++
#include <vector>
#include <iostream>
using namespace std;
int main() {
	vector<int>v;
	v.push_back(4);
	vector<int>::iterator it = v.end();
	printf("%d", *it);				//报错
	printf("%d", it == v.end());	//输出 1
	return 0;
}
```

vector 容器的方法 .end() 返回的是无效的迭代器，虽然可以作为判断的条件，不能再去解地址，例如这样：

```c++
cin >> k;
	for (; *pos != k && pos != v.end(); pos++);//在pos==v.end()之后，*pos非法
	//没找到元素，或者已经删除，归零迭代器
	if (pos == v.end()) {
		pos = v.begin();
	}
	//找到则删除，并归零迭代器
	else {
		v.erase(pos);
		pos = v.begin();
```

不要在循环外部建立容器的迭代器，迭代器直接开在循环内部即可。

循环到最后并没有把 .end() 赋值给迭代器，只是做了比较，比较完成之后循环直接结束。不会再次利用已经到容器尾部的迭代器。

一个码风良好的利用迭代器循环的代码应该如下：

```c++
		for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
			if (*it == k) {
				v.erase(it);
				break;
			}
```

若要删除容器中的所有 值为k的元素，只需要删除 break; 语句。

本题目使用 vector 容器存在的问题：数据量较大时多次遍历TLE

<u>**所以使用链表或者数组解题。**</u>

C++标准库自带了std::list这个双向链表的模板类，使用时需要包含头文件：#include <list>。

```cpp
list<int> myList;
```

这句代码声明了一个list<int>类型的变量，也就是一个包含int类型元素的双向链表。尖括号里边的部分称为**模板参数**，对于list而言，它表示链表里的元素是什么类型。

```cpp
myList.push_front(1);
myList.push_back(2);
```

顾名思义，这两个成员函数分别用于在链表的头部和尾部插入元素。对应地，pop_front()用于移除头部的元素，pop_back()用于移除尾部的元素。

```cpp
typedef list<int>::iterator Iter;
Iter itBegin = myList.begin();
Iter itEnd = myList.end();
for (; itBegin != itEnd; ++itBegin)
	printf(" %d", *itBegin);
```

这段代码演示的是list提供的，用于访问内部元素的**迭代器**。迭代器的类型是list<Tp>::iterator（这里模板参数Tp需要与你操作的链表一致）。

迭代器的用法和指针有些像，可以用*运算符访问内部的元素，++和--运算符可以将它后移或前移一位（建议写成前置形式），用==和!=运算符进判断两个迭代器所指的位置是否一致。

<u>但要注意：list的迭代器不支持it += x或it1 - it2这样的运算，也不支持<，<=等运算符。</u>

begin()成员函数返回指向头部元素的迭代器。

end()成员函数返回指向末尾位置的迭代器。这个“末尾位置”指的是最后一个元素**再往后一位**，<u>也就是说end()所指的位置不包含有效元素，它相当于一个虚设的节点。这样设计是为了满足C++标准库表示区间时左闭右开的惯例。</u>

```cpp
//接上例
myList.remove(it);
//myList的内容：1,3
int x = *it + 10; //ERROR!
```

<u>remove(it)成员函数用于删除某个迭代器所指的节点。注意在删除之后it就失效了，除非给it重新赋值，否则对它的任何操作都会导致错误！</u>

解题代码：

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;
struct node{
    int L, R;
}a[100003];
int n, m;
inline void addRight(int x, int pos) { //插入右边 
    a[x].L = pos;
    a[a[pos].R].L = x;
    a[x].R = a[pos].R;
    a[pos].R = x;
}
inline void addLeft(int x, int pos) { //插入左边
    a[x].R = pos;
    a[a[pos].L].R = x;
    a[x].L = a[pos].L;
    a[pos].L = x;
}
inline void del(int x) {
    if(a[x].L == -1) return;
    a[a[x].L].R = a[x].R;
    a[a[x].R].L = a[x].L;
    a[x].L = -1;
    a[x].R = -1; 
}
inline void go() {
    int x = a[0].R;
    while(1) {
        cout<<x<<" ";
        if(a[x].R == -1) break;
        x = a[x].R;
    }
}
inline void init() {
    for(int i = 1; i <= n; ++i) a[i].L = a[i].R = -1;
    a[1].R = -1; a[1].L = 0; a[0].R = 1;
}
int main() {
    scanf("%d", &n);
    int cmd1, cmd2;
    init();
    for(int i = 2; i <= n; ++i) {
        scanf("%d %d", &cmd1, &cmd2);
        if(!cmd2) addLeft(i, cmd1);
        else addRight(i, cmd1);
    }
    scanf("%d", &m);
    for(int i = 1; i <= m; ++i) {
        scanf("%d", &cmd1);
        del(cmd1);
    }
    go();
    return 0;
}
```

虽然输出的时候 int l 没有作用， 但是在添加元素的时候， int l 相当于左指针，整体相当于一个双向链表，方便寻找左侧元素，不可以去掉。否则又要来回遍历数组。

> inline是C++关键字，在函数声明或定义中，函数返回类型前加上关键字inline，即可以把函数指定为内联函数。这样可以解决一些频繁调用的函数大量消耗栈空间（栈内存）的问题。关键字inline必须与函数定义放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面不起任何作用。inline是一种“用于实现”的关键字，而不是一种“用于声明”的关键字。

引入 inline 的主要原因是用它替代C中表达式形式的宏定义。

表达式形式的宏定义如：

\#define ExpressionName(Var1,Var2) ((Var1)+(Var2))*((Var1)-(Var2))

取代这种形式的原因如下：

1．C中使用define这种形式宏定义的原因是因为C语言是一个效率很高的语言，这种宏定义在形式及使用上像一个函数，但它使用[预处理器](https://baike.baidu.com/item/预处理器?fromModule=lemma_inlink)实现，没有了参数压栈**，代码生成等一系列的操作。因此，效率很高，这是它在C中被使用的一个主要原因。

2．这种[宏定义](https://baike.baidu.com/item/宏定义?fromModule=lemma_inlink)在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器[符号表](https://baike.baidu.com/item/符号表?fromModule=lemma_inlink)中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++[编译器](https://baike.baidu.com/item/编译器?fromModule=lemma_inlink)严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型。这样，它的使用就存在着一系列的隐患和局限性。

3．在C++中引入了类及类的访问控制，这样，如果一个操作或者说一个[表达式](https://baike.baidu.com/item/表达式?fromModule=lemma_inlink)涉及到类的保护成员或私有成员，你就不可能使用这种宏定义来实现（因为无法将this[指针](https://baike.baidu.com/item/指针?fromModule=lemma_inlink)放在合适的位置）。

4．inline推出的目的，也正是为了取代这种表达式形式的[宏定义](https://baike.baidu.com/item/宏定义?fromModule=lemma_inlink)，它消除了宏定义的缺点，同时又很好地继承了宏定义的优点。

预定义

对应于上面的1-3点，阐述如下：

1．inline定义的类的[内联函数](https://baike.baidu.com/item/内联函数?fromModule=lemma_inlink)，函数的代码被放入[符号表](https://baike.baidu.com/item/符号表?fromModule=lemma_inlink)中，在使用时直接进行替换（像宏一样展开），没有了调用的开销，效率也很高。

2．很明显，类的内联函数也是一个真正的函数，[编译器](https://baike.baidu.com/item/编译器?fromModule=lemma_inlink)在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。

3．inline可以作为某个[类的成员函数](https://baike.baidu.com/item/类的成员函数?fromModule=lemma_inlink)，当然就可以在其中使用所在类的保护成员及私有成员。

在何时使用inline函数：

首先，你可以使用inline函数完全取代[表达式](https://baike.baidu.com/item/表达式?fromModule=lemma_inlink)形式的宏定义。

另外要注意，[内联函数](https://baike.baidu.com/item/内联函数?fromModule=lemma_inlink)一般只会用在函数内容非常简单的时候。这是因为，内联函数的代码会在任何调用它的地方展开，如果函数太复杂，代码膨胀带来的恶果很可能会大于效率的提高带来的益处。内联函数最重要的使用地方是用于类的存取函数。

> vs 解决 scanf 不安全的问题，将cpp文件的属性中，“C/C++”"常规""SDL检查"关闭即可。
>
> https://www.jb51.net/article/209480.htm

## P1241 括号序列

我的答案：

```c++
#include <iostream>
#include <vector>
#include <stack>
using namespace std;

int main()
{
	string ch;
	cin >> ch;
	vector<char> v;
	stack<char> s;
	s.push('@');// 避免当栈为空的时候，访问栈顶出错
	v.push_back('@');
	for (int i = 0; i < ch.length(); i++) {
		switch (ch[i])
		{
		case '(':s.push(ch[i]); v.push_back(ch[i]); break;
		case '[':s.push(ch[i]); v.push_back(ch[i]); break;
		case ')':
			if (s.top() == '(') {
				s.pop();
				v.push_back(ch[i]);
			}
			else {
				v.push_back('(');
				v.push_back(ch[i]);
			}
			break;
		case ']':
			if (s.top() == '[') {
				s.pop();
				v.push_back(ch[i]);
			}
			else {
				v.push_back('[');
				v.push_back(ch[i]);
			}
			break;
		default:
			break;
		}
	}
	while (s.size() != 1) {
		if (s.top() == '(') {
			v.push_back(')');
		}
		else {
			v.push_back(']');
		}
		s.pop();
	}
	for (vector<char>::iterator it = v.begin() + 1; it != v.end(); it++) {
		cout << *it;
	}
	return 0;
}
```

> 对于测试用例  ([) 的输出结果是 ([()])
>
> 大佬题解对于该测试用例的输出结果是  ()[]()
>
> 另一个测试用例 ([) 的输出结果是 ([()]) 这显然说明了我的算法有问题
>
> （[)  的输出结果应该是 ([])

~~改进方法：~~

~~既然开一个栈来存放左括号不够，那就开两个栈，分别存放两种左括号。~~

~~代码实现：~~
