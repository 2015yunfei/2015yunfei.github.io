# 租用游艇

## 题目描述

长江游艇俱乐部在长江上设置了 $n$ 个游艇出租站 $1,2,\cdots,n$。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 $i$ 到游艇出租站 $j$ 之间的租金为 $r(i,j)$（$1\le i\lt j\le n$）。试设计一个算法，计算出从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

## 输入格式

第一行中有一个正整数 $n$，表示有 $n$ 个游艇出租站。接下来的 $n-1$ 行是一个半矩阵 $r(i,j)$（$1\le i<j\le n$）。

## 输出格式

输出计算出的从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

## 样例 #1

### 样例输入 #1

```
3
5 15
7
```

### 样例输出 #1

```
12
```

## 提示

$n\le 200$，保证计算过程中任何时刻数值都不超过 $10^6$。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 210;
int n, w[N][N], h[N];

int main() {
    cin >> n;
    for (int i = 1; i < n; ++i) {
        for (int j = i + 1; j <= n; j++)
            cin >> w[i][j];
    }

    for (int i = 2; i <= n; ++i) {
        h[i] = 1e9;
        for (int j = 1; j < i; ++j) {
            h[i] = min(h[i], h[j] + w[j][i]);
        }
    }
    cout << h[n];
    return 0;
} 
```



# [NOIP2006 普及组] 开心的金明

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过$N$元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的$N$元。于是，他把每件物品规定了一个重要度，分为$5$等：用整数$1-5$表示，第$5$等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过$N$元（可以等于$N$元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为$v[j]$，重要度为$w[j]$，共选中了$k$件物品，编号依次为$j_1,j_2,…,j_k$，则所求的总和为：

$v[j_1] \times w[j_1]+v[j_2] \times w[j_2]+ …+v[j_k] \times w[j_k]$。

请你帮助金明设计一个满足要求的购物单。

## 输入格式

第一行，为$2$个正整数，用一个空格隔开：$n,m$（其中$N(<30000)$表示总钱数，$m(<25)$为希望购买物品的个数。）

从第$2$行到第$m+1$行，第$j$行给出了编号为$j-1$的物品的基本数据，每行有$2$个非负整数$ v p$（其中$v$表示该物品的价格$(v \le 10000)$，$p$表示该物品的重要度($1-5$)

## 输出格式

$1$个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值$(<100000000)$。

## 样例 #1

### 样例输入 #1

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 样例输出 #1

```
3900
```

## 提示

NOIP 2006 普及组 第二题

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 30, M = 30010;
int n, m, w[N], v[N];
int f[M];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) cin >> v[i] >> w[i];

    for (int i = 1; i <= m; ++i)
        for (int j = n; j >= v[i]; --j) {
            f[j] = max(f[j], f[j - v[i]] + v[i] * w[i]);
        }

    cout << f[n];
    return 0;
}
```



# 5 倍经验日

## 题目背景

现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。

## 题目描述

现在 absi2011 拿出了 $x$ 个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。

由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 $2$ 个药去打别人，别人却表明 $3$ 个药才能打过，那么相当于你输了并且这两个属性药浪费了。

现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。

要求求出最大经验 $s$，输出 $5s$。

## 输入格式

第一行两个数，$n$ 和 $x$。

后面 $n$ 行每行三个数，分别表示失败时获得的经验 $\mathit{lose}_i$，胜利时获得的经验 $\mathit{win}_i$ 和打过要至少使用的药数量 $\mathit{use}_i$。

## 输出格式

一个整数，最多获得的经验的五倍。

## 样例 #1

### 样例输入 #1

```
6 8
21 52 1
21 70 5
21 48 2
14 38 3
14 36 1
14 36 2
```

### 样例输出 #1

```
1060
```

## 提示

**【Hint】**

五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。

**【数据范围】**

- 对于 $10\%$ 的数据，保证 $x=0$。
- 对于 $30\%$ 的数据，保证 $0\le n\le 10$，$0\le x\le 20$。
- 对于 $60\%$ 的数据，保证 $0\le n,x\le 100$， $10<lose_i,win_i\le 100$，$0\le use_i\le 5$。
- 对于 $100\%$ 的数据，保证 $0\le n,x\le 10^3$，$0<lose_i\le win_i\le 10^6$，$0\le use_i\le 10^3$。

**【题目来源】**

fight.pet.qq.com

absi2011 授权题目

```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 1e3 + 10;

int n, x;

int jingyan[N];
int lose[N], win[N], s[N];

int main() {
    cin >> n >> x;

    for (int i = 1; i <= n; i++) cin >> lose[i] >> win[i] >> s[i];

    for (int i = 1; i <= n; i++) {
        for (int j = x; j >= s[i]; --j)
            jingyan[j] = max(jingyan[j] + lose[i], jingyan[j - s[i]] + win[i]);
        for (int j = s[i] - 1; j >= 0; --j)
            jingyan[j] += lose[i];
    }


    printf("%lld", 5ll * jingyan[x]);

    return 0;
}
```



# [NOIP2001 普及组] 装箱问题

## 题目描述

有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。


现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

## 输入格式

第一行共一个整数 $V$，表示箱子容量。

第二行共一个整数 $n$，表示物品总数。

接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。

## 输出格式

- 共一行一个整数，表示箱子最小剩余空间。

## 样例 #1

### 样例输入 #1

```
24
6
8
3
12
7
9
7
```

### 样例输出 #1

```
0
```

## 提示

对于 $100\%$ 数据，满足 $0<n \le 30$，$1 \le V \le 20000$。

**【题目来源】**

NOIP 2001 普及组第四题

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 35, M = 20010;
int f[M], n, m, v[N];

int main() {
    cin >> m >> n;
    for (int i = 1; i <= n; ++i) cin >> v[i];

    for (int i = 1; i <= n; ++i)
        for (int j = m; j >= v[i]; --j) f[j] = max(f[j], f[j - v[i]] + v[i]);

    cout << m - f[m];
    return 0;
}
```



# [NOIP2005 普及组] 采药

## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？

## 输入格式

第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

## 样例 #1

### 样例输入 #1

```
70 3
71 100
69 1
1 2
```

### 样例输出 #1

```
3
```

## 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题

```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int M = 110, T = 1010;

int v[M], w[M];
int m, t;
int f[T];

int main() {
    cin >> t >> m;

    for (int i = 1; i <= m; ++i) {
        cin >> v[i] >> w[i];
    }

    for (int i = 1; i <= m; ++i)
        for (int j = t; j >= v[i]; --j)
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[t];
    return 0;
}
```



# 通天之分组背包

## 题目背景

直达通天路·小 A 历险记第二篇

## 题目描述

自 $01$ 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 $01$ 背包，他的物品大致可分为 $k$ 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。

## 输入格式

两个数 $m,n$，表示一共有 $n$ 件物品，总重量为 $m$。

接下来 $n$ 行，每行 $3$ 个数 $a_i,b_i,c_i$，表示物品的重量，利用价值，所属组数。

## 输出格式

一个数，最大的利用价值。

## 样例 #1

### 样例输入 #1

```
45 3
10 10 1
10 5 1
50 400 2
```

### 样例输出 #1

```
10
```

## 提示

$1 \leq m, n \leq 1000$，$1\leq k\leq 100$，$a_i, b_i, c_i$ 在 `int` 范围内。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1010, M = 110;
int n, m, w[M][N], v[M][N], s[M];
int f[N];

int main() {
    cin >> m >> n;
    int cnt = 0;
    for (int i = 0; i < n; ++i) {
        int a, b, c;
        cin >> a >> b >> c;
        s[c]++;
        w[c][s[c]] = b;
        v[c][s[c]] = a;
        cnt = cnt > c ? cnt : c;
    }

    for (int i = 1; i <= cnt; ++i) {
        for (int j = m; j >= 0; --j)
            for (int k = 1; k <= s[i]; ++k)
                if (j - v[i][k] >= 0) f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
    }
    cout << f[m];
    return 0;
}
```



# A+B Problem（再升级）

## 题目背景

题目名称是吸引你点进来的。

实际上该题还是很水的。

## 题目描述

- $1+1=?$ 显然是 $2$。
- $a+b=?$ P1001 回看不谢。
- 哥德巴赫猜想 似乎已呈泛滥趋势。

_以上纯属个人吐槽_

给定一个正整数 $n$，求将其分解成若干个素数之和的方案总数。

## 输入格式

一行一个正整数 $n$。

## 输出格式

一行一个整数表示方案总数。

## 样例 #1

### 样例输入 #1

```
7
```

### 样例输出 #1

```
3
```

## 样例 #2

### 样例输入 #2

```
20
```

### 样例输出 #2

```
26
```

## 提示

### 样例解释

存在如下三种方案：

- $7=7$。
- $7=2+5$。
- $7=2+2+3$。

### 数据范围及约定

- 对于 $30\%$ 的数据 $1\le n\le 10$。
- 对于 $100\%$ 的数据，$1\le n\le 10^3$。

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1010;
int n, cnt, v[N];
long long int f[N];

bool check(int x) {
    for (int i = 2; i * i <= x; ++i)
        if (x % i == 0) return false;
    return true;
}

int main() {
    cin >> n;

    for (int i = 2; i <= n; i++)
        if (check(i)) v[++cnt] = i;

    f[0] = 1;
    for (int i = 1; i <= cnt; ++i)
        for (int j = v[i]; j <= n; ++j)
            f[j] += f[j - v[i]];
    cout << f[n];
    return 0;
}
```



# NASA的食物计划

## 题目背景

NASA（美国航空航天局）因为航天飞机的隔热瓦等其他安全技术问题一直大伤脑筋，因此在各方压力下终止了航天飞机的历史，但是此类事情会不会在以后发生，谁也无法保证。所以，在遇到这类航天问题时，也许只能让航天员出仓维修。但是过多的维修会消耗航天员大量的能量，因此 NASA 便想设计一种食品方案，使体积和承重有限的条件下多装载一些高卡路里的食物。

## 题目描述

航天飞机的体积有限，当然如果载过重的物品，燃料会浪费很多钱，每件食品都有各自的体积、质量以及所含卡路里。在告诉你体积和质量的最大值的情况下，请输出能达到的食品方案所含卡路里的最大值，当然每个食品只能使用一次。

## 输入格式

第一行 $2$ 个整数，分别代表体积最大值 $h$ 和质量最大值 $t$。 

第二行 $1$ 个整数代表食品总数 $n$。 

接下来 $n$ 行每行 $3$ 个数 体积 $h_i$，质量 $t_i$，所含卡路里 $k_i$。

## 输出格式

一个数，表示所能达到的最大卡路里（`int` 范围内）

## 样例 #1

### 样例输入 #1

```
320 350
4
160 40 120
80 110 240
220 70 310
40 400 220
```

### 样例输出 #1

```
550
```

## 提示

对于 $100\%$ 的数据，$h,t,h_i,t_i \le 400$，$n \le 50$，$k_i \le 500$。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 60, M = 410;

int v[N], w[N], n, h, t, m[N];
int f[M][M];

int main() {
    cin >> h >> t;
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> v[i] >> m[i] >> w[i];

    for (int i = 1; i <= n; i++)
        for (int j = h; j >= v[i]; --j) {
            for (int k = t; k >= m[i]; --k)
                f[j][k] = max(f[j][k], f[j - v[i]][k - m[i]] + w[i]);
        }

    cout << f[h][t];
    return 0;
}
```



# [NOIP2012 普及组] 摆花

## 题目描述

小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。

试编程计算，一共有多少种不同的摆花方案。

## 输入格式

第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。

第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。

## 输出格式

一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。

## 样例 #1

### 样例输入 #1

```
2 4
3 2
```

### 样例输出 #1

```
2
```

## 提示

【数据范围】

对于 $20\%$ 数据，有 $0<n \le 8,0<m \le 8,0 \le a_i \le 8$。

对于 $50\%$ 数据，有 $0<n \le 20,0<m \le 20,0 \le a_i \le 20$。

对于 $100\%$ 数据，有 $0<n \le 100,0<m \le 100,0 \le a_i \le 100$。

NOIP 2012 普及组 第三题

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 110, mod = 1e6 + 7;
int n, m, f[N][N], s[N];

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> s[i];

    f[0][0] = 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 0; j <= m; ++j)
            for (int k = 0; k <= min(s[i], j); ++k)
                f[i][j] = (f[i][j] + f[i - 1][j - k]) % mod;

    cout << f[n][m];
    return 0;
}
```

