# 【深基15.例1】询问学号

## 题目描述

有 $n(n \le 2 \times 10^6)$ 名同学陆陆续续进入教室。我们知道每名同学的学号（在 $1$ 到 $10^9$ 之间），按进教室的顺序给出。上课了，老师想知道第 $i$ 个进入教室的同学的学号是什么（最先进入教室的同学 $i=1$），询问次数不超过 $10^5$ 次。

## 输入格式

第一行 $2$ 个整数 $n$ 和 $m$，表示学生个数和询问次数。

第二行 $n$ 个整数，表示按顺序进入教室的学号。

第三行 $m$ 个整数，表示询问第几个进入教室的同学。

## 输出格式

输出 $m$ 个整数表示答案，用换行隔开。

## 样例 #1

### 样例输入 #1

```
10 3
1 9 2 60 8 17 11 4 5 14
1 5 9
```

### 样例输出 #1

```
1
8
5
```

```c++
#include <iostream>

using namespace std;
long long a[2000001];

int main() {
    long long n, m, x;
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= m; ++i) {
        cin >> x;
        cout << a[x] << endl;//输出a[x]
    }
    return 0;
}
```



# 【深基15.例2】寄包柜

## 题目描述

超市里有 $n(1\le n\le10^5)$ 个寄包柜。每个寄包柜格子数量不一，第 $i$ 个寄包柜有 $a_i(1\le a_i\le10^5)$ 个格子，不过我们并不知道各个 $a_i$ 的值。对于每个寄包柜，格子编号从 1 开始，一直到 $a_i$。现在有 $q(1 \le q\le10^5)$ 次操作：

- `1 i j k`：在第 $i$ 个柜子的第 $j$ 个格子存入物品 $k(0\le k\le 10^9)$。当 $k=0$ 时说明清空该格子。
- `2 i j`：查询第 $i$ 个柜子的第 $j$ 个格子中的物品是什么，保证查询的柜子有存过东西。

已知超市里共计不会超过 $10^7$ 个寄包格子，$a_i$ 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。

## 输入格式

第一行 2 个整数 $n$ 和 $q$，寄包柜个数和询问次数。

接下来 $q$ 个整数，表示一次操作。

## 输出格式

对于查询操作时，输出答案，以换行隔开。

## 样例 #1

### 样例输入 #1

```
5 4
1 3 10000 118014
1 1 1 1
2 3 10000
2 1 1
```

### 样例输出 #1

```
118014
1
```

## 提示

$\text{upd 2022.7.26}$：新增加一组 Hack 数据。

```c++
#include <iostream>
#include <map>

using namespace std;

int main() {
    map<pair<int, int>, int> temp_map;
    int n, q, temp;
    int i, j;
    long long k;
    cin >> n >> q;
    while (q--) {
        cin >> temp;
        if (temp == 1) {
            cin >> i >> j >> k;
            if (k == 0) {
                temp_map.erase(make_pair(i, j));
                continue;
            }
            temp_map[make_pair(i, j)] = k;
        } else {
            cin >> i >> j;
            map<pair<int, int>, int>::iterator pos = temp_map.find(make_pair(i, j));
            printf("%ld\n", pos->second);
        }
    }
    return 0;
}
```



# 后缀表达式

## 题目描述

所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。

如：$\texttt{3*(5-2)+7}$ 对应的后缀表达式为：$\texttt{3.5.2.-*7.+@}$。在该式中，`@` 为表达式的结束符号。`.` 为操作数的结束符号。

## 输入格式

输入一行一个字符串 $s$，表示后缀表达式。

## 输出格式

输出一个整数，表示表达式的值。

## 样例 #1

### 样例输入 #1

```
3.5.2.-*7.+@
```

### 样例输出 #1

```
16
```

## 提示

数据保证，$1 \leq |s| \leq 50$，答案和计算过程中的每一个值的绝对值不超过 $10^9$。

```c++
#include <iostream>
#include<stack>

using namespace std;

int main() {
    char ch;
    int num = 0;
    int a, b;
    stack<int> temp;
    ch = getchar();
    while (ch != '@') {
        switch (ch) {
            case '.':
                temp.push(num);
                num = 0;
                break;
            case '+':
                a = temp.top();
                temp.pop();
                b = temp.top();
                temp.pop();
                temp.push(a + b);
                break;
            case '-':
                a = temp.top();
                temp.pop();
                b = temp.top();
                temp.pop();
                temp.push(b - a);
                break;
            case '*':
                a = temp.top();
                temp.pop();
                b = temp.top();
                temp.pop();
                temp.push(a * b);
                break;
            case '/':
                a = temp.top();
                temp.pop();
                b = temp.top();
                temp.pop();
                temp.push(b / a);
                break;
            default:
                num = num * 10 + ch - '0';
                break;
        }
        ch = getchar();
    }
    cout << temp.top();
    return 0;
}
```



# 约瑟夫问题

## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**

## 输入格式

输入两个整数 $n,m$。

## 输出格式

输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。

## 样例 #1

### 样例输入 #1

```
10 3
```

### 样例输出 #1

```
3 6 9 2 7 1 8 5 10 4
```

## 提示

$1 \le m, n \le 100$

```c++
#include <iostream>
#include <queue>

using namespace std;

int main() {
    int n, m, i = 1;
    cin >> n >> m;
    queue<int> temp;
    for (; i <= n; ++i) temp.push(i);
    i = 1;
    while (temp.size() != 1) {
        if (i == m) {
            printf("%d ", temp.front());
            temp.pop();
            i = 1;
            continue;
        }
        i++;
        temp.push(temp.front());
        temp.pop();
    }
    printf("%d", temp.front());
    return 0;
}
```



# 队列安排

## 题目描述

一个学校里老师要将班上 $N$ 个同学排成一列，同学被编号为 $1\sim N$，他采取如下的方法：

1. 先将 $1$ 号同学安排进队列，这时队列中只有他一个人；

2. $2\sim N$ 号同学依次入列，编号为 $i$ 的同学入列方式为：老师指定编号为 $i$ 的同学站在编号为 $1\sim(i-1)$ 中某位同学（即之前已经入列的同学）的左边或右边；

3. 从队列中去掉 $M$ 个同学，其他同学位置顺序不变。

在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。

## 输入格式

第一行一个整数 $N$，表示了有 $N$ 个同学。

第 $2\sim N$ 行，第 $i$ 行包含两个整数 $k,p$，其中 $k$ 为小于 $i$ 的正整数，$p$ 为 $0$ 或者 $1$。若 $p$ 为 $0$，则表示将 $i$ 号同学插入到 $k$ 号同学的左边，$p$ 为 $1$ 则表示插入到右边。

第 $N+1$ 行为一个整数 $M$，表示去掉的同学数目。

接下来 $M$ 行，每行一个正整数 $x$，表示将 $x$ 号同学从队列中移去，如果 $x$ 号同学已经不在队列中则忽略这一条指令。

## 输出格式

一行，包含最多 $N$ 个空格隔开的整数，表示了队列从左到右所有同学的编号。

## 样例 #1

### 样例输入 #1

```
4
1 0
2 1
1 0
2
3
3
```

### 样例输出 #1

```
2 4 1
```

## 提示

**【样例解释】**

将同学 $2$ 插入至同学 $1$ 左边，此时队列为：

`2 1`

将同学 $3$ 插入至同学 $2$ 右边，此时队列为：

`2 3 1`  

将同学 $4$ 插入至同学 $1$ 左边，此时队列为：

`2 3 4 1`  

将同学 $3$ 从队列中移出，此时队列为：

`2 4 1`  

同学 $3$ 已经不在队列中，忽略最后一条指令

最终队列：

`2 4 1`  

**【数据范围】**

对于 $20\%$ 的数据，$1\leq N\leq 10$。

对于 $40\%$ 的数据，$1\leq N\leq 1000$。

对于 $100\%$ 的数据，$1<M\leq N\leq 10^5$。

```c++
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
struct node {
    int L, R;
} a[100003];
int n, m;

inline void addRight(int x, int pos) { //插入右边 
    a[x].L = pos;
    a[a[pos].R].L = x;
    a[x].R = a[pos].R;
    a[pos].R = x;
}

inline void addLeft(int x, int pos) { //插入左边
    a[x].R = pos;
    a[a[pos].L].R = x;
    a[x].L = a[pos].L;
    a[pos].L = x;
}

inline void del(int x) {
    if (a[x].L == -1) return;
    a[a[x].L].R = a[x].R;
    a[a[x].R].L = a[x].L;
    a[x].L = -1;
    a[x].R = -1;
}

inline void go() {
    int x = a[0].R;
    while (1) {
        cout << x << " ";
        if (a[x].R == -1) break;
        x = a[x].R;
    }
}

inline void init() {
    for (int i = 1; i <= n; ++i) a[i].L = a[i].R = -1;
    a[1].R = -1;
    a[1].L = 0;
    a[0].R = 1;
}

int main() {
    scanf("%d", &n);
    int cmd1, cmd2;
    init();
    for (int i = 2; i <= n; ++i) {
        scanf("%d %d", &cmd1, &cmd2);
        if (!cmd2) addLeft(i, cmd1);
        else addRight(i, cmd1);
    }
    scanf("%d", &m);
    for (int i = 1; i <= m; ++i) {
        scanf("%d", &cmd1);
        del(cmd1);
    }
    go();
    return 0;
}
```



# [NOIP2010 提高组] 机器翻译

## 题目背景

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

## 题目描述

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

## 输入格式

共 $2$ 行。每行中两个数之间用一个空格隔开。

第一行为两个正整数 $M,N$，代表内存容量和文章的长度。

第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。

## 输出格式

一个整数，为软件需要查词典的次数。

## 样例 #1

### 样例输入 #1

```
3 7
1 2 1 5 4 4 1
```

### 样例输出 #1

```
5
```

## 提示

### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。

```c++
// luogu_list_6.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include <iostream>
#include <deque>
#include <set>

using namespace std;

int main() {
    int m, n, num;
    int times = 0;
    deque<int> mydeque;
    set<int> setmy;
    cin >> m >> n;
    while (n--) {
        cin >> num;
        if (setmy.find(num) != setmy.end()) {
            continue;
        }
        times++;
        if (mydeque.size() == m) {
            int temp = mydeque.front();
            mydeque.pop_front();
            setmy.erase(setmy.find(temp));
            mydeque.push_back(num);
            setmy.insert(num);
        } else {
            mydeque.push_back(num);
            setmy.insert(num);
        }
    }
    cout << times;
    return 0;
}
```



# [NOIP2016 普及组] 海港

## 题目背景

NOIP2016 普及组 T3

## 题目描述

小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。

小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 $i$ 艘到达的船，他记录了这艘船到达的时间 $t_i$ (单位：秒)，船上的乘客数 $k_i$，以及每名乘客的国籍 $x_{i,1}, x_{i,2},\dots,x_{i,k}$。

小K统计了 $n$ 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 $24$ 小时（$24$ 小时 $=86400$ 秒）内所有乘船到达的乘客来自多少个不同的国家。

形式化地讲，你需要计算 $n$ 条信息。对于输出的第 $i$ 条信息，你需要统计满足 $t_i-86400<t_p \le t_i$ 的船只 $p$，在所有的 $x_{p,j}$ 中，总共有多少个不同的数。

## 输入格式

第一行输入一个正整数 $n$，表示小 K 统计了 $n$ 艘船的信息。

接下来 $n$ 行，每行描述一艘船的信息：前两个整数 $t_i$ 和 $k_i$ 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 $k_i$ 个整数 $x_{i,j}$ 表示船上乘客的国籍。

保证输入的 $t_i$ 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 $t_i$ 秒到达海港。

保证 $1 \le n \le 10^5$，$\sum{k_i} \le 3\times 10^5 $ ，$1\le x_{i,j} \le 10^5$， $1 \le t_{i-1}\le  t_i    \le  10^9$。


其中 $\sum{k_i}$ 表示所有的 $k_i$ 的和。

## 输出格式

输出 $n$ 行，第 $i$ 行输出一个整数表示第 $i$ 艘船到达后的统计信息。

## 样例 #1

### 样例输入 #1

```
3
1 4 4 1 2 2
2 2 2 3
10 1 3
```

### 样例输出 #1

```
3
4
4
```

## 样例 #2

### 样例输入 #2

```
4
1 4 1 2 2 3
3 2 2 3
86401 2 3 4
86402 1 5
```

### 样例输出 #2

```
3
3
3
4
```

## 提示

【样例解释 1】

第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $4,1,2,2$，共来自 $3$ 个不同的国家；

第二艘船在第 $2$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4 + 2 = 6$ 个乘客，分别是来自国家 $4,1,2,2,2,3$，共来自 $4$ 个不同的国家；

第三艘船在第 $10$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船、第二艘船和第三艘船，共有 $4+2+1=7$ 个乘客，分别是来自国家 $4,1,2,2,2,3,3$，共来自 $4$ 个不同的国家。

【样例解释 2】

第一艘船在第 $1$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船，共有 $4$ 个乘客，分别是来自国家 $1,2,2,3$，共来自 $3$ 个不同的国家。

第二艘船在第 $3$ 秒到达海港，最近 $24$ 小时到达的船是第一艘船和第二艘船，共有 $4+2=6$ 个乘客，分别是来自国家 $1,2,2,3,2,3$，共来自 $3$ 个不同的国家。

第三艘船在第 $86401$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船和第三艘船，共有 $2+2=4$ 个乘客，分别是来自国家 $2,3,3,4$，共来自 $3$ 个不同的国家。

第四艘船在第 $86402$ 秒到达海港，最近 $24$ 小时到达的船是第二艘船、第三艘船和第四艘船，共有 $2+2+1=5$ 个乘客，分别是来自国家 $2,3,3,4,5$，共来自 $4$个 不同的国家。

【数据范围】

- 对于 $10\%$ 的测试点，$n=1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10$。
- 对于 $20\%$ 的测试点，$1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767$。
- 对于 $40\%$ 的测试点，$1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400$。
- 对于 $70\%$ 的测试点，$1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9$。
- 对于 $100\%$ 的测试点，$1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9$。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, h[N], ne[3 * N], idx, e[3 * N];
int ti[N], st[N], cnt;

void add(int a, int b) {
    e[idx] = b;
    ne[idx] = h[a];
    h[a] = idx++;
}

int main() {
    cin >> n;
    memset(h, -1, sizeof h);
    int num, id;
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &ti[i], &num);
        for (int j = 1; j <= num; j++) {
            scanf("%d", &id);
            add(i, id);
        }
    }
    for (int i = 1, j = 1; i <= n; ++i) {
        for (int t = h[i]; ~t; t = ne[t]) {
            if (st[e[t]] == 0) cnt++;
            st[e[t]]++;
        }
        while (j < i && ti[i] - ti[j] >= 86400) {
            for (int t = h[j]; ~t; t = ne[t]) {
                if (st[e[t]] == 1) cnt--;
                st[e[t]]--;
            }
            j++;
        }
        cout << cnt << endl;
    }
    return 0;
}
```



# 【深基15.习9】验证栈序列

## 题目描述

给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 $n(n\le100000)$。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 `Yes`，否则输出 `No`。为了防止骗分，每个测试点有多组数据。

## 输入格式

第一行一个整数 $q$，询问次数。

接下来 $q$ 个询问，对于每个询问：

第一行一个整数 $n$ 表示序列长度；

第二行 $n$ 个整数表示入栈序列；

第三行 $n$ 个整数表示出栈序列；

## 输出格式

对于每个询问输出答案。

## 样例 #1

### 样例输入 #1

```
2
5
1 2 3 4 5
5 4 3 2 1
4
1 2 3 4
2 4 1 3
```

### 样例输出 #1

```
Yes
No
```

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5 + 10;
int n, a[N], b[N];

void solve() {
    cin >> n;
    for (int i = 0; i < n; ++i) scanf("%d", &a[i]);
    for (int i = 0; i < n; ++i) scanf("%d", &b[i]);
    stack<int> s;
    for (int i = 0, j = 0; i < n; ++i) {
        s.push(a[i]);
        while (s.size() && s.top() == b[j]) {
            s.pop();
            j++;
        }
    }
    if (s.size()) cout << "No" << endl;
    else cout << "Yes" << endl;
}

int main() {
    int t;
    cin >> t;
    while (t--) solve();
    return 0;
}
```



# [HNOI2002]营业额统计

## 题目描述

Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。

Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。

而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。

我们定义，一天的最小波动值 = $\min\{|\text{该天以前某一天的营业额}-\text{该天营业额}|\}$。

特别地，第一天的最小波动值为第一天的营业额。

## 输入格式

第一行为正整数 $n$（$n \leq 32767$） ，表示该公司从成立一直到现在的天数，接下来的 $n$ 行每行有一个整数 $a_i$（$|a_i| \leq 10^6$) ，表示第 $i$ 天公司的营业额，可能存在负数。

## 输出格式

输出一个正整数，即每一天最小波动值的和，保证结果小于 $2^{31}$。

## 样例 #1

### 样例输入 #1

```
6
5
1
2
5
4
6
```

### 样例输出 #1

```
12
```

## 提示

结果说明：$5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|=5+4+1+0+1+1=12$

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 40000;
int n, g[N];

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) scanf("%d", &g[i]);
    int ans = 0;
    set<int> s;
    set<int>::iterator it1, it2;
    if (n > 0) {
        ans = g[1];
        s.insert(g[1]);
    }
    for (int i = 2; i <= n; ++i) {
        it1 = s.lower_bound(g[i]);
        if (it1 != s.begin()) {
            it2 = it1--;
            ans += min(abs(g[i] - *it1), abs(g[i] - *it2));
        } else {
            ans += abs(g[i] - *it1);
        }
        s.insert(g[i]);
    }
    cout << ans;
    return 0;
}
```

**注意第一天的最小波动值一定要特判，这是根据定义来确定的！！！**



- insert(x) 自动插入排序，时间O(logN)
- lower_bound(x) 耗时O(logN)查找离x最接近且大于x的数