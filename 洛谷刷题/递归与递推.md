# 数楼梯

## 题目描述

楼梯有 $N$ 阶，上楼可以一步上一阶，也可以一步上二阶。

编一个程序，计算共有多少种不同的走法。

## 输入格式

一个数字，楼梯数。

## 输出格式

输出走的方式总数。

## 样例 #1

### 样例输入 #1

```
4
```

### 样例输出 #1

```
5
```

## 提示

- 对于 $60\%$ 的数据，$N \leq 50$；   
- 对于 $100\%$ 的数据，$1 \le N \leq 5000$。



```c++
#include<bits/stdc++.h>

using namespace std;
typedef long long int LL;
const int N = 5010;

vector<int> f[N][3];
int n;

void add(int x, vector<int> &h) {
    int len = max(f[x - 1][1].size(), f[x - 1][2].size());

    int t = 0;
    for (int i = 0; i < len; ++i) {
        if (i < f[x - 1][1].size()) t += f[x - 1][1][i];
        if (i < f[x - 1][2].size()) t += f[x - 1][2][i];
        h.push_back(t % 10);
        t /= 10;
    }
    if (t) h.push_back(t);
}

int main() {
    cin >> n;

    f[1][1].push_back(1);
    f[2][2].push_back(1);
    f[2][1].push_back(1);
    for (int i = 3; i <= n; ++i) {
        add(i, f[i][1]);         //f[i-1][1]+f[i-1][2];
        add(i - 1, f[i][2]);       //f[i-2][1]+f[i-2][2];
    }

    vector<int> d;
    add(n + 1, d);
    for (int i = d.size() - 1; i >= 0; --i) printf("%d", d[i]);

    return 0;

} 
```

本题第一次尝试就直接 AC ，先整理经验。

看到题目首先想到的就是闫式 DP 分析法，然后直接在纸上画图，发现分析法是正确的，然后开始写程序，完成调试之后，发现题目数据较大，最终结果会超过一千位数字，所以即便是开 LL 也会爆。直接考虑高精度，这里使用了 vector 的二维数组配合高精度加法，顺利完成本题目。

![image-20230109085700816](%E5%BA%93/image-20230109085700816.png)







# [NOIP2003 普及组] 栈

## 题目背景

栈是计算机中经典的数据结构，简单的说，栈就是限制在一端进行插入删除操作的线性表。

栈有两种最重要的操作，即 pop（从栈顶弹出一个元素）和 push（将一个元素进栈）。

栈的重要性不言自明，任何一门数据结构的课程都会介绍栈。宁宁同学在复习栈的基本概念时，想到了一个书上没有讲过的问题，而他自己无法给出答案，所以需要你的帮忙。

## 题目描述

![](%E5%BA%93/18.png) 

宁宁考虑的是这样一个问题：一个操作数序列，$1,2,\ldots ,n$（图示为 1 到 3 的情况），栈 A 的深度大于 $n$。

现在可以进行两种操作，

1. 将一个数，从操作数序列的头端移到栈的头端（对应数据结构栈的 push 操作）
2. 将一个数，从栈的头端移到输出序列的尾端（对应数据结构栈的 pop 操作）

使用这两种操作，由一个操作数序列就可以得到一系列的输出序列，下图所示为由 `1 2 3` 生成序列 `2 3 1` 的过程。

![](%E5%BA%93/19.png) 

（原始状态如上图所示）

你的程序将对给定的 $n$，计算并输出由操作数序列 $1,2,\ldots,n$ 经过操作可能得到的输出序列的总数。

## 输入格式

输入文件只含一个整数 $n$（$1 \leq n \leq 18$）。

## 输出格式

输出文件只有一行，即可能输出序列的总数目。

## 样例 #1

### 样例输入 #1

```
3
```

### 样例输出 #1

```
5
```

## 提示

**【题目来源】**

NOIP 2003 普及组第三题



```c++
#include<bits/stdc++.h>

using namespace std;

int f(int n) {
    if (n == 0)return 1;
    if (n <= 2)return n;
    int sum = 0;
    for (int i = 0; i <= n - 1; ++i)sum += f(i) * f(n - i - 1);
    return sum;
}

int main() {
    int n;
    cin >> n;
    cout << f(n);
    return 0;
} 
```



递推：

对于`k`来说，总的合法的输出序列个数就是 `f(k-1)*f(n-k)`



看洛谷题解貌似是有四种做法：

- 递归、记忆化搜索
- 递归、DP
- 数论做法、卡特兰 Catalan
- 高精度、打表



# [NOIP2001 普及组] 数的计算

## 题目描述

给出自然数 $n$，要求按如下方式构造数列：

1. 只有一个数字 $n$ 的数列是一个合法的数列。
2. 在一个合法的数列的末尾加入一个自然数，但是这个自然数不能超过该数列最后一项的一半，可以得到一个新的合法数列。

请你求出，一共有多少个合法的数列。两个合法数列 $a, b$ 不同当且仅当两数列长度不同或存在一个正整数 $i \leq |a|$，使得 $a_i \neq b_i$。

## 输入格式

输入只有一行一个整数，表示 $n$。

## 输出格式

输出一行一个整数，表示合法的数列个数。

## 样例 #1

### 样例输入 #1

```
6
```

### 样例输出 #1

```
6
```

## 提示

### 样例 1 解释

满足条件的数列为：
- $6$
- $6, 1$
- $6, 2$
- $6, 3$
- $6, 2, 1$
- $6, 3, 1$

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^3$。

### 说明

本题数据来源是 NOIP 2001 普及组第一题，但是原题的题面描述和数据不符，故对题面进行了修改，使之符合数据。原题面如下，谨供参考：

> 我们要求找出具有下列性质数的个数（包含输入的正整数 $n$）。
>
> 先输入一个正整数 $n$（$n \le 1000$），然后对此正整数按照如下方法进行处理：
>
> 1. 不作任何处理；
> 2. 在它的左边拼接一个正整数，但该正整数不能超过原数，或者是上一个被拼接的数的一半；
> 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。

感谢 @[dbxxx](/user/120868) 对本题情况的反馈，原题面的问题见[本贴](https://www.luogu.com.cn/discuss/526184)。



```c++
#include<bits/stdc++.h>

using namespace std;

const int N = 1001;

int n;
int f[1001];//存每一位数的种类

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) { //1-n的递推
        for (int j = 1; j <= i / 2; j++) {
            f[i] += f[j]; //每一位叠加 递推走起
        }
        f[i]++; //加上本身
    }
    cout << f[n];//输出n的种类
    return 0;
}
```

总体来说，这道题是数学思想以及对递推的理解，自己推导一下还是做的出来



利用搜索找到所有结果，然后打表

下面是一个打表的代码例子，耗时大概十分钟左右，主要是学习如何打表——在代码上如何实现

```c++
#include <cstdio>
#include <iostream>

using namespace std;

long long dfs(int x) //深搜
{
    if (x == 1) return 1;
    long long tot = 1; //加上自身，所以初始化是 1 
    for (int i = 1; i <= x / 2; i++) //列举 
        tot += dfs(i);
    return tot;
}

int main() {
    cout << "a[1001]={";  //便于直接复制

    for (int i = 1; i <= 1000; i++) //枚举所有数 
        cout << dfs(i) << ",";

    cout << "}";

    return 0;
}
```



# [NOIP2002 普及组] 选数

## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。

## 输入格式

第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k<n$）。

第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。

## 输出格式

输出一个整数，表示种类数。

## 样例 #1

### 样例输入 #1

```
4 3
3 7 12 19
```

### 样例输出 #1

```
1
```

## 提示

**【题目来源】**

NOIP 2002 普及组第二题



```c++
#include<bits/stdc++.h>

using namespace std;
const int N = 25;

int n, k;
int a[N];
int num;
int cnt;
int sum;
bool st[N];

bool check(int num) {
    if (num < 2) return false;
    for (int i = 2; i <= num / i; ++i) {
        if (num % i == 0) return false;
    }
    return true;
}

void dfs(int x) {
    if (cnt == k) {
        if (check(num)) sum++;
        return;
    }
    if (x > n) return;
    cnt++;
    num += a[x - 1];
    dfs(x + 1);
    cnt--;
    num -= a[x - 1];
    dfs(x + 1);
}

int main() {
    cin >> n >> k;
    for (int i = 0; i < n; i++) cin >> a[i];

    dfs(1);

    cout << sum;

    return 0;
}
```



# [NOIP1998 普及组] 幂次方

## 题目描述

任何一个正整数都可以用 $2$ 的幂次方表示。例如 $137=2^7+2^3+2^0 $。

同时约定方次用括号来表示，即 $a^b$ 可表示为 $a(b)$。

由此可知，$137$ 可表示为 $2(7)+2(3)+2(0)$

进一步：

$7= 2^2+2+2^0$  ( $2^1$ 用 $2$ 表示)，并且 $3=2+2^0$。

所以最后 $137$ 可表示为 $2(2(2)+2+2(0))+2(2+2(0))+2(0)$。

又如 $1315=2^{10} +2^8 +2^5 +2+1$

所以 $1315$ 最后可表示为 $2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)$。

## 输入格式

一行一个正整数 $n$。

## 输出格式

符合约定的 $n$ 的 $0, 2$ 表示（在表示中不能有空格）。

## 样例 #1

### 样例输入 #1

```
1315
```

### 样例输出 #1

```
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
```

## 提示

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^4$。



```c++
#include <bits/stdc++.h>

using namespace std;
int n;

void search(int x) {

    int p = 1, q = 0;
    printf("2");
    //每一次搜索都要输出2
    //如果是1次幂就没必要写2(1)，后面会说;
    while (x >= p) {
        ++q;
        p *= 2;
    }
    //计算幂，由于这里会多算一次，所以计数器q-1;
    p /= 2;
    --q;
    if (q == 0 || q == 2) printf("(%d)", q);
    //各种括号的判断
    if (q >= 3) {
        printf("(");
        search(q);
        printf(")");
    }
    x -= p;
    //上面计数器就是多算了一次，因此p也多乘了一个2;
    if (x)//输入的数x为真（最后分解完就成0了，变成假），输出"+";
    {
        printf("+");
        search(x);
    }

}

int main() {
    cin >> n;
    search(n);
    return 0;
}
```



直接手打数据应该最快了

```c++
#include<bits/stdc++.h>

using namespace std;

int main() {

    int n;
    cin >> n;
    string s[16] = {"2(0)", "2", "2(2)", "2(2+2(0))", "2(2(2))", "2(2(2)+2(0))", "2(2(2)+2)", "2(2(2)+2+2(0))",
                    "2(2(2+2(0)))", "2(2(2+2(0))+1)", "2(2(2+2(0))+2)", "2(2(2+2(0))+2+2(0))", "2(2(2+2(0))+2(2))",
                    "2(2(2+2(0))+2(2)+2(0))", "2(2(2+2(0))+2(2)+2)", "2(2(2+2(0))+2(2)+2+2(0))"};
    bool temp = false;
    for (int i = 15; i >= 0; i--)
        if (pow(2, i) <= n) {
            n -= pow(2, i);
            if (temp) cout << '+';
            cout << s[i];
            temp = true;
        }
    return 0;
}
```

